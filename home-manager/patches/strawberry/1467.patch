From b10b6beded23353db8808c63d11bf54cdd708222 Mon Sep 17 00:00:00 2001
From: Jonas Kvinge <jonas@jkvinge.net>
Date: Fri, 21 Jun 2024 16:36:40 +0200
Subject: [PATCH] Add visualizations

---
 .github/workflows/build.yml                   |   9 +
 CMakeLists.txt                                |  38 +-
 debian/control                                |   3 +-
 dist/unix/strawberry.spec.in                  |   1 +
 src/analyzer/analyzercontainer.cpp            |  21 +-
 src/analyzer/analyzercontainer.h              |   4 +
 src/config.h.in                               |   3 +
 src/core/mainwindow.cpp                       |  33 ++
 src/core/mainwindow.h                         |   6 +
 src/core/mainwindow.ui                        |   6 +
 src/engine/gstbufferconsumer.h                |   2 +-
 src/engine/gstengine.cpp                      |   4 +-
 src/engine/gstengine.h                        |   2 +-
 src/engine/gstenginepipeline.cpp              |   2 +-
 src/visualizations/projectmpresetmodel.cpp    | 159 ++++++
 src/visualizations/projectmpresetmodel.h      |  77 +++
 src/visualizations/projectmvisualization.cpp  | 469 ++++++++++++++++++
 src/visualizations/projectmvisualization.h    | 114 +++++
 src/visualizations/visualizationcontainer.cpp | 328 ++++++++++++
 src/visualizations/visualizationcontainer.h   | 103 ++++
 .../visualizationopenglwidget.cpp             |  39 ++
 .../visualizationopenglwidget.h               |  42 ++
 src/visualizations/visualizationoverlay.cpp   | 116 +++++
 src/visualizations/visualizationoverlay.h     |  71 +++
 src/visualizations/visualizationoverlay.ui    | 234 +++++++++
 src/visualizations/visualizationselector.cpp  |  88 ++++
 src/visualizations/visualizationselector.h    |  61 +++
 src/visualizations/visualizationselector.ui   | 140 ++++++
 28 files changed, 2168 insertions(+), 7 deletions(-)
 create mode 100644 src/visualizations/projectmpresetmodel.cpp
 create mode 100644 src/visualizations/projectmpresetmodel.h
 create mode 100644 src/visualizations/projectmvisualization.cpp
 create mode 100644 src/visualizations/projectmvisualization.h
 create mode 100644 src/visualizations/visualizationcontainer.cpp
 create mode 100644 src/visualizations/visualizationcontainer.h
 create mode 100644 src/visualizations/visualizationopenglwidget.cpp
 create mode 100644 src/visualizations/visualizationopenglwidget.h
 create mode 100644 src/visualizations/visualizationoverlay.cpp
 create mode 100644 src/visualizations/visualizationoverlay.h
 create mode 100644 src/visualizations/visualizationoverlay.ui
 create mode 100644 src/visualizations/visualizationselector.cpp
 create mode 100644 src/visualizations/visualizationselector.h
 create mode 100644 src/visualizations/visualizationselector.ui

diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index b66e695947..aefe15940a 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -62,6 +62,7 @@ jobs:
             libchromaprint-devel
             fftw3-devel
             libebur128-devel
+            projectM-devel
             desktop-file-utils
             update-desktop-files
             appstream-glib
@@ -79,6 +80,7 @@ jobs:
             qt6-linguist-devel
             gtest
             gmock
+            qt6-opengl-devel
       - name: Install kdsingleapplication-qt6-devel
         if: matrix.opensuse_version == 'tumbleweed'
         run: zypper -n --gpg-auto-import-keys in kdsingleapplication-qt6-devel
@@ -186,6 +188,7 @@ jobs:
             libchromaprint-devel
             libebur128-devel
             fftw-devel
+            libprojectM-devel
             desktop-file-utils
             libappstream-glib
             hicolor-icon-theme
@@ -275,6 +278,7 @@ jobs:
           lib64Qt6DBus-devel
           lib64Qt6Gui-devel
           lib64Qt6Widgets-devel
+          lib64Qt6OpenGL-devel
           lib64Qt6Test-devel
           qt6-cmake
           qt6-qtbase-tools
@@ -369,6 +373,7 @@ jobs:
           lib64fftw-devel
           lib64dbus-devel
           lib64appstream-devel
+          lib64projectm-devel
           lib64qt6core-devel
           lib64qt6gui-devel
           lib64qt6widgets-devel
@@ -378,6 +383,7 @@ jobs:
           lib64qt6dbus-devel
           lib64qt6help-devel
           lib64qt6test-devel
+          lib64qt6opengl-devel
           desktop-file-utils
           appstream-util
           hicolor-icon-theme
@@ -469,6 +475,7 @@ jobs:
             qt6-tools-dev
             qt6-tools-dev-tools
             qt6-l10n-tools
+            libprojectm-dev
       - name: Checkout
         uses: actions/checkout@v4
         with:
@@ -550,6 +557,7 @@ jobs:
             qt6-tools-dev
             qt6-tools-dev-tools
             qt6-l10n-tools
+            libprojectm-dev
       - name: Checkout
         uses: actions/checkout@v4
         with:
@@ -632,6 +640,7 @@ jobs:
             qt6-l10n-tools
             gstreamer1.0-alsa
             gstreamer1.0-pulseaudio
+            libprojectm-dev
       - name: Install keyboxd
         if: matrix.ubuntu_version == 'noble'
         env:
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7338dc3f98..b3c2cd3241 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -205,13 +205,22 @@ else()
   pkg_check_modules(TAGLIB REQUIRED IMPORTED_TARGET taglib>=1.12)
 endif()
 
+find_package(projectM4 COMPONENTS Playlist)
+if(projectM4_FOUND)
+  set(LIBPROJECTM_FOUND ON)
+  set(HAVE_PROJECTM4 ON)
+  set(LIBPROJECTM_LIBRARIES libprojectM::projectM libprojectM::playlist)
+else()
+  pkg_check_modules(LIBPROJECTM libprojectM)
+endif()
+
 find_package(GTest)
 
 set(QT_VERSION_MAJOR 6)
 set(QT_MIN_VERSION 6.4.0)
 set(QT_DEFAULT_MAJOR_VERSION ${QT_VERSION_MAJOR})
 set(QT_COMPONENTS Core Concurrent Gui Widgets Network Sql)
-set(QT_OPTIONAL_COMPONENTS LinguistTools Test)
+set(QT_OPTIONAL_COMPONENTS OpenGLWidgets LinguistTools Test)
 if(UNIX AND NOT APPLE)
   list(APPEND QT_OPTIONAL_COMPONENTS DBus)
 endif()
@@ -380,6 +389,11 @@ if(HAVE_X11_GLOBALSHORTCUTS OR HAVE_KGLOBALACCEL_GLOBALSHORTCUTS OR APPLE OR WIN
   set(HAVE_GLOBALSHORTCUTS ON)
 endif()
 
+optional_component(VISUALIZATIONS ON "Visualizations"
+  DEPENDS "libprojectm" LIBPROJECTM_FOUND
+  DEPENDS "QtOpenGLWidgets" Qt${QT_VERSION_MAJOR}OpenGLWidgets_FOUND
+)
+
 if(NOT CMAKE_CROSSCOMPILING)
   # Check that we have Qt with sqlite driver
   set(CMAKE_REQUIRED_FLAGS "-std=c++17")
@@ -1455,6 +1469,26 @@ optional_source(HAVE_QOBUZ
     src/settings/qobuzsettingspage.ui
 )
 
+optional_source(HAVE_VISUALIZATIONS
+  SOURCES
+    src/visualizations/projectmpresetmodel.cpp
+    src/visualizations/projectmvisualization.cpp
+    src/visualizations/visualizationcontainer.cpp
+    src/visualizations/visualizationoverlay.cpp
+    src/visualizations/visualizationselector.cpp
+    src/visualizations/visualizationopenglwidget.cpp
+  HEADERS
+    src/visualizations/projectmpresetmodel.h
+    src/visualizations/projectmvisualization.h
+    src/visualizations/visualizationcontainer.h
+    src/visualizations/visualizationoverlay.h
+    src/visualizations/visualizationselector.h
+    src/visualizations/visualizationopenglwidget.h
+  UI
+    src/visualizations/visualizationoverlay.ui
+    src/visualizations/visualizationselector.ui
+)
+
 qt_wrap_cpp(SOURCES ${HEADERS})
 qt_wrap_ui(SOURCES ${UI})
 qt_add_resources(SOURCES data/data.qrc data/icons.qrc)
@@ -1523,6 +1557,7 @@ target_link_libraries(strawberry_lib PUBLIC
   Qt${QT_VERSION_MAJOR}::Network
   Qt${QT_VERSION_MAJOR}::Sql
   $<$<BOOL:${HAVE_DBUS}>:Qt${QT_VERSION_MAJOR}::DBus>
+  $<$<BOOL:${HAVE_VISUALIZATIONS}>:Qt${QT_VERSION_MAJOR}::OpenGLWidgets>
   ICU::uc
   ICU::i18n
   $<$<BOOL:${HAVE_ALSA}>:ALSA::ALSA>
@@ -1537,6 +1572,7 @@ target_link_libraries(strawberry_lib PUBLIC
   $<$<BOOL:${HAVE_MTP}>:PkgConfig::LIBMTP>
   $<$<BOOL:${HAVE_GPOD}>:PkgConfig::LIBGPOD PkgConfig::GDK_PIXBUF>
   $<$<BOOL:${HAVE_QTSPARKLE}>:qtsparkle-qt${QT_VERSION_MAJOR}::qtsparkle>
+  $<$<BOOL:${HAVE_VISUALIZATIONS}>:${LIBPROJECTM_LIBRARIES}>
   $<$<BOOL:${WIN32}>:dsound dwmapi getopt-win::getopt>
   $<$<BOOL:${MSVC}>:WindowsApp>
   ${SINGLEAPPLICATION_LIBRARIES}
diff --git a/debian/control b/debian/control
index cc69f3037a..652bb92bf3 100644
--- a/debian/control
+++ b/debian/control
@@ -27,7 +27,8 @@ Build-Depends: debhelper-compat (= 12),
                libmtp-dev,
                libchromaprint-dev,
                libfftw3-dev,
-               libebur128-dev
+               libebur128-dev,
+               libprojectm-dev
 Standards-Version: 4.7.0
 
 Package: strawberry
diff --git a/dist/unix/strawberry.spec.in b/dist/unix/strawberry.spec.in
index f5253e1626..d690a907c8 100644
--- a/dist/unix/strawberry.spec.in
+++ b/dist/unix/strawberry.spec.in
@@ -43,6 +43,7 @@ BuildRequires:  pkgconfig(taglib)
 BuildRequires:  pkgconfig(fftw3)
 BuildRequires:  pkgconfig(icu-uc)
 BuildRequires:  pkgconfig(icu-i18n)
+BuildRequires:  pkgconfig(libprojectM)
 BuildRequires:  cmake(Qt@QT_VERSION_MAJOR@Core)
 BuildRequires:  cmake(Qt@QT_VERSION_MAJOR@Concurrent)
 BuildRequires:  cmake(Qt@QT_VERSION_MAJOR@Network)
diff --git a/src/analyzer/analyzercontainer.cpp b/src/analyzer/analyzercontainer.cpp
index ad25ad68e1..3747935c34 100644
--- a/src/analyzer/analyzercontainer.cpp
+++ b/src/analyzer/analyzercontainer.cpp
@@ -73,7 +73,8 @@ AnalyzerContainer::AnalyzerContainer(QWidget *parent)
       double_click_timer_(new QTimer(this)),
       ignore_next_click_(false),
       current_analyzer_(nullptr),
-      engine_(nullptr) {
+      engine_(nullptr),
+      action_visualization_(nullptr) {
 
   QHBoxLayout *layout = new QHBoxLayout(this);
   setLayout(layout);
@@ -118,6 +119,17 @@ void AnalyzerContainer::mouseReleaseEvent(QMouseEvent *e) {
 
 }
 
+void AnalyzerContainer::mouseDoubleClickEvent(QMouseEvent *e) {
+
+  Q_UNUSED(e);
+
+  double_click_timer_->stop();
+  ignore_next_click_ = true;
+
+  if (action_visualization_) action_visualization_->trigger();
+
+}
+
 void AnalyzerContainer::ShowPopupMenu() {
   context_menu_->popup(last_click_pos_);
 }
@@ -249,3 +261,10 @@ void AnalyzerContainer::AddFramerate(const QString &name, const int framerate) {
   QObject::connect(action, &QAction::triggered, this, [this, framerate]() { ChangeFramerate(framerate); } );
 
 }
+
+void AnalyzerContainer::SetVisualizationsAction(QAction *visualization) {
+
+  action_visualization_ = visualization;
+  context_menu_->addAction(action_visualization_);
+
+}
diff --git a/src/analyzer/analyzercontainer.h b/src/analyzer/analyzercontainer.h
index 20f36eafac..412e93a06d 100644
--- a/src/analyzer/analyzercontainer.h
+++ b/src/analyzer/analyzercontainer.h
@@ -46,6 +46,7 @@ class AnalyzerContainer : public QWidget {
   explicit AnalyzerContainer(QWidget *parent);
 
   void SetEngine(SharedPtr<EngineBase> engine);
+  void SetVisualizationsAction(QAction *visualization);
 
   static const char *kSettingsGroup;
   static const char *kSettingsFramerate;
@@ -55,6 +56,7 @@ class AnalyzerContainer : public QWidget {
 
  protected:
   void mouseReleaseEvent(QMouseEvent *e) override;
+  void mouseDoubleClickEvent(QMouseEvent *e) override;
   void wheelEvent(QWheelEvent *e) override;
 
  private Q_SLOTS:
@@ -89,6 +91,8 @@ class AnalyzerContainer : public QWidget {
 
   AnalyzerBase *current_analyzer_;
   SharedPtr<EngineBase> engine_;
+
+  QAction *action_visualization_;
 };
 
 template<typename T>
diff --git a/src/config.h.in b/src/config.h.in
index 492829e877..84df112ed2 100644
--- a/src/config.h.in
+++ b/src/config.h.in
@@ -46,4 +46,7 @@
 
 #cmakedefine ENABLE_WIN32_CONSOLE
 
+#cmakedefine HAVE_VISUALIZATIONS
+#cmakedefine HAVE_PROJECTM4
+
 #endif // CONFIG_H_IN
diff --git a/src/core/mainwindow.cpp b/src/core/mainwindow.cpp
index 1cac9fa01e..b019cfa290 100644
--- a/src/core/mainwindow.cpp
+++ b/src/core/mainwindow.cpp
@@ -208,6 +208,11 @@
 
 #include "organize/organizeerrordialog.h"
 
+#ifdef HAVE_VISUALIZATIONS
+#  include "visualizations/visualizationcontainer.h"
+#  include "engine/gstengine.h"
+#endif
+
 #ifdef Q_OS_WIN
 #  include "core/windows7thumbbar.h"
 #endif
@@ -617,6 +622,12 @@ MainWindow::MainWindow(Application *app, SharedPtr<SystemTrayIcon> tray_icon, OS
   stop_menu->addAction(ui_->action_stop_after_this_track);
   ui_->stop_button->setMenu(stop_menu);
 
+#ifdef HAVE_VISUALIZATIONS
+  QObject::connect(ui_->action_visualizations, &QAction::triggered, this, &MainWindow::ShowVisualizations);
+#else
+  ui_->action_visualizations->setEnabled(false);
+#endif
+
   // Player connections
   QObject::connect(ui_->volume, &VolumeSlider::valueChanged, &*app_->player(), &Player::SetVolumeFromSlider);
 
@@ -901,6 +912,7 @@ MainWindow::MainWindow(Application *app, SharedPtr<SystemTrayIcon> tray_icon, OS
 
   // Analyzer
   QObject::connect(ui_->analyzer, &AnalyzerContainer::WheelEvent, this, &MainWindow::VolumeWheelEvent);
+  ui_->analyzer->SetVisualizationsAction(ui_->action_visualizations);
 
   // Statusbar widgets
   ui_->playlist_summary->setMinimumWidth(QFontMetrics(font()).horizontalAdvance(u"WW selected of WW tracks - [ WW:WW ]"_s));
@@ -3354,3 +3366,24 @@ void MainWindow::FocusSearchField() {
   }
 
 }
+
+void MainWindow::ShowVisualizations() {
+
+#ifdef HAVE_VISUALIZATIONS
+
+  if (!visualization_) {
+    visualization_.reset(new VisualizationContainer);
+
+    visualization_->SetActions(ui_->action_previous_track, ui_->action_play_pause, ui_->action_stop, ui_->action_next_track);
+    connect(&*app_->player(), &Player::Stopped, &*visualization_, &VisualizationContainer::Stopped);
+    connect(&*app_->player(), &Player::ForceShowOSD, &*visualization_, &VisualizationContainer::SongMetadataChanged);
+    connect(&*app_->playlist_manager(), &PlaylistManager::CurrentSongChanged, &*visualization_, &VisualizationContainer::SongMetadataChanged);
+
+    visualization_->SetEngine(qobject_cast<GstEngine*>(&*app_->player()->engine()));
+  }
+
+  visualization_->show();
+
+#endif  // HAVE_VISUALIZATIONS
+
+}
diff --git a/src/core/mainwindow.h b/src/core/mainwindow.h
index 54af2685e0..814365d3b0 100644
--- a/src/core/mainwindow.h
+++ b/src/core/mainwindow.h
@@ -98,6 +98,7 @@ class Windows7ThumbBar;
 class AddStreamDialog;
 class LastFMImportDialog;
 class RadioViewContainer;
+class VisualizationContainer;
 
 class MainWindow : public QMainWindow, public PlatformInterface {
   Q_OBJECT
@@ -266,6 +267,7 @@ class MainWindow : public QMainWindow, public PlatformInterface {
  public Q_SLOTS:
   void CommandlineOptionsReceived(const QByteArray &string_options);
   void Raise();
+  void ShowVisualizations();
 
  private:
 
@@ -345,6 +347,10 @@ class MainWindow : public QMainWindow, public PlatformInterface {
 
   LastFMImportDialog *lastfm_import_dialog_;
 
+#ifdef HAVE_VISUALIZATIONS
+  ScopedPtr<VisualizationContainer> visualization_;
+#endif
+
   QAction *collection_show_all_;
   QAction *collection_show_duplicates_;
   QAction *collection_show_untagged_;
diff --git a/src/core/mainwindow.ui b/src/core/mainwindow.ui
index 345af71afc..a3bb795f49 100644
--- a/src/core/mainwindow.ui
+++ b/src/core/mainwindow.ui
@@ -521,6 +521,7 @@
     <addaction name="action_cover_manager"/>
     <addaction name="action_equalizer"/>
     <addaction name="action_transcoder"/>
+    <addaction name="action_visualizations"/>
     <addaction name="separator"/>
     <addaction name="action_update_collection"/>
     <addaction name="action_full_collection_scan"/>
@@ -867,6 +868,11 @@
     <string>Import data from last.fm...</string>
    </property>
   </action>
+  <action name="action_visualizations">
+    <property name="text">
+      <string>Visualizations</string>
+    </property>
+  </action>
  </widget>
  <layoutdefault spacing="6" margin="11"/>
  <customwidgets>
diff --git a/src/engine/gstbufferconsumer.h b/src/engine/gstbufferconsumer.h
index e6823812b4..5c1b0cf151 100644
--- a/src/engine/gstbufferconsumer.h
+++ b/src/engine/gstbufferconsumer.h
@@ -36,7 +36,7 @@ class GstBufferConsumer {
 
   // This is called in some unspecified GStreamer thread.
   // Ownership of the buffer is transferred to the BufferConsumer, and it should gst_buffer_unref it.
-  virtual void ConsumeBuffer(GstBuffer *buffer, const int pipeline_id, const QString &format) = 0;
+  virtual void ConsumeBuffer(GstBuffer *buffer, const int pipeline_id, const QString &format, const int channels) = 0;
 
  private:
   Q_DISABLE_COPY(GstBufferConsumer)
diff --git a/src/engine/gstengine.cpp b/src/engine/gstengine.cpp
index 8457f58461..01a86d6bc7 100644
--- a/src/engine/gstengine.cpp
+++ b/src/engine/gstengine.cpp
@@ -522,7 +522,9 @@ void GstEngine::ReloadSettings() {
 
 }
 
-void GstEngine::ConsumeBuffer(GstBuffer *buffer, const int pipeline_id, const QString &format) {
+void GstEngine::ConsumeBuffer(GstBuffer *buffer, const int pipeline_id, const QString &format, const int channels) {
+
+  Q_UNUSED(channels);
 
   // Schedule this to run in the GUI thread.  The buffer gets added to the queue and unreffed by UpdateScope.
   if (!QMetaObject::invokeMethod(this, "AddBufferToScope", Q_ARG(GstBuffer*, buffer), Q_ARG(int, pipeline_id), Q_ARG(QString, format))) {
diff --git a/src/engine/gstengine.h b/src/engine/gstengine.h
index 1b3ecf05f6..af745934a9 100644
--- a/src/engine/gstengine.h
+++ b/src/engine/gstengine.h
@@ -83,7 +83,7 @@ class GstEngine : public EngineBase, public GstBufferConsumer {
   bool ALSADeviceSupport(const QString &output) const override;
   bool ExclusiveModeSupport(const QString &output) const override;
 
-  void ConsumeBuffer(GstBuffer *buffer, const int pipeline_id, const QString &format) override;
+  void ConsumeBuffer(GstBuffer *buffer, const int pipeline_id, const QString &format, const int channels) override;
 
  public Q_SLOTS:
   void ReloadSettings() override;
diff --git a/src/engine/gstenginepipeline.cpp b/src/engine/gstenginepipeline.cpp
index 7322bf7581..2fda3d77b9 100644
--- a/src/engine/gstenginepipeline.cpp
+++ b/src/engine/gstenginepipeline.cpp
@@ -1328,7 +1328,7 @@ GstPadProbeReturn GstEnginePipeline::BufferProbeCallback(GstPad *pad, GstPadProb
 
   for (GstBufferConsumer *consumer : std::as_const(consumers)) {
     gst_buffer_ref(buf);
-    consumer->ConsumeBuffer(buf, instance->id(), format);
+    consumer->ConsumeBuffer(buf, instance->id(), format, channels);
   }
 
   if (buf16) {
diff --git a/src/visualizations/projectmpresetmodel.cpp b/src/visualizations/projectmpresetmodel.cpp
new file mode 100644
index 0000000000..e6a8958f8b
--- /dev/null
+++ b/src/visualizations/projectmpresetmodel.cpp
@@ -0,0 +1,159 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <QAbstractItemModel>
+#include <QString>
+#include <QStringList>
+#include <QFileInfo>
+#include <QDir>
+#include <QDirIterator>
+
+#include "core/logging.h"
+
+#include "projectmpresetmodel.h"
+#include "projectmvisualization.h"
+
+ProjectMPresetModel::ProjectMPresetModel(ProjectMVisualization *projectm_visualization, QObject *parent)
+    : QAbstractItemModel(parent),
+      projectm_visualization_(projectm_visualization) {
+
+  // Find presets
+  if (QFileInfo::exists(projectm_visualization_->preset_path())) {
+    QDirIterator it(projectm_visualization_->preset_path(), QStringList() << QStringLiteral("*.milk") << QStringLiteral("*.prjm"), QDir::Files | QDir::NoDotAndDotDot | QDir::Readable, QDirIterator::Subdirectories);
+    QStringList files;
+    while (it.hasNext()) {
+      it.next();
+      files << it.filePath();
+    }
+    std::stable_sort(files.begin(), files.end());
+    for (const QString &filepath : std::as_const(files)) {
+      const QFileInfo fileinfo(filepath);
+      all_presets_ << Preset(fileinfo.filePath(), fileinfo.fileName(), false);
+    }
+  }
+  else {
+    qLog(Error) << "ProjectM preset path" << projectm_visualization_->preset_path() << "does not exist";
+  }
+
+}
+
+int ProjectMPresetModel::rowCount(const QModelIndex &idx) const {
+
+  Q_UNUSED(idx);
+
+  if (!projectm_visualization_) return 0;
+
+  return static_cast<int>(all_presets_.count());
+
+}
+
+int ProjectMPresetModel::columnCount(const QModelIndex &idx) const {
+  Q_UNUSED(idx);
+  return 1;
+}
+
+QModelIndex ProjectMPresetModel::index(const int row, const int column, const QModelIndex &idx) const {
+  Q_UNUSED(idx);
+  return createIndex(row, column);
+}
+
+QModelIndex ProjectMPresetModel::parent(const QModelIndex &child) const {
+  Q_UNUSED(child);
+  return QModelIndex();
+}
+
+QVariant ProjectMPresetModel::data(const QModelIndex &index, const int role) const {
+
+  switch (role) {
+    case Qt::DisplayRole:
+      return all_presets_[index.row()].name_;
+    case Qt::CheckStateRole:{
+      bool selected = all_presets_[index.row()].selected_;
+      return selected ? Qt::Checked : Qt::Unchecked;
+    }
+    case Role::Role_Path:
+      return all_presets_[index.row()].path_;
+    default:
+      return QVariant();
+  }
+
+}
+
+Qt::ItemFlags ProjectMPresetModel::flags(const QModelIndex &idx) const {
+
+  if (!idx.isValid()) return QAbstractItemModel::flags(idx);
+  return Qt::ItemIsSelectable | Qt::ItemIsEditable | Qt::ItemIsUserCheckable | Qt::ItemIsEnabled;
+
+}
+
+bool ProjectMPresetModel::setData(const QModelIndex &idx, const QVariant &value, int role) {
+
+  if (role == Qt::CheckStateRole) {
+    all_presets_[idx.row()].selected_ = value.toBool();
+    projectm_visualization_->SetSelected(QStringList() << all_presets_[idx.row()].path_, value.toBool());
+    return true;
+  }
+
+  return false;
+
+}
+
+void ProjectMPresetModel::SetImmediatePreset(const QModelIndex &idx) {
+  projectm_visualization_->SetImmediatePreset(all_presets_[idx.row()].path_);
+}
+
+void ProjectMPresetModel::SelectAll() {
+
+  QStringList paths;
+  paths.reserve(all_presets_.count());
+  for (int i = 0; i < all_presets_.count(); ++i) {
+    paths << all_presets_[i].path_;
+    all_presets_[i].selected_ = true;
+  }
+  projectm_visualization_->SetSelected(paths, true);
+
+  Q_EMIT dataChanged(index(0, 0), index(rowCount() - 1, 0));
+
+}
+
+void ProjectMPresetModel::SelectNone() {
+
+  projectm_visualization_->ClearSelected();
+  for (int i = 0; i < all_presets_.count(); ++i) {
+    all_presets_[i].selected_ = false;
+  }
+
+  Q_EMIT dataChanged(index(0, 0), index(rowCount() - 1, 0));
+
+}
+
+void ProjectMPresetModel::MarkSelected(const QString &path, const bool selected) {
+
+  for (int i = 0; i < all_presets_.count(); ++i) {
+    if (path == all_presets_[i].path_) {
+      all_presets_[i].selected_ = selected;
+      return;
+    }
+  }
+
+}
diff --git a/src/visualizations/projectmpresetmodel.h b/src/visualizations/projectmpresetmodel.h
new file mode 100644
index 0000000000..f32ff75f05
--- /dev/null
+++ b/src/visualizations/projectmpresetmodel.h
@@ -0,0 +1,77 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef PROJECTMPRESETMODEL_H
+#define PROJECTMPRESETMODEL_H
+
+#include "config.h"
+
+#include <QList>
+#include <QString>
+#include <QAbstractItemModel>
+
+class ProjectMVisualization;
+
+class ProjectMPresetModel : public QAbstractItemModel {
+  Q_OBJECT
+
+  friend class ProjectMVisualization;
+
+ public:
+  explicit ProjectMPresetModel(ProjectMVisualization *projectm_visualization, QObject *parent = nullptr);
+
+  enum Role {
+    Role_Path = Qt::UserRole,
+  };
+
+  void MarkSelected(const QString &path, bool selected);
+
+  // QAbstractItemModel
+  QModelIndex index(const int row, const int column, const QModelIndex &parent = QModelIndex()) const override;
+  QModelIndex parent(const QModelIndex &child) const override;
+  int rowCount(const QModelIndex &parent = QModelIndex()) const override;
+  int columnCount(const QModelIndex &parent = QModelIndex()) const override;
+  QVariant data(const QModelIndex &index, const int role = Qt::DisplayRole) const override;
+  Qt::ItemFlags flags(const QModelIndex &index) const override;
+  bool setData(const QModelIndex &index, const QVariant &value, const int role = Qt::EditRole) override;
+
+ public Q_SLOTS:
+  void SetImmediatePreset(const QModelIndex &index);
+  void SelectAll();
+  void SelectNone();
+
+ private:
+  struct Preset {
+    explicit Preset(const QString &path, const QString &name, const bool selected)
+        : path_(path),
+          name_(name),
+          selected_(selected) {}
+
+    QString path_;
+    QString name_;
+    bool selected_;
+  };
+
+  ProjectMVisualization *projectm_visualization_;
+  QList<Preset> all_presets_;
+};
+
+#endif  // PROJECTMPRESETMODEL_H
diff --git a/src/visualizations/projectmvisualization.cpp b/src/visualizations/projectmvisualization.cpp
new file mode 100644
index 0000000000..f4f57d9210
--- /dev/null
+++ b/src/visualizations/projectmvisualization.cpp
@@ -0,0 +1,469 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <string>
+#include <memory>
+
+#ifdef HAVE_PROJECTM4
+#  include <projectM-4/types.h>
+#  include <projectM-4/core.h>
+#  include <projectM-4/parameters.h>
+#  include <projectM-4/memory.h>
+#  include <projectM-4/audio.h>
+#  include <projectM-4/render_opengl.h>
+#  include <projectM-4/playlist_types.h>
+#  include <projectM-4/playlist_core.h>
+#  include <projectM-4/playlist_memory.h>
+#  include <projectM-4/playlist_items.h>
+#  include <projectM-4/playlist_playback.h>
+#else
+#  include <libprojectM/projectM.hpp>
+#endif  // HAVE_PROJECTM4
+
+#include <QCoreApplication>
+#include <QGraphicsScene>
+#include <QString>
+#include <QStringList>
+#include <QDir>
+#include <QFileInfo>
+#include <QScopeGuard>
+#include <QPainter>
+#include <QRandomGenerator>
+#include <QMessageBox>
+#include <QTimerEvent>
+
+#include "core/logging.h"
+#include "core/settings.h"
+#include "projectmvisualization.h"
+#include "projectmpresetmodel.h"
+#include "visualizationcontainer.h"
+
+ProjectMVisualization::ProjectMVisualization(VisualizationContainer *container)
+    : QGraphicsScene(container),
+      container_(container),
+      preset_model_(nullptr),
+#ifdef HAVE_PROJECTM4
+      projectm_instance_(nullptr),
+      projectm_playlist_instance_(nullptr),
+#endif
+      mode_(Mode::Random),
+      duration_(15),
+      texture_size_(512) {
+
+  QObject::connect(this, &QGraphicsScene::sceneRectChanged, this, &ProjectMVisualization::SceneRectChanged);
+
+#ifndef HAVE_PROJECTM4
+  for (int i = 0; i < TOTAL_RATING_TYPES; ++i) {
+    default_rating_list_.push_back(3);
+  }
+#endif  // HAVE_PROJECTM4
+
+}
+
+ProjectMVisualization::~ProjectMVisualization() {
+
+#ifdef HAVE_PROJECTM4
+  if (projectm_playlist_instance_) {
+    projectm_playlist_destroy(projectm_playlist_instance_);
+  }
+  if (projectm_instance_) {
+    projectm_destroy(projectm_instance_);
+  }
+#endif  // HAVE_PROJECTM4
+
+}
+
+void ProjectMVisualization::Init() {
+
+#ifdef HAVE_PROJECTM4
+  if (projectm_instance_) {
+    return;
+  }
+#else
+  if (projectm_) {
+    return;
+  }
+#endif  // HAVE_PROJECTM4
+
+  // Find the projectM presets
+
+  QStringList data_paths = QStringList() << QStringLiteral("/usr/share")
+                                         << QStringLiteral("/usr/local/share")
+                                         << QLatin1String(CMAKE_INSTALL_PREFIX) + QLatin1String("/share");
+
+  const QStringList xdg_data_dirs = QString::fromUtf8(qgetenv("XDG_DATA_DIRS")).split(QLatin1Char(':'));
+  for (const QString &xdg_data_dir : xdg_data_dirs) {
+    if (!data_paths.contains(xdg_data_dir)) {
+      data_paths.append(xdg_data_dir);
+    }
+  }
+
+#if defined(Q_OS_WIN32)
+  data_paths.prepend(QCoreApplication::applicationDirPath());
+#endif
+
+  const QStringList projectm_paths = QStringList() << QStringLiteral("projectM/presets")
+                                                   << QStringLiteral("projectm-presets");
+
+  QStringList preset_paths;
+  for (const QString &data_path : std::as_const(data_paths)) {
+    for (const QString &projectm_path : projectm_paths) {
+      const QString path = data_path + QLatin1Char('/') + projectm_path;
+      if (!QFileInfo::exists(path) || QDir(path).entryList(QDir::Dirs | QDir::Files | QDir::NoDotAndDotDot).isEmpty()) {
+        preset_paths << path;
+        continue;
+      }
+      preset_path_ = path;
+      break;
+    }
+  }
+
+  // Create projectM settings
+#ifdef HAVE_PROJECTM4
+  Q_ASSERT(projectm_instance_ == nullptr);
+  Q_ASSERT(projectm_playlist_instance_ == nullptr);
+  projectm_instance_ = projectm_create();
+  projectm_set_preset_duration(projectm_instance_, duration_);
+  projectm_set_mesh_size(projectm_instance_, 32, 24);
+  projectm_set_fps(projectm_instance_, 35);
+  projectm_set_window_size(projectm_instance_, 512, 512);
+  projectm_playlist_instance_ = projectm_playlist_create(projectm_instance_);
+#else
+  projectM::Settings s;
+  s.presetURL = preset_path_.toStdString();
+  s.meshX = 32;
+  s.meshY = 24;
+  s.textureSize = texture_size_;
+  s.fps = 35;
+  s.windowWidth = 512;
+  s.windowHeight = 512;
+  s.smoothPresetDuration = 5;
+  s.presetDuration = duration_;
+  s.shuffleEnabled = true;
+  s.softCutRatingsEnabled = false;
+  s.easterEgg = 0;
+  projectm_ = std::make_unique<projectM>(s);
+#endif  // HAVE_PROJECTM4
+
+  Q_ASSERT(preset_model_ == nullptr);
+  preset_model_ = new ProjectMPresetModel(this, this);
+
+  Load();
+
+  // Start at a random preset.
+#ifdef HAVE_PROJECTM4
+  const uint count = projectm_playlist_size(projectm_playlist_instance_);
+  if (count > 0) {
+    const uint position = QRandomGenerator::global()->bounded(count);
+    projectm_playlist_set_position(projectm_playlist_instance_, position, true);
+  }
+#else
+  const uint count = projectm_->getPlaylistSize();
+  if (count > 0) {
+    const uint selection = QRandomGenerator::global()->bounded(count);
+    projectm_->selectPreset(selection, true);
+  }
+#endif  // HAVE_PROJECTM4
+
+  if (preset_path_.isEmpty()) {
+    qWarning("ProjectM presets could not be found, search path was:\n  %s", preset_paths.join(QLatin1String("\n  ")).toLocal8Bit().constData());
+    QMessageBox::warning(nullptr, tr("Missing projectM presets"), tr("Strawberry could not load any projectM visualizations.  Check that you have installed Strawberry properly."));
+  }
+
+  Resize(sceneRect().width(), sceneRect().height(), container_->devicePixelRatio());
+
+}
+
+void ProjectMVisualization::drawBackground(QPainter *p, const QRectF &rect) {
+
+  Q_UNUSED(rect);
+
+  p->beginNativePainting();
+
+#ifdef HAVE_PROJECTM4
+  projectm_opengl_render_frame(projectm_instance_);
+#else
+  projectm_->renderFrame();
+#endif
+
+  p->endNativePainting();
+
+}
+
+void ProjectMVisualization::SceneRectChanged(const QRectF &rect) {
+
+  Resize(rect.width(), rect.height(), container_->devicePixelRatio());
+
+}
+
+void ProjectMVisualization::Resize(const qreal width, const qreal height, const qreal pixel_ratio) {
+
+#ifdef HAVE_PROJECTM4
+  if (projectm_instance_) {
+    projectm_set_window_size(projectm_instance_, static_cast<size_t>(width * pixel_ratio), static_cast<size_t>(height * pixel_ratio));
+  }
+#else
+  if (projectm_) {
+    projectm_->projectM_resetGL(static_cast<int>(width * pixel_ratio), static_cast<int>(height * pixel_ratio));
+  }
+#endif  // HAVE_PROJECTM4
+
+}
+
+void ProjectMVisualization::SetTextureSize(const int size) {
+
+  texture_size_ = size;
+
+#ifndef HAVE_PROJECTM4
+  if (projectm_) {
+    projectm_->changeTextureSize(texture_size_);
+  }
+#endif  // HAVE_PROJECTM4
+
+}
+
+void ProjectMVisualization::SetDuration(const int seconds) {
+
+  duration_ = seconds;
+
+#ifdef HAVE_PROJECTM4
+  if (projectm_instance_) {
+    projectm_set_preset_duration(projectm_instance_, duration_);
+  }
+#else
+  if (projectm_) {
+    projectm_->changePresetDuration(duration_);
+  }
+#endif  // HAVE_PROJECTM4
+
+  Save();
+
+}
+
+void ProjectMVisualization::ConsumeBuffer(GstBuffer *buffer, const int pipeline_id, const QString &format, const int channels) {
+
+  Q_UNUSED(pipeline_id);
+  Q_UNUSED(format);
+
+  GstMapInfo map;
+  gst_buffer_map(buffer, &map, GST_MAP_READ);
+
+#ifdef HAVE_PROJECTM4
+  if (projectm_instance_) {
+    const unsigned int samples_per_channel = (map.size / sizeof(int16_t)) / channels;
+    const int16_t *data = reinterpret_cast<int16_t*>(map.data);
+    projectm_pcm_add_int16(projectm_instance_, data, samples_per_channel, static_cast<projectm_channels>(channels));
+  }
+#else
+  if (projectm_) {
+    const int16_t samples_per_channel = static_cast<int16_t>((map.size / sizeof(int16_t)) / channels);
+    const int16_t *data = reinterpret_cast<int16_t*>(map.data);
+    projectm_->pcm()->addPCM16Data(data, samples_per_channel);
+  }
+#endif  // HAVE_PROJECTM4
+
+  gst_buffer_unmap(buffer, &map);
+  gst_buffer_unref(buffer);
+
+}
+
+void ProjectMVisualization::SetSelected(const QStringList &paths, const bool selected) {
+
+  for (const QString &path : paths) {
+    const int index = IndexOfPreset(path);
+    if (selected && index == -1) {
+#ifdef HAVE_PROJECTM4
+      projectm_playlist_add_preset(projectm_playlist_instance_, path.toUtf8().constData(), true);
+#else
+      projectm_->addPresetURL(path.toStdString(), std::string(), default_rating_list_);
+#endif
+    }
+    else if (!selected && index != -1) {
+#ifdef HAVE_PROJECTM4
+      projectm_playlist_remove_preset(projectm_playlist_instance_, index);
+#else
+      projectm_->removePreset(index);
+#endif
+    }
+  }
+
+  Save();
+
+}
+
+void ProjectMVisualization::ClearSelected() {
+
+#ifdef HAVE_PROJECTM4
+  projectm_playlist_clear(projectm_playlist_instance_);
+#else
+  projectm_->clearPlaylist();
+#endif
+
+  Save();
+
+}
+
+int ProjectMVisualization::IndexOfPreset(const QString &preset_path) const {
+
+#ifdef HAVE_PROJECTM4
+  const uint count = projectm_playlist_size(projectm_playlist_instance_);
+  for (uint i = 0; i < count; ++i) {
+    char *projectm_preset_path = projectm_playlist_item(projectm_playlist_instance_, i);
+    if (projectm_preset_path) {
+      const QScopeGuard projectm_preset_path_deleter = qScopeGuard([projectm_preset_path](){ projectm_playlist_free_string(projectm_preset_path); });
+      if (QLatin1String(projectm_preset_path) == preset_path) {
+        return static_cast<int>(i);
+      }
+    }
+  }
+#else
+  const uint count = projectm_->getPlaylistSize();
+  for (uint i = 0; i < count; ++i) {
+    if (QString::fromStdString(projectm_->getPresetURL(i)) == preset_path) return static_cast<int>(i);
+  }
+#endif  // HAVE_PROJECTM4
+
+  return -1;
+
+}
+
+void ProjectMVisualization::Load() {
+
+  Settings s;
+  s.beginGroup(QLatin1String(VisualizationContainer::kSettingsGroup));
+  mode_ = Mode(s.value("mode", 0).toInt());
+  duration_ = s.value("duration", duration_).toInt();
+  s.endGroup();
+
+#ifdef HAVE_PROJECTM4
+  projectm_set_preset_duration(projectm_instance_, duration_);
+  projectm_playlist_clear(projectm_playlist_instance_);
+#else
+  projectm_->changePresetDuration(duration_);
+  projectm_->clearPlaylist();
+#endif  // HAVE_PROJECTM4
+
+  switch (mode_) {
+    case Mode::Random:{
+      for (int i = 0; i < preset_model_->all_presets_.count(); ++i) {
+#ifdef HAVE_PROJECTM4
+        projectm_playlist_add_preset(projectm_playlist_instance_, preset_model_->all_presets_[i].path_.toUtf8().constData(), false);
+#else
+        projectm_->addPresetURL(preset_model_->all_presets_[i].path_.toStdString(), std::string(), default_rating_list_);
+#endif
+        preset_model_->all_presets_[i].selected_ = true;
+      }
+      break;
+    }
+    case Mode::FromList:{
+      s.beginGroup(QLatin1String(VisualizationContainer::kSettingsGroup));
+      const QStringList paths = s.value("preset_paths").toStringList();
+      s.endGroup();
+      for (const QString &path : paths) {
+#ifdef HAVE_PROJECTM4
+        projectm_playlist_add_preset(projectm_playlist_instance_, path.toUtf8().constData(), true);
+#else
+        projectm_->addPresetURL(path.toStdString(), std::string(), default_rating_list_);
+#endif
+        preset_model_->MarkSelected(path, true);
+      }
+    }
+  }
+
+}
+
+void ProjectMVisualization::Save() {
+
+  QStringList paths;
+
+  for (const ProjectMPresetModel::Preset &preset : std::as_const(preset_model_->all_presets_)) {
+    if (preset.selected_) paths << preset.path_;
+  }
+
+  Settings s;
+  s.beginGroup(VisualizationContainer::kSettingsGroup);
+  s.setValue("preset_paths", paths);
+  s.setValue("mode", static_cast<int>(mode_));
+  s.setValue("duration", duration_);
+  s.endGroup();
+
+}
+
+void ProjectMVisualization::SetMode(const Mode mode) {
+
+  mode_ = mode;
+  Save();
+
+}
+
+QString ProjectMVisualization::preset_path() const {
+
+#ifdef HAVE_PROJECTM4
+  return preset_path_;
+#else
+  if (projectm_) {
+    return QString::fromStdString(projectm_->settings().presetURL);
+  }
+  return QString();
+#endif  // HAVE_PROJECTM4
+
+}
+
+void ProjectMVisualization::SetImmediatePreset(const int index) {
+
+#ifdef HAVE_PROJECTM4
+  if (projectm_playlist_instance_) {
+    projectm_playlist_set_position(projectm_playlist_instance_, index, true);
+  }
+#else
+  if (projectm_) {
+    projectm_->selectPreset(index, true);
+  }
+#endif  // HAVE_PROJECTM4
+
+}
+
+void ProjectMVisualization::SetImmediatePreset(const QString &path) {
+
+  const int index = IndexOfPreset(path);
+  if (index != -1) {
+    SetImmediatePreset(index);
+  }
+
+}
+
+void ProjectMVisualization::Lock(const bool lock) {
+
+#ifdef HAVE_PROJECTM4
+  if (projectm_instance_) {
+    projectm_set_preset_locked(projectm_instance_, lock);
+  }
+#else
+  if (projectm_) {
+    projectm_->setPresetLock(lock);
+  }
+#endif  // HAVE_PROJECTM4
+
+  if (!lock) Load();
+
+}
diff --git a/src/visualizations/projectmvisualization.h b/src/visualizations/projectmvisualization.h
new file mode 100644
index 0000000000..c8b700d2e2
--- /dev/null
+++ b/src/visualizations/projectmvisualization.h
@@ -0,0 +1,114 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef PROJECTMVISUALIZATION_H
+#define PROJECTMVISUALIZATION_H
+
+#include "config.h"
+
+#include <memory>
+#include <vector>
+
+#ifdef HAVE_PROJECTM4
+#  include <projectM-4/types.h>
+#  include <projectM-4/playlist_types.h>
+#else
+#  include <libprojectM/projectM.hpp>
+#endif
+
+#include <QString>
+#include <QStringList>
+#include <QGraphicsScene>
+
+#include "engine/gstbufferconsumer.h"
+
+class projectM;
+class QPainter;
+class ProjectMPresetModel;
+class VisualizationContainer;
+
+class ProjectMVisualization : public QGraphicsScene, public GstBufferConsumer {
+  Q_OBJECT
+
+ public:
+  explicit ProjectMVisualization(VisualizationContainer *container);
+  ~ProjectMVisualization();
+
+  enum class Mode {
+    Random = 0,
+    FromList = 1,
+  };
+
+  QString preset_path() const;
+  ProjectMPresetModel *preset_model() const { return preset_model_; }
+
+  Mode mode() const { return mode_; }
+  int duration() const { return duration_; }
+
+  void Init();
+
+  // BufferConsumer
+  void ConsumeBuffer(GstBuffer *buffer, const int pipeline_id, const QString &format, const int channels) override;
+
+ public Q_SLOTS:
+  void SetTextureSize(const int size);
+  void SetDuration(const int seconds);
+
+  void SetSelected(const QStringList &paths, const bool selected);
+  void ClearSelected();
+  void SetImmediatePreset(const int index);
+  void SetImmediatePreset(const QString &path);
+  void SetMode(const Mode mode);
+
+  void Lock(const bool lock);
+
+ protected:
+  // QGraphicsScene
+  void drawBackground(QPainter *painter, const QRectF &rect) override;
+
+ private Q_SLOTS:
+  void SceneRectChanged(const QRectF &rect);
+
+ private:
+  void Load();
+  void Save();
+
+  int IndexOfPreset(const QString &preset_path) const;
+
+  void Resize(const qreal width, const qreal height, const qreal pixel_ratio);
+
+ private:
+  VisualizationContainer *container_;
+  ProjectMPresetModel *preset_model_;
+#ifdef HAVE_PROJECTM4
+  projectm_handle projectm_instance_;
+  projectm_playlist_handle projectm_playlist_instance_;
+#else
+  std::unique_ptr<projectM> projectm_;
+#endif
+  Mode mode_;
+  int duration_;
+  std::vector<int> default_rating_list_;
+  int texture_size_;
+  QString preset_path_;
+};
+
+#endif  // PROJECTMVISUALIZATION_H
diff --git a/src/visualizations/visualizationcontainer.cpp b/src/visualizations/visualizationcontainer.cpp
new file mode 100644
index 0000000000..14fdcc6686
--- /dev/null
+++ b/src/visualizations/visualizationcontainer.cpp
@@ -0,0 +1,328 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <QtGlobal>
+
+#include <QOpenGLWidget>
+
+#include <QGraphicsProxyWidget>
+#include <QHBoxLayout>
+#include <QLabel>
+#include <QMenu>
+#include <QMessageBox>
+#include <QShortcut>
+#include <QActionGroup>
+
+#include "core/logging.h"
+#include "core/iconloader.h"
+#include "core/settings.h"
+#include "engine/gstengine.h"
+#include "visualizationcontainer.h"
+#include "visualizationopenglwidget.h"
+#include "visualizationoverlay.h"
+#include "visualizationselector.h"
+#include "projectmvisualization.h"
+
+const char *VisualizationContainer::kSettingsGroup = "Visualizations";
+
+namespace {
+constexpr int kLowFramerate = 15;
+constexpr int kMediumFramerate = 25;
+constexpr int kHighFramerate = 35;
+constexpr int kSuperHighFramerate = 60;
+
+constexpr int kDefaultWidth = 828;
+constexpr int kDefaultHeight = 512;
+constexpr int kDefaultFps = kHighFramerate;
+constexpr int kDefaultTextureSize = 512;
+}  // namespace
+
+VisualizationContainer::VisualizationContainer(QWidget *parent)
+    : QGraphicsView(parent),
+      projectm_visualization_(new ProjectMVisualization(this)),
+      overlay_(new VisualizationOverlay),
+      selector_(new VisualizationSelector(this)),
+      overlay_proxy_(nullptr),
+      engine_(nullptr),
+      menu_(new QMenu(this)),
+      fps_(kDefaultFps),
+      size_(kDefaultTextureSize) {
+
+  setWindowTitle(tr("Visualizations"));
+  setWindowIcon(IconLoader::Load(QStringLiteral("strawberry")));
+  setMinimumSize(64, 64);
+
+  {
+    Settings s;
+    s.beginGroup(QLatin1String(kSettingsGroup));
+    if (!restoreGeometry(s.value("geometry").toByteArray())) {
+      resize(kDefaultWidth, kDefaultHeight);
+    }
+    fps_ = s.value("fps", kDefaultFps).toInt();
+    size_ = s.value("size", kDefaultTextureSize).toInt();
+    s.endGroup();
+  }
+
+  QShortcut *close = new QShortcut(QKeySequence::Close, this);
+  QObject::connect(close, &QShortcut::activated, this, &VisualizationContainer::close);
+
+  // Set up the graphics view
+  setScene(projectm_visualization_);
+  setViewport(new VisualizationOpenGLWidget(projectm_visualization_));
+  setViewportUpdateMode(QGraphicsView::FullViewportUpdate);
+  setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+  setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+  setFrameStyle(QFrame::NoFrame);
+
+  // Add the overlay
+  overlay_proxy_ = scene()->addWidget(overlay_);
+  QObject::connect(overlay_, &VisualizationOverlay::OpacityChanged, this, &VisualizationContainer::ChangeOverlayOpacity);
+  QObject::connect(overlay_, &VisualizationOverlay::ShowPopupMenu, this, &VisualizationContainer::ShowPopupMenu);
+  ChangeOverlayOpacity(0.0);
+
+  projectm_visualization_->SetTextureSize(size_);
+  SizeChanged();
+
+  // Selector
+  selector_->SetVisualization(projectm_visualization_);
+
+  // Settings menu
+  menu_->addAction(IconLoader::Load(QStringLiteral("view-fullscreen")), tr("Toggle fullscreen"), this, &VisualizationContainer::ToggleFullscreen);
+
+  QMenu *fps_menu = menu_->addMenu(tr("Framerate"));
+  QActionGroup *fps_group = new QActionGroup(this);
+  AddFramerateMenuItem(tr("Low (%1 fps)").arg(kLowFramerate), kLowFramerate, fps_, fps_group);
+  AddFramerateMenuItem(tr("Medium (%1 fps)").arg(kMediumFramerate), kMediumFramerate, fps_, fps_group);
+  AddFramerateMenuItem(tr("High (%1 fps)").arg(kHighFramerate), kHighFramerate, fps_, fps_group);
+  AddFramerateMenuItem(tr("Super high (%1 fps)").arg(kSuperHighFramerate), kSuperHighFramerate, fps_, fps_group);
+  fps_menu->addActions(fps_group->actions());
+
+  QMenu *quality_menu = menu_->addMenu(tr("Quality", "Visualization quality"));
+  QActionGroup *quality_group = new QActionGroup(this);
+  AddQualityMenuItem(tr("Low (256x256)"), 256, size_, quality_group);
+  AddQualityMenuItem(tr("Medium (512x512)"), 512, size_, quality_group);
+  AddQualityMenuItem(tr("High (1024x1024)"), 1024, size_, quality_group);
+  AddQualityMenuItem(tr("Super high (2048x2048)"), 2048, size_, quality_group);
+  quality_menu->addActions(quality_group->actions());
+
+  menu_->addAction(tr("Select visualizations..."), selector_, &VisualizationContainer::show);
+
+  menu_->addSeparator();
+  menu_->addAction(IconLoader::Load(QStringLiteral("application-exit")), tr("Close visualization"), this, &VisualizationContainer::hide);
+
+}
+
+void VisualizationContainer::AddFramerateMenuItem(const QString &name, const int value, const int def, QActionGroup *group) {
+
+  QAction *action = group->addAction(name);
+  action->setCheckable(true);
+  action->setChecked(value == def);
+  QObject::connect(action, &QAction::triggered, this, [this, value]() { SetFps(value); });
+
+}
+
+void VisualizationContainer::AddQualityMenuItem(const QString &name, const int value, const int def, QActionGroup *group) {
+
+  QAction *action = group->addAction(name);
+  action->setCheckable(true);
+  action->setChecked(value == def);
+  QObject::connect(action, &QAction::triggered, this, [this, value]() { SetQuality(value); });
+
+}
+
+void VisualizationContainer::SetEngine(GstEngine *engine) {
+
+  engine_ = engine;
+
+  if (isVisible()) engine_->AddBufferConsumer(projectm_visualization_);
+
+}
+
+void VisualizationContainer::showEvent(QShowEvent *e) {
+
+  qLog(Debug) << "Showing visualization";
+
+  QGraphicsView::showEvent(e);
+
+  update_timer_.start(1000 / fps_, this);
+
+  if (engine_) engine_->AddBufferConsumer(projectm_visualization_);
+
+}
+
+void VisualizationContainer::hideEvent(QHideEvent *e) {
+
+  qLog(Debug) << "Hiding visualization";
+
+  QGraphicsView::hideEvent(e);
+
+  update_timer_.stop();
+
+  if (engine_) engine_->RemoveBufferConsumer(projectm_visualization_);
+
+}
+
+void VisualizationContainer::closeEvent(QCloseEvent *e) {
+
+  Q_UNUSED(e);
+
+  // Don't close the window. Just hide it.
+  e->ignore();
+  hide();
+
+}
+
+void VisualizationContainer::resizeEvent(QResizeEvent *e) {
+  QGraphicsView::resizeEvent(e);
+  SizeChanged();
+}
+
+void VisualizationContainer::SizeChanged() {
+
+  // Save the geometry
+  Settings s;
+  s.beginGroup(kSettingsGroup);
+  s.setValue("geometry", saveGeometry());
+
+  // Resize the scene
+  if (scene()) scene()->setSceneRect(QRect(QPoint(0, 0), size()));
+
+  // Resize the overlay
+  if (overlay_) overlay_->resize(size());
+
+}
+
+void VisualizationContainer::timerEvent(QTimerEvent *e) {
+
+  QGraphicsView::timerEvent(e);
+  if (e->timerId() == update_timer_.timerId()) scene()->update();
+
+}
+
+void VisualizationContainer::SetActions(QAction *previous, QAction *play_pause, QAction *stop, QAction *next) {
+  overlay_->SetActions(previous, play_pause, stop, next);
+}
+
+void VisualizationContainer::SongMetadataChanged(const Song &metadata) {
+  overlay_->SetSongTitle(QStringLiteral("%1 - %2").arg(metadata.artist(), metadata.title()));
+}
+
+void VisualizationContainer::Stopped() {
+  overlay_->SetSongTitle(tr("strawberry"));
+}
+
+void VisualizationContainer::ChangeOverlayOpacity(const qreal value) {
+
+  overlay_proxy_->setOpacity(value);
+
+  // Hide the cursor if the overlay is hidden
+  if (value < 0.5) {
+    viewport()->setCursor(Qt::BlankCursor);
+  }
+  else {
+    viewport()->unsetCursor();
+  }
+
+
+}
+
+void VisualizationContainer::enterEvent(QEnterEvent *e) {
+
+  QGraphicsView::enterEvent(e);
+
+  overlay_->SetVisible(true);
+
+}
+
+void VisualizationContainer::leaveEvent(QEvent *e) {
+  QGraphicsView::leaveEvent(e);
+  overlay_->SetVisible(false);
+}
+
+void VisualizationContainer::mouseMoveEvent(QMouseEvent *e) {
+  QGraphicsView::mouseMoveEvent(e);
+  overlay_->SetVisible(true);
+}
+
+void VisualizationContainer::mouseDoubleClickEvent(QMouseEvent *e) {
+  QGraphicsView::mouseDoubleClickEvent(e);
+  ToggleFullscreen();
+}
+
+void VisualizationContainer::contextMenuEvent(QContextMenuEvent *event) {
+  QGraphicsView::contextMenuEvent(event);
+  ShowPopupMenu(event->pos());
+}
+
+void VisualizationContainer::keyReleaseEvent(QKeyEvent *event) {
+
+  if (event->matches(QKeySequence::Close) || event->key() == Qt::Key_Escape) {
+    if (isFullScreen()) {
+      ToggleFullscreen();
+    }
+    else {
+      hide();
+    }
+    return;
+  }
+
+  QGraphicsView::keyReleaseEvent(event);
+
+}
+
+void VisualizationContainer::ToggleFullscreen() {
+
+  setWindowState(windowState() ^ Qt::WindowFullScreen);
+
+}
+
+void VisualizationContainer::SetFps(const int fps) {
+
+  fps_ = fps;
+
+  // Save settings
+  Settings s;
+  s.beginGroup(kSettingsGroup);
+  s.setValue("fps", fps_);
+
+  update_timer_.stop();
+  update_timer_.start(1000 / fps_, this);
+
+}
+
+void VisualizationContainer::ShowPopupMenu(const QPoint &pos) {
+  menu_->popup(mapToGlobal(pos));
+}
+
+void VisualizationContainer::SetQuality(const int size) {
+
+  size_ = size;
+
+  // Save settings
+  Settings s;
+  s.beginGroup(kSettingsGroup);
+  s.setValue("size", size_);
+
+  projectm_visualization_->SetTextureSize(size_);
+
+}
diff --git a/src/visualizations/visualizationcontainer.h b/src/visualizations/visualizationcontainer.h
new file mode 100644
index 0000000000..550d97e788
--- /dev/null
+++ b/src/visualizations/visualizationcontainer.h
@@ -0,0 +1,103 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef VISUALIZATIONCONTAINER_H
+#define VISUALIZATIONCONTAINER_H
+
+#include "config.h"
+
+#include <QBasicTimer>
+#include <QGraphicsView>
+
+#include "core/song.h"
+
+class GstEngine;
+class ProjectMVisualization;
+class VisualizationOverlay;
+class VisualizationSelector;
+
+class QMenu;
+class QActionGroup;
+class QEvent;
+class QShowEvent;
+class QHideEvent;
+class QCloseEvent;
+class QResizeEvent;
+class QTimerEvent;
+class QMouseEvent;
+class QContextMenuEvent;
+class QKeyEvent;
+class QEnterEvent;
+
+class VisualizationContainer : public QGraphicsView {
+  Q_OBJECT
+
+ public:
+  explicit VisualizationContainer(QWidget *parent = nullptr);
+
+  static const char *kSettingsGroup;
+
+  void SetEngine(GstEngine *engine);
+  void SetActions(QAction *previous, QAction *play_pause, QAction *stop, QAction *next);
+
+ public Q_SLOTS:
+  void SongMetadataChanged(const Song &metadata);
+  void Stopped();
+
+ protected:
+  // QWidget
+  void showEvent(QShowEvent *e) override;
+  void hideEvent(QHideEvent *e) override;
+  void closeEvent(QCloseEvent *e) override;
+  void resizeEvent(QResizeEvent *e) override;
+  void timerEvent(QTimerEvent *e) override;
+  void mouseMoveEvent(QMouseEvent *e) override;
+  void enterEvent(QEnterEvent *e) override;
+  void leaveEvent(QEvent *e) override;
+  void mouseDoubleClickEvent(QMouseEvent *e) override;
+  void contextMenuEvent(QContextMenuEvent *event) override;
+  void keyReleaseEvent(QKeyEvent *event) override;
+
+ private:
+  void SizeChanged();
+  void AddFramerateMenuItem(const QString &name, int value, int def, QActionGroup *group);
+  void AddQualityMenuItem(const QString &name, int value, int def, QActionGroup *group);
+
+ private Q_SLOTS:
+  void ChangeOverlayOpacity(qreal value);
+  void ShowPopupMenu(const QPoint &pos);
+  void ToggleFullscreen();
+  void SetFps(const int fps);
+  void SetQuality(const int size);
+
+ private:
+  ProjectMVisualization *projectm_visualization_;
+  VisualizationOverlay *overlay_;
+  VisualizationSelector *selector_;
+  QGraphicsProxyWidget *overlay_proxy_;
+  GstEngine *engine_;
+  QMenu *menu_;
+  QBasicTimer update_timer_;
+  int fps_;
+  int size_;
+};
+
+#endif  // VISUALIZATIONCONTAINER_H
diff --git a/src/visualizations/visualizationopenglwidget.cpp b/src/visualizations/visualizationopenglwidget.cpp
new file mode 100644
index 0000000000..baa93fd615
--- /dev/null
+++ b/src/visualizations/visualizationopenglwidget.cpp
@@ -0,0 +1,39 @@
+/*
+ * Strawberry Music Player
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <QtGlobal>
+
+#include "visualizationopenglwidget.h"
+#include "projectmvisualization.h"
+
+VisualizationOpenGLWidget::VisualizationOpenGLWidget(ProjectMVisualization *projectm_visualization, QWidget *parent, Qt::WindowFlags f)
+  : QOpenGLWidget(parent, f),
+    projectm_visualization_(projectm_visualization) {}
+
+void VisualizationOpenGLWidget::initializeGL() {
+
+  projectm_visualization_->Init();
+
+  QOpenGLWidget::initializeGL();
+
+  glEnable(GL_BLEND);
+
+}
diff --git a/src/visualizations/visualizationopenglwidget.h b/src/visualizations/visualizationopenglwidget.h
new file mode 100644
index 0000000000..2fc086ecc5
--- /dev/null
+++ b/src/visualizations/visualizationopenglwidget.h
@@ -0,0 +1,42 @@
+/*
+ * Strawberry Music Player
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef VISUALIZATIONOPENGLWIDGET_H
+#define VISUALIZATIONOPENGLWIDGET_H
+
+#include "config.h"
+
+#include <QOpenGLWidget>
+
+class ProjectMVisualization;
+
+class VisualizationOpenGLWidget : public QOpenGLWidget {
+  Q_OBJECT
+
+ public:
+  explicit VisualizationOpenGLWidget(ProjectMVisualization *projectm_visualization, QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
+
+ protected:
+  void initializeGL() override;
+
+ private:
+  ProjectMVisualization *projectm_visualization_;
+};
+
+#endif  // VISUALIZATIONOPENGLWIDGET_H
diff --git a/src/visualizations/visualizationoverlay.cpp b/src/visualizations/visualizationoverlay.cpp
new file mode 100644
index 0000000000..b9330b4f87
--- /dev/null
+++ b/src/visualizations/visualizationoverlay.cpp
@@ -0,0 +1,116 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <QString>
+#include <QBasicTimer>
+#include <QTimeLine>
+#include <QGraphicsProxyWidget>
+#include <QTimerEvent>
+#include <QMouseEvent>
+
+#include "core/iconloader.h"
+#include "visualizationoverlay.h"
+#include "ui_visualizationoverlay.h"
+
+namespace {
+constexpr int kFadeDuration = 500;
+constexpr int kFadeTimeout = 5000;
+}
+
+VisualizationOverlay::VisualizationOverlay(QWidget *parent)
+    : QWidget(parent),
+      ui_(new Ui_VisualizationOverlay),
+      fade_timeline_(new QTimeLine(kFadeDuration, this)),
+      visible_(false) {
+
+  ui_->setupUi(this);
+
+  setAttribute(Qt::WA_TranslucentBackground);
+  setMouseTracking(true);
+
+  ui_->settings->setIcon(IconLoader::Load(QStringLiteral("configure")));
+
+  QObject::connect(ui_->settings, &QToolButton::clicked, this, &VisualizationOverlay::ShowSettingsMenu);
+  QObject::connect(fade_timeline_, &QTimeLine::valueChanged, this, &VisualizationOverlay::OpacityChanged);
+
+}
+
+VisualizationOverlay::~VisualizationOverlay() { delete ui_; }
+
+QGraphicsProxyWidget *VisualizationOverlay::title(QGraphicsProxyWidget *proxy) const {
+  return proxy->createProxyForChildWidget(ui_->song_title);
+}
+
+void VisualizationOverlay::SetActions(QAction *previous, QAction *play_pause, QAction *stop, QAction *next) {
+
+  ui_->previous->setDefaultAction(previous);
+  ui_->play_pause->setDefaultAction(play_pause);
+  ui_->stop->setDefaultAction(stop);
+  ui_->next->setDefaultAction(next);
+
+}
+
+void VisualizationOverlay::ShowSettingsMenu() {
+
+  Q_EMIT ShowPopupMenu(ui_->settings->mapToGlobal(ui_->settings->rect().bottomLeft()));
+
+}
+
+void VisualizationOverlay::timerEvent(QTimerEvent *e) {
+
+  QWidget::timerEvent(e);
+
+  if (e->timerId() == fade_out_timeout_.timerId()) {
+    SetVisible(false);
+  }
+
+}
+
+void VisualizationOverlay::SetVisible(const bool visible) {
+
+  // If we're showing the overlay, then fade out again in a little while
+  fade_out_timeout_.stop();
+  if (visible) fade_out_timeout_.start(kFadeTimeout, this);
+
+  // Don't change to the state we're in already
+  if (visible == visible_) return;
+  visible_ = visible;
+
+  // If there's already another fader running then start from the same time that one was already at.
+  int start_time = visible ? 0 : fade_timeline_->duration();
+  if (fade_timeline_->state() == QTimeLine::Running)
+    start_time = fade_timeline_->currentTime();
+
+  fade_timeline_->stop();
+  fade_timeline_->setDirection(visible ? QTimeLine::Forward : QTimeLine::Backward);
+  fade_timeline_->setCurrentTime(start_time);
+  fade_timeline_->resume();
+
+}
+
+void VisualizationOverlay::SetSongTitle(const QString &title) {
+
+  ui_->song_title->setText(title);
+  SetVisible(true);
+
+}
diff --git a/src/visualizations/visualizationoverlay.h b/src/visualizations/visualizationoverlay.h
new file mode 100644
index 0000000000..31b6721e9c
--- /dev/null
+++ b/src/visualizations/visualizationoverlay.h
@@ -0,0 +1,71 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef VISUALIZATIONOVERLAY_H
+#define VISUALIZATIONOVERLAY_H
+
+#include "config.h"
+
+#include <QWidget>
+#include <QString>
+#include <QBasicTimer>
+
+class Ui_VisualizationOverlay;
+
+class QGraphicsProxyWidget;
+class QTimeLine;
+class QAction;
+
+class VisualizationOverlay : public QWidget {
+  Q_OBJECT
+
+ public:
+  explicit VisualizationOverlay(QWidget *parent = nullptr);
+  ~VisualizationOverlay();
+
+  QGraphicsProxyWidget *title(QGraphicsProxyWidget *proxy) const;
+
+  void SetActions(QAction *previous, QAction *play_pause, QAction *stop, QAction *next);
+  void SetSongTitle(const QString &title);
+
+ public Q_SLOTS:
+  void SetVisible(const bool visible);
+
+ Q_SIGNALS:
+  void OpacityChanged(const qreal value);
+  void ShowPopupMenu(const QPoint &pos);
+
+ protected:
+  // QWidget
+  void timerEvent(QTimerEvent *e);
+
+ private Q_SLOTS:
+  void ShowSettingsMenu();
+
+ private:
+  Ui_VisualizationOverlay *ui_;
+
+  QTimeLine *fade_timeline_;
+  QBasicTimer fade_out_timeout_;
+  bool visible_;
+};
+
+#endif  // VISUALIZATIONOVERLAY_H
diff --git a/src/visualizations/visualizationoverlay.ui b/src/visualizations/visualizationoverlay.ui
new file mode 100644
index 0000000000..dfd985619c
--- /dev/null
+++ b/src/visualizations/visualizationoverlay.ui
@@ -0,0 +1,234 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>VisualizationOverlay</class>
+ <widget class="QWidget" name="VisualizationOverlay">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>523</width>
+    <height>302</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>Form</string>
+  </property>
+  <property name="styleSheet">
+   <string notr="true">VisualizationOverlay {
+  background-color: transparent;
+}
+
+#frame {
+  background-color: rgba(96, 59, 25, 70%);
+  border-top-left-radius: 10px;
+  border-top-right-radius: 10px;
+  border-color: rgba(145, 89, 38, 100%);
+  border-width: 4px 4px 0px 4px;
+  border-style: solid;
+}
+
+#song_title {
+  font-weight: bold;
+  font-size: 20px;
+  color: #feae65;
+}
+
+QToolButton {
+  background: transparent;
+  border: none;
+}</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout_2">
+   <property name="margin">
+    <number>0</number>
+   </property>
+   <item>
+    <spacer name="verticalSpacer">
+     <property name="orientation">
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeHint" stdset="0">
+      <size>
+       <width>20</width>
+       <height>210</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" name="horizontalLayout_3">
+     <item>
+      <spacer name="horizontalSpacer">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QFrame" name="frame">
+       <property name="frameShape">
+        <enum>QFrame::StyledPanel</enum>
+       </property>
+       <property name="frameShadow">
+        <enum>QFrame::Raised</enum>
+       </property>
+       <layout class="QVBoxLayout" name="verticalLayout">
+        <item>
+         <widget class="QLabel" name="song_title">
+          <property name="text">
+           <string>Strawberry</string>
+          </property>
+          <property name="alignment">
+           <set>Qt::AlignCenter</set>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <layout class="QHBoxLayout" name="horizontalLayout_2">
+          <item>
+           <spacer name="horizontalSpacer_5">
+            <property name="orientation">
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeType">
+             <enum>QSizePolicy::Preferred</enum>
+            </property>
+            <property name="sizeHint" stdset="0">
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+          <item>
+           <widget class="QWidget" name="widget" native="true">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Maximum" vsizetype="Preferred">
+              <horstretch>0</horstretch>
+              <verstretch>0</verstretch>
+             </sizepolicy>
+            </property>
+            <layout class="QHBoxLayout" name="horizontalLayout">
+             <property name="margin">
+              <number>0</number>
+             </property>
+             <item>
+              <widget class="QToolButton" name="previous">
+               <property name="iconSize">
+                <size>
+                 <width>24</width>
+                 <height>24</height>
+                </size>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QToolButton" name="play_pause">
+               <property name="iconSize">
+                <size>
+                 <width>24</width>
+                 <height>24</height>
+                </size>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QToolButton" name="stop">
+               <property name="iconSize">
+                <size>
+                 <width>24</width>
+                 <height>24</height>
+                </size>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QToolButton" name="next">
+               <property name="iconSize">
+                <size>
+                 <width>24</width>
+                 <height>24</height>
+                </size>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <spacer name="horizontalSpacer_3">
+               <property name="orientation">
+                <enum>Qt::Horizontal</enum>
+               </property>
+               <property name="sizeType">
+                <enum>QSizePolicy::Fixed</enum>
+               </property>
+               <property name="sizeHint" stdset="0">
+                <size>
+                 <width>20</width>
+                 <height>13</height>
+                </size>
+               </property>
+              </spacer>
+             </item>
+             <item>
+              <widget class="QToolButton" name="settings">
+               <property name="toolTip">
+                <string>Visualizations Settings</string>
+               </property>
+               <property name="iconSize">
+                <size>
+                 <width>24</width>
+                 <height>24</height>
+                </size>
+               </property>
+              </widget>
+             </item>
+            </layout>
+           </widget>
+          </item>
+          <item>
+           <spacer name="horizontalSpacer_4">
+            <property name="orientation">
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeType">
+             <enum>QSizePolicy::Preferred</enum>
+            </property>
+            <property name="sizeHint" stdset="0">
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+         </layout>
+        </item>
+       </layout>
+      </widget>
+     </item>
+     <item>
+      <spacer name="horizontalSpacer_2">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/src/visualizations/visualizationselector.cpp b/src/visualizations/visualizationselector.cpp
new file mode 100644
index 0000000000..c8e06394d5
--- /dev/null
+++ b/src/visualizations/visualizationselector.cpp
@@ -0,0 +1,88 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <QPushButton>
+
+#include "visualizationselector.h"
+#include "projectmpresetmodel.h"
+#include "projectmvisualization.h"
+#include "ui_visualizationselector.h"
+
+VisualizationSelector::VisualizationSelector(QWidget *parent)
+    : QDialog(parent),
+      ui_(new Ui_VisualizationSelector),
+      projectm_visualization_(nullptr),
+      select_all_(nullptr),
+      select_none_(nullptr) {
+
+  ui_->setupUi(this);
+
+  select_all_ = ui_->buttonBox->addButton(tr("Select All"), QDialogButtonBox::ActionRole);
+  select_none_ = ui_->buttonBox->addButton(tr("Select None"), QDialogButtonBox::ActionRole);
+  QObject::connect(select_all_, &QPushButton::clicked, this, &VisualizationSelector::SelectAll);
+  QObject::connect(select_none_, &QPushButton::clicked, this, &VisualizationSelector::SelectNone);
+  select_all_->setEnabled(false);
+  select_none_->setEnabled(false);
+
+  QObject::connect(ui_->mode, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &VisualizationSelector::ModeChanged);
+
+}
+
+VisualizationSelector::~VisualizationSelector() { delete ui_; }
+
+void VisualizationSelector::showEvent(QShowEvent *e) {
+
+  Q_UNUSED(e);
+
+  if (!ui_->list->model()) {
+    ui_->delay->setValue(projectm_visualization_->duration());
+    ui_->list->setModel(projectm_visualization_->preset_model());
+    QObject::connect(ui_->list->selectionModel(), &QItemSelectionModel::currentChanged, projectm_visualization_->preset_model(), &ProjectMPresetModel::SetImmediatePreset);
+    QObject::connect(ui_->delay, QOverload<int>::of(&QSpinBox::valueChanged), projectm_visualization_, &ProjectMVisualization::SetDuration);
+
+    ui_->mode->setCurrentIndex(static_cast<int>(projectm_visualization_->mode()));
+  }
+
+  projectm_visualization_->Lock(true);
+
+}
+
+void VisualizationSelector::hideEvent(QHideEvent *e) {
+  Q_UNUSED(e);
+  projectm_visualization_->Lock(false);
+}
+
+void VisualizationSelector::ModeChanged(const int mode) {
+
+  const bool enabled = mode == 1;
+  ui_->list->setEnabled(enabled);
+  select_all_->setEnabled(enabled);
+  select_none_->setEnabled(enabled);
+
+  projectm_visualization_->SetMode(static_cast<ProjectMVisualization::Mode>(mode));
+
+}
+
+void VisualizationSelector::SelectAll() { projectm_visualization_->preset_model()->SelectAll(); }
+
+void VisualizationSelector::SelectNone() { projectm_visualization_->preset_model()->SelectNone(); }
diff --git a/src/visualizations/visualizationselector.h b/src/visualizations/visualizationselector.h
new file mode 100644
index 0000000000..4c97beabb8
--- /dev/null
+++ b/src/visualizations/visualizationselector.h
@@ -0,0 +1,61 @@
+/*
+ * Strawberry Music Player
+ * This file was part of Clementine.
+ * Copyright 2010, David Sansome <me@davidsansome.com>
+ * Copyright 2024, Jonas Kvinge <jonas@jkvinge.net>
+ *
+ * Strawberry is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Strawberry is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Strawberry.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef VISUALIZATIONSELECTOR_H
+#define VISUALIZATIONSELECTOR_H
+
+#include "config.h"
+
+#include <QDialog>
+
+class QPushButton;
+class QShowEvent;
+class QHideEvent;
+
+class ProjectMVisualization;
+class Ui_VisualizationSelector;
+
+class VisualizationSelector : public QDialog {
+  Q_OBJECT
+
+ public:
+  explicit VisualizationSelector(QWidget *parent = nullptr);
+  ~VisualizationSelector();
+
+  void SetVisualization(ProjectMVisualization *projectm_visualization) { projectm_visualization_ = projectm_visualization; }
+
+ protected:
+  void showEvent(QShowEvent *e) override;
+  void hideEvent(QHideEvent *e) override;
+
+ private Q_SLOTS:
+  void ModeChanged(const int mode);
+  void SelectAll();
+  void SelectNone();
+
+ private:
+  Ui_VisualizationSelector *ui_;
+  ProjectMVisualization *projectm_visualization_;
+  QPushButton *select_all_;
+  QPushButton *select_none_;
+};
+
+#endif  // VISUALIZATIONSELECTOR_H
diff --git a/src/visualizations/visualizationselector.ui b/src/visualizations/visualizationselector.ui
new file mode 100644
index 0000000000..1c9a071d54
--- /dev/null
+++ b/src/visualizations/visualizationselector.ui
@@ -0,0 +1,140 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>VisualizationSelector</class>
+ <widget class="QDialog" name="VisualizationSelector">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>595</width>
+    <height>475</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>Select visualizations</string>
+  </property>
+  <property name="windowIcon">
+   <iconset resource="../../data/data.qrc">
+    <normaloff>:/icon.png</normaloff>:/icon.png</iconset>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <item>
+    <layout class="QFormLayout" name="formLayout">
+     <item row="0" column="0">
+      <widget class="QLabel" name="label">
+       <property name="text">
+        <string>Visualization mode</string>
+       </property>
+      </widget>
+     </item>
+     <item row="0" column="1">
+      <widget class="QComboBox" name="mode">
+       <item>
+        <property name="text">
+         <string>Random visualization</string>
+        </property>
+       </item>
+       <item>
+        <property name="text">
+         <string>Choose from the list</string>
+        </property>
+       </item>
+      </widget>
+     </item>
+     <item row="1" column="0">
+      <widget class="QLabel" name="label_2">
+       <property name="text">
+        <string>Delay between visualizations</string>
+       </property>
+      </widget>
+     </item>
+     <item row="1" column="1">
+      <widget class="QSpinBox" name="delay">
+       <property name="suffix">
+        <string> seconds</string>
+       </property>
+       <property name="minimum">
+        <number>2</number>
+       </property>
+       <property name="maximum">
+        <number>120</number>
+       </property>
+       <property name="value">
+        <number>15</number>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <widget class="QListView" name="list">
+     <property name="enabled">
+      <bool>false</bool>
+     </property>
+     <property name="alternatingRowColors">
+      <bool>true</bool>
+     </property>
+     <property name="selectionBehavior">
+      <enum>QAbstractItemView::SelectRows</enum>
+     </property>
+     <property name="uniformItemSizes">
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox">
+     <property name="orientation">
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="standardButtons">
+      <set>QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>mode</tabstop>
+  <tabstop>delay</tabstop>
+  <tabstop>list</tabstop>
+  <tabstop>buttonBox</tabstop>
+ </tabstops>
+ <resources>
+  <include location="../../data/data.qrc"/>
+ </resources>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>VisualizationSelector</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>248</x>
+     <y>254</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>157</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>VisualizationSelector</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
