From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0b-00069f02.pphosted.com (mx0b-00069f02.pphosted.com [205.220.177.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 9443925779;
	Thu, 17 Oct 2024 20:43:23 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.177.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729197805; cv=fail; b=di0JyinZM5Cb4tKkGVC2BbGm2CAhEuRaq9gnCRP1dK2BFMiZ6FQGmx3+0B2cm0KH7WpLqf4Qvmcxyrd+NtX3KBwDL6NfVF0bvb5IJ/fOkMc52v/EsXpQEmLBLIymJFiuOD4uA1B+/CepNyeEIpO2McCLkZVaFZwTSOn/NoystZY=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729197805; c=relaxed/simple;
	bh=r1rIS4+tl2D1x4fXZD5fIAKB7CebxPDKwcDZdqEPq3M=;
	h=From:To:Cc:Subject:Date:Message-ID:In-Reply-To:References:
	 Content-Type:MIME-Version; b=ptPP4n2ll+Uo5ACs5+N/XYuDyQAA+q7wNmWkQ8k/QbQ6y4fOPjgZBgsLd5h1xmHS6WKn/yiNWqTduAS6+HLcEx7lupG/0PFZzb1C3n7ZrcfYbM6U5YHqeOEhMt+yt16Nl8a4HycJ5Tionp6odODOAn3F0GClryzmrrX7Mj5CSMY=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=hlT25oPZ; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=gzq9/D8b; arc=fail smtp.client-ip=205.220.177.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="hlT25oPZ";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="gzq9/D8b"
Received: from pps.filterd (m0246630.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49HFBvq6024561;
	Thu, 17 Oct 2024 20:42:50 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-transfer-encoding:content-type:date:from:in-reply-to
	:message-id:mime-version:references:subject:to; s=
	corp-2023-11-20; bh=0XL9Kp1iOKvA/fmdS4PltUGMSZ22lYarbZRleGRG5kI=; b=
	hlT25oPZy1L/mjEIi8zdIfEKciZwx4k39RHCN3wyKVdiX1YyKaWLEkKZRNslnwN4
	rwSDk5xO9VYPGCGb9okL3zsWcvr0WtNWfeMZTmA1PhlvN0YfrczvZFrlf7eBJeNz
	cHVSZ4IcIjUokwMJVty3ADEgqJ5/pXygG/uw0gCKXLjMpHOLJ53kCnSWY2rusRGz
	56IY5c9KV9znXEe0G21hCBBd7/h+ZqAMAhkU7qushIV/iGziFxm5vdeTg+kUxYsm
	W9d5Eq7VR1J+Xh2TndlvPmg5pX2Woa7Bvs3ytkmgNuQQFwqvOq6yjwUtbYmrKgSY
	Kv6lTGKIugKiXLxMQg+gFQ==
Received: from phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (phxpaimrmta03.appoci.oracle.com [138.1.37.129])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427fhcpyqv-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:42:50 +0000 (GMT)
Received: from pps.filterd (phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com [127.0.0.1])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49HKWWwc013877;
	Thu, 17 Oct 2024 20:42:49 GMT
Received: from nam10-mw2-obe.outbound.protection.outlook.com (mail-mw2nam10lp2042.outbound.protection.outlook.com [104.47.55.42])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (PPS) with ESMTPS id 427fjarehs-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:42:49 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=dLjNnzJ5Edc1BweFrwDNAIuIlFNTilaIK5xkWGdbHkCYszr2A0ZjjAmgaOsadrfd62cFWyXRj/jGeLIPGuBCyHT5xWTJweyUcM9ZXyKCY9YKCo8HYEDhUgnyHs9aW7i/mMwN8lN7cHmVJvvYNDTPmOp1VpoVxjZ8+ipFB9UzWW11nHdVbUlPuEVxdAw3i+KFptTWKNerBbcLkRd/qNXY3+aDSCqlNkmQI5c1hWZjbKUmTjRTcTPq1Oh4x/gfeYkcujYdaxiQa48DlWXW3m4v1Bp5c8AaQo+ZSWJpdZgxJPpneB0+WEWqSwAaupkfhqC/YaAkNow6SSvIn5ZBwRhQcA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=0XL9Kp1iOKvA/fmdS4PltUGMSZ22lYarbZRleGRG5kI=;
 b=N1BsIwOsAUvU1+RDCIPxK8GtEkdBkPyNFVDrND31tROetjqy6V/w18EzXObkvlCSHHB1MtcKL6woh7rX7eQBox8nIYxqIJjk1r5bGf6t+EfRmN4zKI9oW61YLMkhyp7YGh9c2ZZKqifN6yB7nM6rZiJVTJJEQTvNBtlMt9Oqg8D4uW/+m05gV2rOwKZnUAXa7+wBwNQb2FGo60Bea/kUwIYK79qU3irdT64nkdhAJbDBpGU+EMA+ZSEgJw8KJji7FPVO8coFq4stHqyjVEI6zvu1LeJAXLV6wjvXLcx8nE3LVD28PGcE29lLPYZHSo3FTIz1kug7ojhnCdKMZ/YiSg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=0XL9Kp1iOKvA/fmdS4PltUGMSZ22lYarbZRleGRG5kI=;
 b=gzq9/D8bv/W6o7Qp8Y/kllE+/dSDIUl9plZXwBN5GbnrBuy7IXAp7D+2Pkc2jXss46YioWYh5whe6YnGssOBEEdhu1117+uHGQqkW7o6+jSBr6uTeuV2HpHuhq2vhhA0qoe6sBz5tWl2HWX6YJ97wjUEeV0bEoUYaBaO8gecJEo=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by DS7PR10MB5974.namprd10.prod.outlook.com (2603:10b6:8:9e::10) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.18; Thu, 17 Oct
 2024 20:42:46 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Thu, 17 Oct 2024
 20:42:46 +0000
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Andrew Morton <akpm@linux-foundation.org>
Cc: Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@HansenPartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: [PATCH 1/4] mm: pagewalk: add the ability to install PTEs
Date: Thu, 17 Oct 2024 21:42:35 +0100
Message-ID: <7e246193f60298f08e5ee1f1341f780e0a6a9712.1729196871.git.lorenzo.stoakes@oracle.com>
X-Mailer: git-send-email 2.46.2
In-Reply-To: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: LO4P265CA0177.GBRP265.PROD.OUTLOOK.COM
 (2603:10a6:600:312::20) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|DS7PR10MB5974:EE_
X-MS-Office365-Filtering-Correlation-Id: 5df2e69f-e981-4e3e-0a82-08dceeec416b
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|7416014|376014|366016|1800799024;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?u0qkm7rjh1tD1oa6U2YqU1iEt7u0R89TrWEorHcge2iE/TtoDSwxwYkIohRA?=
 =?us-ascii?Q?rjGlhT3Q7/3UgvsSIYDxKUTyX6jovnB2rcWhO64botoInpb+r1NQNpj1ILHX?=
 =?us-ascii?Q?qF8LWfT4zoXludFjye2CO+bx9zPvkg+8TlPD3OZZcRcj8U2mj/b8ps20nI3V?=
 =?us-ascii?Q?7bNodfKb2D+yFlPJK6DF77BNDNLsgFY5niMh1bdC6G1CIO5D/b1Rymb3fQS7?=
 =?us-ascii?Q?8i47Y/86WZlaOFnBu31N6FcLsFXEAQFmMZMAsAL5GdYnTyq8j4/tqzM25Q8K?=
 =?us-ascii?Q?f590BkRyd3KpjF6qq0TYBzbWyCsbwr43P2i9OjYc0fFcgv3Rjc1GHUsF7iWv?=
 =?us-ascii?Q?GxYdDpGxSqvoLtk4fDtVxW1qo0BvrDw9z/2zxWtp2pKiN5Fh+d359EN27mk7?=
 =?us-ascii?Q?Qtth9n5LZ240pBpVeyhnGppWuk8DH//7oYgtQRLAJlb/8G0g8p4UBrAF39L1?=
 =?us-ascii?Q?kVM4EdHql2rqnIKIFDKbI5u/Y5EdaVHRO8QJhj+RGNvo//Ch6KS7gFVDfNUJ?=
 =?us-ascii?Q?f4yUrgkVx3jPfE4hDVQjjrNcxQOcWma+PuRou4d0KCFlqZvN5T3azVVv1To8?=
 =?us-ascii?Q?qSP1EkYGj8aOb9Xx0qj7JFbvYYGhgWvPH1iWhbJVT54yZk2AR3iqfnRdErhm?=
 =?us-ascii?Q?sM7JUCTAsnH+9ny7WjKXE9Os7HXRBp2hLtrnBSxMpMdGGCbkOGwey0CHYkhc?=
 =?us-ascii?Q?/6YEp/kZIZ4pJBSNcGVUDBa9zptdROAhbujroBWp7bLawlvdBF7TfUDBKj7p?=
 =?us-ascii?Q?7pLlsBpZVV2FxI33dyGDpNZfWdzcy+/RTU5iLQ7rXlOvSpbbq/7xtafs5ubp?=
 =?us-ascii?Q?dVn585+s5tXZMNddtZZ8mm/e73TsCPSVfncSpVRG54vY+rnMnaco6RSLERY+?=
 =?us-ascii?Q?dmSqPCJaCioX4lim2CL4xu6VOvFNBbCvThpwgCCzJyC9YRD3tl/E97RCqGmg?=
 =?us-ascii?Q?qFQ2UbOfBQ8GY9d1gn4wbBpwmG7MJNsLkI8PezUrby0I2ub0DHQ8JO/H7iYD?=
 =?us-ascii?Q?oelR8BhWcHyIAdeDzlXQ3PFDAO/VdQYPWT5tjQtuv/UyydKofEWhzyWzPQ8/?=
 =?us-ascii?Q?ubNxweZ5NJOccnwIIydyi1BwVwlXF1Fg8virOmBvtaztJGL/iVyxBgVbq86G?=
 =?us-ascii?Q?jWjUOybZQs0GDi0+AjQ02yEik4IfyXdV0mCgKM9gXVT8B48fPnwbNIbUXeRX?=
 =?us-ascii?Q?Hm2oDuJQLqEnO090PFcTsxAmj2DfpMNLMTyvRywgAQjrm9pLlA0lPWselLcI?=
 =?us-ascii?Q?I+wr/GABCGqVPXMCYiTaRLenb21EZ/Rq2czc7+5uUr4gNasdIjkb7G21qxac?=
 =?us-ascii?Q?F64A6n9MuEQTYURvL4rFkh1Y?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(7416014)(376014)(366016)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?64JICuhaT03EPmMftusg4jDlrxQV0bij5Q6Eht1U5446KTrW3X6qmP90uZsf?=
 =?us-ascii?Q?c7s6gI2NzVwaP/sfzaAQ16IO2o7NE+JmtL2EnVyC6Ab/Ny9pEAGBrjlIb4vu?=
 =?us-ascii?Q?DrSuCfaNWMfxoM5p9s/k/JjbfXqYCntQ0Z0qSnyszpQl45P7P4cBOS6guE01?=
 =?us-ascii?Q?2wlxtHwQ7j6kB/ljwTd4+h1QhdoqpfHbaagyMKOqnbSBPjJHxvXnWPptFUib?=
 =?us-ascii?Q?kYlTBiPElKxWOE1DgrASmCQwcVkUhcethqCMeDXcQC4mCXIHrHh9AE18C+Gz?=
 =?us-ascii?Q?rydSCJKXrDHi0M5y1IpYjvmEmyzP4AClxkgD4Anb2vp0KzPWs1gEAbDpI0Al?=
 =?us-ascii?Q?Ynox4hVBHAr+Sfyfjie19lcc5BXP67HBATy6S33TNdbsKC0vyk3f0SJXc5JD?=
 =?us-ascii?Q?dXgSdzobc26llTaM2tgCZEOBEC8mC4ZF9ApStgcxl2j/4aZHCu53EoH/Iof2?=
 =?us-ascii?Q?McB479EbHp/dLG/Dg7DPE+FI9ZFW+wB4mRY50VkcjGPcj+fnwzjJEdGXF7O3?=
 =?us-ascii?Q?Q4jI8W4X5N5BK9QJXu0NkQgnB3Ee+O8x5Yg5aeBECHQA+lZeXXj2gnqdJUto?=
 =?us-ascii?Q?h6ib/uGXbWk3LMSTWuHbte1mm4hsa2kk84Uc+LjCTEPx6/sHdBPy7nl+YcdL?=
 =?us-ascii?Q?eYaz2kV2F1iU6rYwJbYSSyeykkXrDXnp1n9lCVTAcIg3f/n87frCkhXFROeX?=
 =?us-ascii?Q?jUnGNyOPoq+qKwUHUgQdC/7pxbPBhMJKJz6wh0Phm7BqlUV37AhtdfKH9MGb?=
 =?us-ascii?Q?EfJ5ldq4L8YnXvqhcNJAY+lT5ZrkR4fRliU3/eGa6tpb70Ne/ZDv0BP81As+?=
 =?us-ascii?Q?xxuQhRZxiiIa3ML/SI1vG1f3p6eozeyS82PxxXcUOWPPLi0DCKem1wBiS9uu?=
 =?us-ascii?Q?V+RBfrS54kgwST2EpxVoGLL+LASlwkK1InItLTZM6sFDV3F4SFWhJhI6JAdL?=
 =?us-ascii?Q?3v69l+OzhcEEZO09riRqY9l3cp7PtFqc6vmvbaQ6CEqa3Lx54qU0oxh0Vcdy?=
 =?us-ascii?Q?POuURL1qbahQ6JyRPjvetFdM2aWoR6kLm1QBl4x3FuK7HKcHwTxbENhyPnBs?=
 =?us-ascii?Q?CHsXylzhvkRxdHUUpXGWCgqi44JgNSBYE3HgavhbaSWr/y8hiQTDDqaNPeBU?=
 =?us-ascii?Q?fRDBiztoms25DMY1reqozNVkBcO4WdrJuE0R8ms7wAOOdhNm14N/Jhf4CV/Y?=
 =?us-ascii?Q?1MMMTGLgS0/SONnZaCu8VRwqjeDOvKz01SfAeSDmhdtU0oBxHacaMAicgkUM?=
 =?us-ascii?Q?4s9M19fymIEJHCEnAEP0lUBqyZ4QlUAqs9YWy/jyw9jmC+q20t40Ris26gpu?=
 =?us-ascii?Q?XOgzc4/USl6ZeWB0JSeCyY8yPj/jT5m1JpXe8qmR/uMkQp0dSXJ9CJ9TF8H1?=
 =?us-ascii?Q?athM8pg3g9DdlxL1vYKQZEj04ixpIdudj7jXwxN5nd3gYpMWhUF9kGfcVWBV?=
 =?us-ascii?Q?iIpvyxQvhrOLFKbhBzgyh8b7+o8jNSmXcJ7OXLbbd7RWLlIIrf86JxLVq76m?=
 =?us-ascii?Q?zskN3dI0r8O0PHN4KKDQ6XukrXMPHMlBloEvG7uPLCCwt6OluOo/XfTB/e8r?=
 =?us-ascii?Q?yZ1On8TwrLOXnCzujO53GiE0kqYZ57kPit+q5peTzs0m6IkmR7V625epKdzc?=
 =?us-ascii?Q?3Q=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	WsJ35mcqrmAk/goU3TJQOeR/93rTeZeBY8Yf26epZjd7jhTT4O84s7CV9G6yxjVOJ7pu3XIhPS9E/lT1dlOhlYgrXWuAQNYG7do0NoOUANx33bZBlqnElK01taPpcEVRyCw7u90C37LKAy7cTP2yQS+WvALGpK154YRCObEzxRF7oq0p+Uumq8IpaDuXoMuDDataVP9i74LL65HlLFR3OuH5FAV/LzxjwOOG9qZ/Z1TTrgPg1GBm2MCc092DbhDyBOqt44jPRHzI5mfRdZimNkrcnhsvA/VgGU5v8ys6T2AxiBXDWVtrhZd82biVhk1He/4xE0nNcARYukDKKwcZNR27PzFxJ64VDVI73fzLnxNwnuKbuJfkDfUPViIg2qwZix7i7hq4052+H720DDwnYFE4okgeB+CHNWKbihnKJvx8x5cdVJkrjFhxzAMX978jRC9dPSJKUbUHhp5b5e6nlhGe4h7QmkYpQY6fE04zAwJUnT+HIFySXTxiToKktQ1khTidlBQhIAhbjO/KTCJA4XeXci8jvw7FdIHJ6oZeYMRqSunv51hwFvljupiYVydtROPOftTak962bPrP7fFf+VdTdIb/qkByWfcfCEfBJVs=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 5df2e69f-e981-4e3e-0a82-08dceeec416b
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Oct 2024 20:42:46.0080
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: P5Su4uE3LK4b3WVzqktJH31/s43FHK+fhCowwBEDzFiJRGbcwo7UeB2Cp0IDLQdDK8qJYp7wOgTbYVJ++ric4NQjEawhOCit8E11+vzVf3Q=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DS7PR10MB5974
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-17_23,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 malwarescore=0 phishscore=0 mlxscore=0
 mlxlogscore=999 bulkscore=0 spamscore=0 suspectscore=0 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2409260000
 definitions=main-2410170139
X-Proofpoint-GUID: zvMkzT1Kk4r1NblzgsNfPkHZ0S4crHuO
X-Proofpoint-ORIG-GUID: zvMkzT1Kk4r1NblzgsNfPkHZ0S4crHuO

The existing generic pagewalk logic permits the walking of page tables,
invoking callbacks at individual page table levels via user-provided
mm_walk_ops callbacks.

This is useful for traversing existing page table entries, but precludes
the ability to establish new ones.

Existing mechanism for performing a walk which also installs page table
entries if necessary are heavily duplicated throughout the kernel, each
with semantic differences from one another and largely unavailable for use
elsewhere.

Rather than add yet another implementation, we extend the generic pagewalk
logic to enable the installation of page table entries by adding a new
install_pte() callback in mm_walk_ops. If this is specified, then upon
encountering a missing page table entry, we allocate and install a new one
and continue the traversal.

If a THP huge page is encountered, we make use of existing logic to split
it. Then once we reach the PTE level, we invoke the install_pte() callback
which provides a PTE entry to install. We do not support hugetlb at this
stage.

If this function returns an error, or an allocation fails during the
operation, we abort the operation altogether. It is up to the caller to
deal appropriately with partially populated page table ranges.

If install_pte() is defined, the semantics of pte_entry() change - this
callback is then only invoked if the entry already exists. This is a useful
property, as it allows a caller to handle existing PTEs while installing
new ones where necessary in the specified range.

If install_pte() is not defined, then there is no functional difference to
this patch, so all existing logic will work precisely as it did before.

As we only permit the installation of PTEs where a mapping does not already
exist there is no need for TLB management, however we do invoke
update_mmu_cache() for architectures which require manual maintenance of
mappings for other CPUs.

We explicitly do not allow the existing page walk API to expose this
feature as it is dangerous and intended for internal mm use only. Therefore
we provide a new walk_page_range_mm() function exposed only to
mm/internal.h.

Reviewed-by: Jann Horn <jannh@google.com>
Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
---
 include/linux/pagewalk.h |  18 +++-
 mm/internal.h            |   6 ++
 mm/pagewalk.c            | 200 ++++++++++++++++++++++++++++-----------
 3 files changed, 165 insertions(+), 59 deletions(-)

diff --git a/include/linux/pagewalk.h b/include/linux/pagewalk.h
index f5eb5a32aeed..9700a29f8afb 100644
--- a/include/linux/pagewalk.h
+++ b/include/linux/pagewalk.h
@@ -25,12 +25,15 @@ enum page_walk_lock {
  *			this handler is required to be able to handle
  *			pmd_trans_huge() pmds.  They may simply choose to
  *			split_huge_page() instead of handling it explicitly.
- * @pte_entry:		if set, called for each PTE (lowest-level) entry,
- *			including empty ones
+ * @pte_entry:		if set, called for each PTE (lowest-level) entry
+ *			including empty ones, except if @install_pte is set.
+ *			If @install_pte is set, @pte_entry is called only for
+ *			existing PTEs.
  * @pte_hole:		if set, called for each hole at all levels,
  *			depth is -1 if not known, 0:PGD, 1:P4D, 2:PUD, 3:PMD.
  *			Any folded depths (where PTRS_PER_P?D is equal to 1)
- *			are skipped.
+ *			are skipped. If @install_pte is specified, this will
+ *			not trigger for any populated ranges.
  * @hugetlb_entry:	if set, called for each hugetlb entry. This hook
  *			function is called with the vma lock held, in order to
  *			protect against a concurrent freeing of the pte_t* or
@@ -51,6 +54,13 @@ enum page_walk_lock {
  * @pre_vma:            if set, called before starting walk on a non-null vma.
  * @post_vma:           if set, called after a walk on a non-null vma, provided
  *                      that @pre_vma and the vma walk succeeded.
+ * @install_pte:        if set, missing page table entries are installed and
+ *                      thus all levels are always walked in the specified
+ *                      range. This callback is then invoked at the PTE level
+ *                      (having split any THP pages prior), providing the PTE to
+ *                      install. If allocations fail, the walk is aborted. This
+ *                      operation is only available for userland memory. Not
+ *                      usable for hugetlb ranges.
  *
  * p?d_entry callbacks are called even if those levels are folded on a
  * particular architecture/configuration.
@@ -76,6 +86,8 @@ struct mm_walk_ops {
 	int (*pre_vma)(unsigned long start, unsigned long end,
 		       struct mm_walk *walk);
 	void (*post_vma)(struct mm_walk *walk);
+	int (*install_pte)(unsigned long addr, unsigned long next,
+			   pte_t *ptep, struct mm_walk *walk);
 	enum page_walk_lock walk_lock;
 };
 
diff --git a/mm/internal.h b/mm/internal.h
index 508f7802dd2b..fb1fb0c984e4 100644
--- a/mm/internal.h
+++ b/mm/internal.h
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/mm_inline.h>
 #include <linux/pagemap.h>
+#include <linux/pagewalk.h>
 #include <linux/rmap.h>
 #include <linux/swap.h>
 #include <linux/swapops.h>
@@ -1451,4 +1452,9 @@ static inline void accept_page(struct page *page)
 }
 #endif /* CONFIG_UNACCEPTED_MEMORY */
 
+/* pagewalk.c */
+int walk_page_range_mm(struct mm_struct *mm, unsigned long start,
+		unsigned long end, const struct mm_walk_ops *ops,
+		void *private);
+
 #endif	/* __MM_INTERNAL_H */
diff --git a/mm/pagewalk.c b/mm/pagewalk.c
index 5f9f01532e67..261cd5f2de38 100644
--- a/mm/pagewalk.c
+++ b/mm/pagewalk.c
@@ -3,9 +3,14 @@
 #include <linux/highmem.h>
 #include <linux/sched.h>
 #include <linux/hugetlb.h>
+#include <linux/mmu_context.h>
 #include <linux/swap.h>
 #include <linux/swapops.h>
 
+#include <asm/tlbflush.h>
+
+#include "internal.h"
+
 /*
  * We want to know the real level where a entry is located ignoring any
  * folding of levels which may be happening. For example if p4d is folded then
@@ -29,9 +34,23 @@ static int walk_pte_range_inner(pte_t *pte, unsigned long addr,
 	int err = 0;
 
 	for (;;) {
-		err = ops->pte_entry(pte, addr, addr + PAGE_SIZE, walk);
-		if (err)
-		       break;
+		if (ops->install_pte && pte_none(ptep_get(pte))) {
+			pte_t new_pte;
+
+			err = ops->install_pte(addr, addr + PAGE_SIZE, &new_pte,
+					       walk);
+			if (err)
+				break;
+
+			set_pte_at(walk->mm, addr, pte, new_pte);
+			/* Non-present before, so for arches that need it. */
+			if (!WARN_ON_ONCE(walk->no_vma))
+				update_mmu_cache(walk->vma, addr, pte);
+		} else {
+			err = ops->pte_entry(pte, addr, addr + PAGE_SIZE, walk);
+			if (err)
+				break;
+		}
 		if (addr >= end - PAGE_SIZE)
 			break;
 		addr += PAGE_SIZE;
@@ -89,11 +108,14 @@ static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,
 again:
 		next = pmd_addr_end(addr, end);
 		if (pmd_none(*pmd)) {
-			if (ops->pte_hole)
+			if (ops->install_pte)
+				err = __pte_alloc(walk->mm, pmd);
+			else if (ops->pte_hole)
 				err = ops->pte_hole(addr, next, depth, walk);
 			if (err)
 				break;
-			continue;
+			if (!ops->install_pte)
+				continue;
 		}
 
 		walk->action = ACTION_SUBTREE;
@@ -116,7 +138,7 @@ static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,
 		 */
 		if ((!walk->vma && (pmd_leaf(*pmd) || !pmd_present(*pmd))) ||
 		    walk->action == ACTION_CONTINUE ||
-		    !(ops->pte_entry))
+		    !(ops->pte_entry || ops->install_pte))
 			continue;
 
 		if (walk->vma)
@@ -148,11 +170,14 @@ static int walk_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end,
  again:
 		next = pud_addr_end(addr, end);
 		if (pud_none(*pud)) {
-			if (ops->pte_hole)
+			if (ops->install_pte)
+				err = __pmd_alloc(walk->mm, pud, addr);
+			else if (ops->pte_hole)
 				err = ops->pte_hole(addr, next, depth, walk);
 			if (err)
 				break;
-			continue;
+			if (!ops->install_pte)
+				continue;
 		}
 
 		walk->action = ACTION_SUBTREE;
@@ -167,7 +192,7 @@ static int walk_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end,
 
 		if ((!walk->vma && (pud_leaf(*pud) || !pud_present(*pud))) ||
 		    walk->action == ACTION_CONTINUE ||
-		    !(ops->pmd_entry || ops->pte_entry))
+		    !(ops->pmd_entry || ops->pte_entry || ops->install_pte))
 			continue;
 
 		if (walk->vma)
@@ -196,18 +221,22 @@ static int walk_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end,
 	do {
 		next = p4d_addr_end(addr, end);
 		if (p4d_none_or_clear_bad(p4d)) {
-			if (ops->pte_hole)
+			if (ops->install_pte)
+				err = __pud_alloc(walk->mm, p4d, addr);
+			else if (ops->pte_hole)
 				err = ops->pte_hole(addr, next, depth, walk);
 			if (err)
 				break;
-			continue;
+			if (!ops->install_pte)
+				continue;
 		}
 		if (ops->p4d_entry) {
 			err = ops->p4d_entry(p4d, addr, next, walk);
 			if (err)
 				break;
 		}
-		if (ops->pud_entry || ops->pmd_entry || ops->pte_entry)
+		if (ops->pud_entry || ops->pmd_entry || ops->pte_entry ||
+		    ops->install_pte)
 			err = walk_pud_range(p4d, addr, next, walk);
 		if (err)
 			break;
@@ -231,18 +260,22 @@ static int walk_pgd_range(unsigned long addr, unsigned long end,
 	do {
 		next = pgd_addr_end(addr, end);
 		if (pgd_none_or_clear_bad(pgd)) {
-			if (ops->pte_hole)
+			if (ops->install_pte)
+				err = __p4d_alloc(walk->mm, pgd, addr);
+			else if (ops->pte_hole)
 				err = ops->pte_hole(addr, next, 0, walk);
 			if (err)
 				break;
-			continue;
+			if (!ops->install_pte)
+				continue;
 		}
 		if (ops->pgd_entry) {
 			err = ops->pgd_entry(pgd, addr, next, walk);
 			if (err)
 				break;
 		}
-		if (ops->p4d_entry || ops->pud_entry || ops->pmd_entry || ops->pte_entry)
+		if (ops->p4d_entry || ops->pud_entry || ops->pmd_entry ||
+		    ops->pte_entry || ops->install_pte)
 			err = walk_p4d_range(pgd, addr, next, walk);
 		if (err)
 			break;
@@ -334,6 +367,11 @@ static int __walk_page_range(unsigned long start, unsigned long end,
 	int err = 0;
 	struct vm_area_struct *vma = walk->vma;
 	const struct mm_walk_ops *ops = walk->ops;
+	bool is_hugetlb = is_vm_hugetlb_page(vma);
+
+	/* We do not support hugetlb PTE installation. */
+	if (ops->install_pte && is_hugetlb)
+		return -EINVAL;
 
 	if (ops->pre_vma) {
 		err = ops->pre_vma(start, end, walk);
@@ -341,7 +379,7 @@ static int __walk_page_range(unsigned long start, unsigned long end,
 			return err;
 	}
 
-	if (is_vm_hugetlb_page(vma)) {
+	if (is_hugetlb) {
 		if (ops->hugetlb_entry)
 			err = walk_hugetlb_range(start, end, walk);
 	} else
@@ -380,47 +418,14 @@ static inline void process_vma_walk_lock(struct vm_area_struct *vma,
 #endif
 }
 
-/**
- * walk_page_range - walk page table with caller specific callbacks
- * @mm:		mm_struct representing the target process of page table walk
- * @start:	start address of the virtual address range
- * @end:	end address of the virtual address range
- * @ops:	operation to call during the walk
- * @private:	private data for callbacks' usage
- *
- * Recursively walk the page table tree of the process represented by @mm
- * within the virtual address range [@start, @end). During walking, we can do
- * some caller-specific works for each entry, by setting up pmd_entry(),
- * pte_entry(), and/or hugetlb_entry(). If you don't set up for some of these
- * callbacks, the associated entries/pages are just ignored.
- * The return values of these callbacks are commonly defined like below:
- *
- *  - 0  : succeeded to handle the current entry, and if you don't reach the
- *         end address yet, continue to walk.
- *  - >0 : succeeded to handle the current entry, and return to the caller
- *         with caller specific value.
- *  - <0 : failed to handle the current entry, and return to the caller
- *         with error code.
- *
- * Before starting to walk page table, some callers want to check whether
- * they really want to walk over the current vma, typically by checking
- * its vm_flags. walk_page_test() and @ops->test_walk() are used for this
- * purpose.
- *
- * If operations need to be staged before and committed after a vma is walked,
- * there are two callbacks, pre_vma() and post_vma(). Note that post_vma(),
- * since it is intended to handle commit-type operations, can't return any
- * errors.
- *
- * struct mm_walk keeps current values of some common data like vma and pmd,
- * which are useful for the access from callbacks. If you want to pass some
- * caller-specific data to callbacks, @private should be helpful.
+/*
+ * See the comment for walk_page_range(), this performs the heavy lifting of the
+ * operation, only sets no restrictions on how the walk proceeds.
  *
- * Locking:
- *   Callers of walk_page_range() and walk_page_vma() should hold @mm->mmap_lock,
- *   because these function traverse vma list and/or access to vma's data.
+ * We usually restrict the ability to install PTEs, but this functionality is
+ * available to internal memory management code and provided in mm/internal.h.
  */
-int walk_page_range(struct mm_struct *mm, unsigned long start,
+int walk_page_range_mm(struct mm_struct *mm, unsigned long start,
 		unsigned long end, const struct mm_walk_ops *ops,
 		void *private)
 {
@@ -479,6 +484,80 @@ int walk_page_range(struct mm_struct *mm, unsigned long start,
 	return err;
 }
 
+/*
+ * Determine if the walk operations specified are permitted to be used for a
+ * page table walk.
+ *
+ * This check is performed on all functions which are parameterised by walk
+ * operations and exposed in include/linux/pagewalk.h.
+ *
+ * Internal memory management code can use the walk_page_range_mm() function to
+ * be able to use all page walking operations.
+ */
+static bool check_ops_valid(const struct mm_walk_ops *ops)
+{
+	/*
+	 * The installation of PTEs is solely under the control of memory
+	 * management logic and subject to many subtle locking, security and
+	 * cache considerations so we cannot permit other users to do so, and
+	 * certainly not for exported symbols.
+	 */
+	if (ops->install_pte)
+		return false;
+
+	return true;
+}
+
+/**
+ * walk_page_range - walk page table with caller specific callbacks
+ * @mm:		mm_struct representing the target process of page table walk
+ * @start:	start address of the virtual address range
+ * @end:	end address of the virtual address range
+ * @ops:	operation to call during the walk
+ * @private:	private data for callbacks' usage
+ *
+ * Recursively walk the page table tree of the process represented by @mm
+ * within the virtual address range [@start, @end). During walking, we can do
+ * some caller-specific works for each entry, by setting up pmd_entry(),
+ * pte_entry(), and/or hugetlb_entry(). If you don't set up for some of these
+ * callbacks, the associated entries/pages are just ignored.
+ * The return values of these callbacks are commonly defined like below:
+ *
+ *  - 0  : succeeded to handle the current entry, and if you don't reach the
+ *         end address yet, continue to walk.
+ *  - >0 : succeeded to handle the current entry, and return to the caller
+ *         with caller specific value.
+ *  - <0 : failed to handle the current entry, and return to the caller
+ *         with error code.
+ *
+ * Before starting to walk page table, some callers want to check whether
+ * they really want to walk over the current vma, typically by checking
+ * its vm_flags. walk_page_test() and @ops->test_walk() are used for this
+ * purpose.
+ *
+ * If operations need to be staged before and committed after a vma is walked,
+ * there are two callbacks, pre_vma() and post_vma(). Note that post_vma(),
+ * since it is intended to handle commit-type operations, can't return any
+ * errors.
+ *
+ * struct mm_walk keeps current values of some common data like vma and pmd,
+ * which are useful for the access from callbacks. If you want to pass some
+ * caller-specific data to callbacks, @private should be helpful.
+ *
+ * Locking:
+ *   Callers of walk_page_range() and walk_page_vma() should hold @mm->mmap_lock,
+ *   because these function traverse vma list and/or access to vma's data.
+ */
+int walk_page_range(struct mm_struct *mm, unsigned long start,
+		unsigned long end, const struct mm_walk_ops *ops,
+		void *private)
+{
+	if (!check_ops_valid(ops))
+		return -EINVAL;
+
+	return walk_page_range_mm(mm, start, end, ops, private);
+}
+
 /**
  * walk_page_range_novma - walk a range of pagetables not backed by a vma
  * @mm:		mm_struct representing the target process of page table walk
@@ -494,7 +573,7 @@ int walk_page_range(struct mm_struct *mm, unsigned long start,
  * walking the kernel pages tables or page tables for firmware.
  *
  * Note: Be careful to walk the kernel pages tables, the caller may be need to
- * take other effective approache (mmap lock may be insufficient) to prevent
+ * take other effective approaches (mmap lock may be insufficient) to prevent
  * the intermediate kernel page tables belonging to the specified address range
  * from being freed (e.g. memory hot-remove).
  */
@@ -513,6 +592,8 @@ int walk_page_range_novma(struct mm_struct *mm, unsigned long start,
 
 	if (start >= end || !walk.mm)
 		return -EINVAL;
+	if (!check_ops_valid(ops))
+		return -EINVAL;
 
 	/*
 	 * 1) For walking the user virtual address space:
@@ -556,6 +637,8 @@ int walk_page_range_vma(struct vm_area_struct *vma, unsigned long start,
 		return -EINVAL;
 	if (start < vma->vm_start || end > vma->vm_end)
 		return -EINVAL;
+	if (!check_ops_valid(ops))
+		return -EINVAL;
 
 	process_mm_walk_lock(walk.mm, ops->walk_lock);
 	process_vma_walk_lock(vma, ops->walk_lock);
@@ -574,6 +657,8 @@ int walk_page_vma(struct vm_area_struct *vma, const struct mm_walk_ops *ops,
 
 	if (!walk.mm)
 		return -EINVAL;
+	if (!check_ops_valid(ops))
+		return -EINVAL;
 
 	process_mm_walk_lock(walk.mm, ops->walk_lock);
 	process_vma_walk_lock(vma, ops->walk_lock);
@@ -623,6 +708,9 @@ int walk_page_mapping(struct address_space *mapping, pgoff_t first_index,
 	unsigned long start_addr, end_addr;
 	int err = 0;
 
+	if (!check_ops_valid(ops))
+		return -EINVAL;
+
 	lockdep_assert_held(&mapping->i_mmap_rwsem);
 	vma_interval_tree_foreach(vma, &mapping->i_mmap, first_index,
 				  first_index + nr - 1) {
-- 
2.46.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0b-00069f02.pphosted.com (mx0b-00069f02.pphosted.com [205.220.177.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id A4A90227B81;
	Thu, 17 Oct 2024 20:43:24 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.177.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729197811; cv=fail; b=CkGDLvJNDNPmM9gpzBPAnHlvvQ8MmaOHWBX1x2mEPNe4B16egvT4BW3ioWykie5E+0FT0Tyvn0jOeCvh6qSCf2SAIifl1LMLXyWkphQU8wvKwyCnTwvj/TLqOw83qdcOxXd5IoYfMj17cYA+3U8HIQWT0WMxr5lT7MGAflhsyJg=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729197811; c=relaxed/simple;
	bh=seRFlbig6bmMj4L85vquOgIQfJWEVSoox1fS5GDlnrM=;
	h=From:To:Cc:Subject:Date:Message-ID:Content-Type:MIME-Version; b=QMUNICCf0ywEklCnTFM/VV6yqzABFErhn50XLcCHvjN5rLP+DSdT2FIaXGPSTqj8X3GS+bbzzfXynH0t9xC/zcDk7Inz2PAl7DSwFx8OOcRNqyRGpOSCfUWI2MuuvUjP3pgV2nSk1lf3fCrhg03b3PS3YxtS+wCYFt6Y5JLwU98=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=hfO0U7Fb; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=yCFy7uDd; arc=fail smtp.client-ip=205.220.177.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="hfO0U7Fb";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="yCFy7uDd"
Received: from pps.filterd (m0246630.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49HFBvQb024544;
	Thu, 17 Oct 2024 20:42:48 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-transfer-encoding:content-type:date:from:message-id
	:mime-version:subject:to; s=corp-2023-11-20; bh=JFjBK3TRj3stnAAc
	vD7TcUXrYRF59XCIoJApGcGNuJ8=; b=hfO0U7FbpvmYBw23xpHN3rJ9Ej46S3Cm
	Bs8VVeoDTUi+K9e9Nva4v8DegXIBhVk9Fcz5tR1LLviWzxwidMW3GfWv09PU6+WL
	cW3/CbYNiT8tERTUNO9W2V15IoRM5cvAeH0HdekyuhIziQ0r9LmxnKr5AGx8Mqg8
	spKcYac7xIhmh5qxt3gw4VcLwEaTbhcF6A9BcKjNOOTcqW84NAZ5n83pqpkkCuE/
	kXeipEqOpD2N5kTnsXXoNMsZV4tjUIPgXVdCSeyjncsVTPDnxWt+E7VogD94Z69N
	jfENNMuf5BvBfFeYYW18xRmjXRhwHqgN8xB82hGjZ3r56RfrRWXGuA==
Received: from phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (phxpaimrmta03.appoci.oracle.com [138.1.37.129])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427fhcpyqr-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:42:47 +0000 (GMT)
Received: from pps.filterd (phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com [127.0.0.1])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49HKDTec014081;
	Thu, 17 Oct 2024 20:42:46 GMT
Received: from nam10-bn7-obe.outbound.protection.outlook.com (mail-bn7nam10lp2041.outbound.protection.outlook.com [104.47.70.41])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (PPS) with ESMTPS id 427fjarege-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:42:46 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=zWWnf4by29EAk5VSoeqhjMfGxthxAChyydZe14lraHKt0E2/9CG3MT9YonIn64ufnWCF9+deLKQTu/Lck+fDtAvdPAq8yAbdiopz/KqYV3szF+83m7GqSi+5uYwCwi6qGFdy+6jSkHS4vFgrcDfAz5LGSOBCmnQL+1vIfWNm0PLN4NHG5eN92q5vImm/1XL6td4F53I4zqx+kkWDU+GcR9XsmwkieBKP3YiIBqeX2lLGvqftqVtDzS85H5p3XqdvSBSLEwnR1mXdvxcqyv53hqrR5txx6JBoISfoAyBP4wmEi7hJby+H/CQLRt7Kakm2WrjmJrC3LUlGHyUiC5+8Dg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=JFjBK3TRj3stnAAcvD7TcUXrYRF59XCIoJApGcGNuJ8=;
 b=F0jUsznQ0lEME9B3/dkU9Eip5tG7iQ0jiKvS8zcE2/4O4tQOrvcawu4EY87kN0rLj13+cztsLMbonJuDtJ7ZltC6m/RevexAMf3ILGQM9oQ19HJ2mfknxaGbzFaZAYBHg0MgvW4pEFxmtRoK7kYfaSdBZ6OqOESocjHVG1DWdMYCzdsdQPfxadTApoM+PVjc1a2Xw0wmDp5tzpb+XUqs3radTpYL5rGpiDsGJrv6TF63gboQ0P7hrvn4wvNtgYDuqWPqZz0xRtclxN7Bl4+z8gzWoZFgQfD3wmNBp69QGIg8nEBTgo8rWKPHl3kjIqgTmrcNCeIudC8gr/PcEh+zbA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=JFjBK3TRj3stnAAcvD7TcUXrYRF59XCIoJApGcGNuJ8=;
 b=yCFy7uDdi2OknQ4iPK688BuJPD+py9/Y/KdMSmwUCw+a2Xm3Tg/zDm9tcWvEPd8U4+K/n1XhSL4dCHFbtygL7EOWk5AiwtFbNuzNt1ZC0xs0oi0XA4231QlLFDTiK9r5Q8XiHqrD7fudbY+y0Xwudfy1/ZEGZ9evw00ow4ONMPg=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by DS7PR10MB5974.namprd10.prod.outlook.com (2603:10b6:8:9e::10) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.18; Thu, 17 Oct
 2024 20:42:43 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Thu, 17 Oct 2024
 20:42:43 +0000
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Andrew Morton <akpm@linux-foundation.org>
Cc: Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@HansenPartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: [PATCH 0/4] implement lightweight guard pages
Date: Thu, 17 Oct 2024 21:42:34 +0100
Message-ID: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
X-Mailer: git-send-email 2.46.2
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: LO2P265CA0366.GBRP265.PROD.OUTLOOK.COM
 (2603:10a6:600:a3::18) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|DS7PR10MB5974:EE_
X-MS-Office365-Filtering-Correlation-Id: 703da154-9af7-459c-87dc-08dceeec3fac
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|7416014|376014|366016|1800799024;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?m98Bo9X+p4VplSh8ISy0RUq5kh4xqQepdItIIQrscY5X2VmYllybz822jXgf?=
 =?us-ascii?Q?yL4XfmEWbXtxgBjwm+2JglPF0ZVfBDEwz9RsCzzZVZlZLr90kRmMRrVlrrch?=
 =?us-ascii?Q?wOfmrQCaG+GQ8R7xpjOOBLSBQHbOhSmCAUPHI/0hMs28oSdHIoU+4AFlXAN+?=
 =?us-ascii?Q?+1OHTbFlpgRmxaS20n+T+WnDPNR+V8k2EwHqxwJOr1ybhRzPg6vwWuQ7ymyz?=
 =?us-ascii?Q?6/Ii3ElzoxM7lgTVmCdFeS33fIug9oJZRIB6wWnJ+I0efd4+80WG4NTSNIDb?=
 =?us-ascii?Q?4zj9HpxGWTpoADqQj8rjINTAVXsI8D7NzkJUH5f9gKNAMAyjmww0Bp7K8NHE?=
 =?us-ascii?Q?MUkEcsulWONW+PYF4dN+DaVD+N0ELqfptK9Pg7NmU2LDrcQ4FpPQAPSrm+qT?=
 =?us-ascii?Q?cxKwXazF5G7I4z6HdGVHfl5N5VvzsEK9UYbmCp/NxZu7/TBSZ3y7wQRW64OA?=
 =?us-ascii?Q?wlNavMJ/LEh3vMariRTbVO0hiNZ4nGBYEhex4L/7EMDlcp4cP3pDK63gBFQl?=
 =?us-ascii?Q?yio+XQ6TXKnBaEccV3EZXTb8W7UfYwjORhxP+AsJg49Jk36HedfhkndVvjCh?=
 =?us-ascii?Q?7SWsJI4RKWdyVaXgMW+vcPK3STL79mrX+0tR7hd4rfLqIzcAtgtgxZf685O/?=
 =?us-ascii?Q?NCO44eaRwpm6qHfTXh4mFTUtVNXKWh898PIlWsv71We6eGrovOPcEPqYsvZN?=
 =?us-ascii?Q?Bb7ncOUhYB+Jn1qX1zFvlrSmpUiJMo43ioeXfxyZWK1AMB3rgwQCUxy7V0XJ?=
 =?us-ascii?Q?kDB76zNAJWPtGm3jk/JKIlly231b1e4Gw26+mIK/xStg3iErhXngs0Zlfuk9?=
 =?us-ascii?Q?v81c03xS5m5H/kOMorbLaywt8jSWnzMu5UWwTOS22dNhi5goXjmsj0TqPSSD?=
 =?us-ascii?Q?BmAvqCOUy+hukLfQnUmNO7yOdpFzWoWAlur0PXKXVMP/SfteFvc+/vIqv92b?=
 =?us-ascii?Q?q/bCjiS7FhYTjCHTCOeYRJIUxbnILYlyxAH3X52z7Wa/i3qDnUEltU40RC3M?=
 =?us-ascii?Q?a/2PovLYSVFML+tTbf57wu+ni8yEdyRjbEOL0nm41NgltAg1Lewr3uSQ4wUv?=
 =?us-ascii?Q?hLLDc5JN0z+6Uy/YVVOrVqEJDzqI1Vn806Ubd1sM19fnWCGPYtB+AuaLx1MJ?=
 =?us-ascii?Q?xUCPlRaqbpExB97aSNtsaTY5v2KAu1Ruwd8LoAc/kVubgsjN0rR3f6jLOSlA?=
 =?us-ascii?Q?K2+n9byO7/o0v6esqwc5XCpCFW+xIA7KmgJDWFYkgLcgpefb2mDGUMzT8CvF?=
 =?us-ascii?Q?C0hAYQERGkqeSWexIitlxJIko8mYM8Iepc//eu/kZGUgtpVInHwVaywnKsG/?=
 =?us-ascii?Q?5MCcHF4OjWUnobpOB0TE7GLn?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(7416014)(376014)(366016)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?r5waV27vnCSvaRE6GcBeCA9JehpDLIOVMNHLg4/olG/0RY1b74tBndQlNiDq?=
 =?us-ascii?Q?CcZCZ+LjplDe8Ox/cmxupBlb6FZ4kPgZ62+oftcP5K8m2XQZUzJsyDFS2xUP?=
 =?us-ascii?Q?3dJskPvjedXrAZdtOUFuUSXMdLznvwRonQzLvjMpOeIUDJNjHNMc+lGZnE3m?=
 =?us-ascii?Q?BJVS+NY9Ia+XC16F3YzVI2N1iVmVYcvvgzv8+rEw2Z1OpCjC0As7omNAbsob?=
 =?us-ascii?Q?2ancefKtiEMa+sdFGAm7CE8uTlMrg7/O+eeOkOlrSXqZqa1y0FQdvFOmxN/w?=
 =?us-ascii?Q?YYZox+bLZecC3Qut7tEsyZYAn9HUU2D7Q8GpQb2VdSq2BTV4WD0XB9shrcRl?=
 =?us-ascii?Q?X8oSWKUhIa80DsN2AY4HPfM8ElpkL9M7cxs4HZJAIkkO4njQl6c0ylePu5uH?=
 =?us-ascii?Q?LC0yHgSOH4GHldjuNNCib/fZIFduMXpHyqahUahNFNyJozFEv/rXrx+UnAml?=
 =?us-ascii?Q?q/CtUscjXcFXfEeEh7eICZ689EXFXhhNK9dDJd5TjmU8x67OPkjU1GowhXGL?=
 =?us-ascii?Q?hGS8ViuHmtyRWUkPynKpLgw0ClBPP6+VTWgXQMXTI0PK34B21omAde7OUius?=
 =?us-ascii?Q?u35UwEEXG4WYrxrqSsugzVgkIF81yf8dI6vWc+wTEjA6N9YhD0VlR/xJw0AX?=
 =?us-ascii?Q?ggmyHyEBUktNiTiRYHGF7e+9K/Ao7V6H2BgneRChrLpLxENspaisR6Zwdw2C?=
 =?us-ascii?Q?8vqxPFdkRy8RGdY6jcc1JEZdqeeB3ejJCuNHgR8hGVvJk9BSmwHmGpnkQLbQ?=
 =?us-ascii?Q?ZCqs6FwLqBImjl+3SaQYVETzQUXbG32A9Fbj4SXo+cgbagKqDlLqRU613MQ3?=
 =?us-ascii?Q?O6jpmlFtaxInTqsa2V+A/K6dxtJ9ZyAu/xndv65eylelfn97r9VGxyO+jbi+?=
 =?us-ascii?Q?4s22ioKhBrjq1Lmw1L7xyyYZupve86uOkA8YCPPaYrlUtph7cIxuERD0Bx1W?=
 =?us-ascii?Q?vcZvzUX0Vb7N2WehozIZUEAO+1TtTFKl6o+mWIcccBJhZHoJJtDiv6i9+62K?=
 =?us-ascii?Q?yuIzZ65VahddlSv09jw3uLILg53CroHwydXI3zvnBaooF8UyRZJDmUoMl/w2?=
 =?us-ascii?Q?PEQ/qZuSyobWnGbJsASC/KpuLJu7E61OsAfnUyOErRZ2Vb+GA6aS84JMCKQH?=
 =?us-ascii?Q?759YsNIL3dzEmSy37cNTB+0dvloDS0eGTFFyXK/gYQgI3gztiaR1ZrV3c79B?=
 =?us-ascii?Q?L37JiR2to+vM7UYwd9YlCTu0fS9hHdAPL1d9Nb1pYU341NCNlIhT8GMvV/VL?=
 =?us-ascii?Q?pR9TwFhEeqeU+/dViyMzekizE9dy1o8ot10HWOtBsqFfOtrQVQROMmBRxxjc?=
 =?us-ascii?Q?SsIDOKZ1ktzDJJkEdxXf85KTrFM2b+jR9tPu73LkABwpB36QOGqex3ayFkwf?=
 =?us-ascii?Q?xh6pT9AHnpXTbDO6vjL51cVO+RHt3mZRyc7jOn0FRs1VbJVVTh05X2U4VCOg?=
 =?us-ascii?Q?exVwfh+0Nrpi6RuPncenbyagh+JDBQcLzPwNIBFapwkHIEGVPhX7t4Q856nB?=
 =?us-ascii?Q?PVfjhjgxVMS5bi3Rxe3iE5WBexv+vXp3uUsR3jPctWd6CFj841uag5kqJ6bz?=
 =?us-ascii?Q?gKan7FWw2Nvn6GQHTLw6xEZLKevYX9/kgzJGKb9ILckfEl+CywrTF4oGUTpC?=
 =?us-ascii?Q?NA=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	2JYK3RJWv03RvdK8AjaABhc2kNNhOT15i8aJaMq9J0/w5oVddr5136ehBFwrXnON/+g6HjSvHql5tKWnMoVudvauBs8NxgVT0+KESVMplEc1rMc7VaGBGUEdCRb6Zp0KMBPxtRNQ7rdwE3OELNN+44b5P0QF52gISXemvZZk0rn48z2mXvGMNyVG34pU064aE7DIMqOQDMjq4K/Z4qqguXIRiai3Lm34Ov1ok0O90JDZWiZO7+/mUzkEL7Cs9aBsoEl4jdLbd7zXD9ksqHJTwE6kShe218RLjhpQXTXyPM3jCeBRCZXoNeWRTiXW2w5IFDpD1t/quUeCVLUAQ/GkV0VlaU9Aq4bELcxoOZAJIuXh+gBjFM/qoLY8QktJV7d9CwcsV6Kl2v09SI6o3Gw4GyITahGqGfz80VpShR64L9d3gZ675q/LrxFmdQqtJl73uY0S0d/9wZy7tySC3NTqSaOZXbwqtFxt7EUOINkcM5Mar2PNSFiBZC9ZWFK2l4p5vwTEQ6purM+o6yGWyPJijROnZLY40DYXgVpgWWK8lfe9ieS6m1jV4Kv5pMq5fM2IVxhW6MVv8fOD/Ye/iDGB8KlEsRxOz8w4LWIW9UUdBEI=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 703da154-9af7-459c-87dc-08dceeec3fac
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Oct 2024 20:42:43.0710
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: gLN3jMUhmwZC8fiaee1Qg1qGiL0hIizeB2pa5fKtj3ceT4ROEximdUzYvmrAGN184Dlt3yZS4SdskReUsKfmtq/r4FlnmWw2J8qzXsMWny8=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DS7PR10MB5974
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-17_23,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 malwarescore=0 phishscore=0 mlxscore=0
 mlxlogscore=811 bulkscore=0 spamscore=0 suspectscore=0 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2409260000
 definitions=main-2410170139
X-Proofpoint-GUID: _zO60PHbznZfGshKT2uf37f1SbrFvXPH
X-Proofpoint-ORIG-GUID: _zO60PHbznZfGshKT2uf37f1SbrFvXPH

Userland library functions such as allocators and threading implementations
often require regions of memory to act as 'guard pages' - mappings which,
when accessed, result in a fatal signal being sent to the accessing
process.

The current means by which these are implemented is via a PROT_NONE mmap()
mapping, which provides the required semantics however incur an overhead of
a VMA for each such region.

With a great many processes and threads, this can rapidly add up and incur
a significant memory penalty. It also has the added problem of preventing
merges that might otherwise be permitted.

This series takes a different approach - an idea suggested by Vlasimil
Babka (and before him David Hildenbrand and Jann Horn - perhaps more - the
provenance becomes a little tricky to ascertain after this - please forgive
any omissions!)  - rather than locating the guard pages at the VMA layer,
instead placing them in page tables mapping the required ranges.

Early testing of the prototype version of this code suggests a 5 times
speed up in memory mapping invocations (in conjunction with use of
process_madvise()) and a 13% reduction in VMAs on an entirely idle android
system and unoptimised code.

We expect with optimisation and a loaded system with a larger number of
guard pages this could significantly increase, but in any case these
numbers are encouraging.

This way, rather than having separate VMAs specifying which parts of a
range are guard pages, instead we have a VMA spanning the entire range of
memory a user is permitted to access and including ranges which are to be
'guarded'.

After mapping this, a user can specify which parts of the range should
result in a fatal signal when accessed.

By restricting the ability to specify guard pages to memory mapped by
existing VMAs, we can rely on the mappings being torn down when the
mappings are ultimately unmapped and everything works simply as if the
memory were not faulted in, from the point of view of the containing VMAs.

This mechanism in effect poisons memory ranges similar to hardware memory
poisoning, only it is an entirely software-controlled form of poisoning.

Any poisoned region of memory is also able to 'unpoisoned', that is, to
have its poison markers removed.

The mechanism is implemented via madvise() behaviour - MADV_GUARD_POISON
which simply poisons ranges - and MADV_GUARD_UNPOISON - which clears this
poisoning.

Poisoning can be performed across multiple VMAs and any existing mappings
will be cleared, that is zapped, before installing the poisoned page table
mappings.

There is no concept of 'nested' poisoning, multiple attempts to poison a
range will, after the first poisoning, have no effect.

Importantly, unpoisoning of poisoned ranges has no effect on non-poisoned
memory, so a user can safely unpoison a range of memory and clear only
poison page table mappings leaving the rest intact.

The actual mechanism by which the page table entries are specified makes
use of existing logic - PTE markers, which are used for the userfaultfd
UFFDIO_POISON mechanism.

Unfortunately PTE_MARKER_POISONED is not suited for the guard page
mechanism as it results in VM_FAULT_HWPOISON semantics in the fault
handler, so we add our own specific PTE_MARKER_GUARD and adapt existing
logic to handle it.

We also extend the generic page walk mechanism to allow for installation of
PTEs (carefully restricted to memory management logic only to prevent
unwanted abuse).

We ensure that zapping performed by, for instance, MADV_DONTNEED, does not
remove guard poison markers, nor does forking (except when VM_WIPEONFORK is
specified for a VMA which implies a total removal of memory
characteristics).

It's important to note that the guard page implementation is emphatically
NOT a security feature, so a user can remove the poisoning if they wish. We
simply implement it in such a way as to provide the least surprising
behaviour.

An extensive set of self-tests are provided which ensure behaviour is as
expected and additionally self-documents expected behaviour of poisoned
ranges.

Suggested-by: Vlastimil Babka <vbabka@suze.cz>
Suggested-by: Jann Horn <jannh@google.com>
Suggested-by: David Hildenbrand <david@redhat.com>

v1
* Un-RFC'd as appears no major objections to approach but rather debate on
  implementation.
* Fixed issue with arches which need mmu_context.h and
  tlbfush.h. header imports in pagewalker logic to be able to use
  update_mmu_cache() as reported by the kernel test bot.
* Added comments in page walker logic to clarify who can use
  ops->install_pte and why as well as adding a check_ops_valid() helper
  function, as suggested by Christoph.
* Pass false in full parameter in pte_clear_not_present_full() as suggested
  by Jann.
* Stopped erroneously requiring a write lock for the poison operation as
  suggested by Jann and Suren.
* Moved anon_vma_prepare() to the start of madvise_guard_poison() to be
  consistent with how this is used elsewhere in the kernel as suggested by
  Jann.
* Avoid returning -EAGAIN if we are raced on page faults, just keep looping
  and duck out if a fatal signal is pending or a conditional reschedule is
  needed, as suggested by Jann.
* Avoid needlessly splitting huge PUDs and PMDs by specifying
  ACTION_CONTINUE, as suggested by Jann.

RFC
https://lore.kernel.org/all/cover.1727440966.git.lorenzo.stoakes@oracle.com/

Lorenzo Stoakes (4):
  mm: pagewalk: add the ability to install PTEs
  mm: add PTE_MARKER_GUARD PTE marker
  mm: madvise: implement lightweight guard page mechanism
  selftests/mm: add self tests for guard page feature

 arch/alpha/include/uapi/asm/mman.h       |    3 +
 arch/mips/include/uapi/asm/mman.h        |    3 +
 arch/parisc/include/uapi/asm/mman.h      |    3 +
 arch/xtensa/include/uapi/asm/mman.h      |    3 +
 include/linux/mm_inline.h                |    2 +-
 include/linux/pagewalk.h                 |   18 +-
 include/linux/swapops.h                  |   26 +-
 include/uapi/asm-generic/mman-common.h   |    3 +
 mm/hugetlb.c                             |    3 +
 mm/internal.h                            |    6 +
 mm/madvise.c                             |  168 ++++
 mm/memory.c                              |   18 +-
 mm/mprotect.c                            |    3 +-
 mm/mseal.c                               |    1 +
 mm/pagewalk.c                            |  200 ++--
 tools/testing/selftests/mm/.gitignore    |    1 +
 tools/testing/selftests/mm/Makefile      |    1 +
 tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
 18 files changed, 1564 insertions(+), 66 deletions(-)
 create mode 100644 tools/testing/selftests/mm/guard-pages.c

--
2.46.2

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0a-00069f02.pphosted.com (mx0a-00069f02.pphosted.com [205.220.165.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 55B01229134;
	Thu, 17 Oct 2024 20:43:32 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.165.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729197814; cv=fail; b=EGrYLFhgdxGvQqgGjD0oTge6tWavxDDDDYqCNKeqT4rea4pQBQgWxYgaXS5HFwDjH5MO4GccMAfo38XmbqcvNOW6W+kq13dt7SpKVHLfXfwOdQmMtPJYi4jTqOvSsOXgwIFnMdVwmOuW6Qxb3jAoUtLWDMSD4cTV3gmaUCpUPwk=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729197814; c=relaxed/simple;
	bh=weJnfCo8iCo0onxne+DIwlybazXwHadMOFndAz3D9YI=;
	h=From:To:Cc:Subject:Date:Message-ID:In-Reply-To:References:
	 Content-Type:MIME-Version; b=kuSNrWtA6c2YaapoozKBhR4kIf5BILpKXIYjIfiP18v5vk8xHApQ+yyVHqJih2x3/jyqwPr+4HbtR/9awTKibecdY60KvQZoQ+EGiF/ls6v/dBhluehoUAHOyEKGU+I4xQDuN2YtqPFPfOCYvXh1x/JgGoerpYkGI+LN+YUlUII=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=TNfhDw5c; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=kzExMkDu; arc=fail smtp.client-ip=205.220.165.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="TNfhDw5c";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="kzExMkDu"
Received: from pps.filterd (m0246629.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49HFBems000334;
	Thu, 17 Oct 2024 20:42:54 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-transfer-encoding:content-type:date:from:in-reply-to
	:message-id:mime-version:references:subject:to; s=
	corp-2023-11-20; bh=5MFnXUdslOqsT6J/eW5S/+20CDpOLupPW1WBkk3fQsA=; b=
	TNfhDw5cHMWroI1NEZSqe24Rb+N7pcAwxDBrd10Ys7LMV934viVlH7PVByvwxWRu
	BX5B+DKCTwY9PAyJPUqPQtKATXU7+bwdPNABYPyTiTK2QAn3BpIgZvFtGLw/2SLB
	DCnvUYqffZBF3q5QPjvWu8jowop9Hc08BzvjMmWRV7yAr8mAySf0/ZhhC8IDL+gV
	Mk2q4nMDuFZTVMWuBys0BtvrFiLUOoMoEnDMwwZvRPu0XvP6eiP5+NjqjCOiVYFu
	Je76HbaQ4BNtfKdGvWNOPPkRycUaWWxERkBLIj7pH1qOt7/UEhdaHCFh9OX7uXse
	TUY6q3yBqlVJ8HSfKQP/OQ==
Received: from phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (phxpaimrmta03.appoci.oracle.com [138.1.37.129])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427h09ptq7-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:42:53 +0000 (GMT)
Received: from pps.filterd (phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com [127.0.0.1])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49HJNIiF013980;
	Thu, 17 Oct 2024 20:42:53 GMT
Received: from nam12-mw2-obe.outbound.protection.outlook.com (mail-mw2nam12lp2041.outbound.protection.outlook.com [104.47.66.41])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (PPS) with ESMTPS id 427fjarenb-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:42:53 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=V2bXZKytxnfXrluUFupx8e3HwlZ10KzhSSqjU5X1kjyFQISKyxYaJ+qnJOoXIHP962TQqPFixvTfsbGItQJ5WxjR62otbv0+5X8qgz3iaGZR0ukhEhf80iC4moNJFcQ2BW3E3eNz5tRfG6+K2GcBgO+H1jwKG5Zzq+JL5qf78zw7QUMnMPaUR/EuSrIosukXWgp1+uqG/rputxHpfdneo2YVnkh42V8g447Iazq/gLLYOcd7R3EEEY9AHhrPkwkrB6GypwCbsvqdYGPJb4BMT/Rddvm2shSu7Ilo0XNsaepCJCE7/5INmh5syG6QUGscYTg0JSnxPkY+yIEYEtWz1g==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=5MFnXUdslOqsT6J/eW5S/+20CDpOLupPW1WBkk3fQsA=;
 b=TRVokPCeZ6Y2uiCRlqPb+YAyH8F+sGQz2VnxS7GX6q/jMlLTDvsiHmPUwpXXyxk1eKYnOaWJykHcmyBsFX3VduigzTJndQ9aKr8EtTu7LNLA/DVXnz1PJ6A/1Dg0PhIKWtAKVx2d0o4ToAjiQwQAuTJIIghR1GvFpm1KNvyAM+wl8kh2ksaLHESL8PKSnK3ifz1tgVuLVi8aiku1bQuNrZHdB7wQ355L2p62xlNHAIou8HJu2TDEqaEg88rud9FjkvhNB8H8a4jBWpBjvO6Cd65i4yotI3Q9ttncoReH6yic8eOL9NJAyBZJOBVFwl2RA0X05zgqHhCafaZECtpnCg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=5MFnXUdslOqsT6J/eW5S/+20CDpOLupPW1WBkk3fQsA=;
 b=kzExMkDuoRD8CmKAXj2dX2Pg8cE9HVJayAbJxt6lPLyFOjOTO4xsbF2qZJt9p98dKDDX1jFbbRopUTQa1Np5gtY7YznNIV2RxLNQAuJjvdmRMLK+cdGi21egtQb1ookbvPXSGahlyd0q0Ch6U5Fw6X51Dw0PyRXhAjNvboerF3Y=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by DS7PR10MB5974.namprd10.prod.outlook.com (2603:10b6:8:9e::10) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.18; Thu, 17 Oct
 2024 20:42:49 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Thu, 17 Oct 2024
 20:42:48 +0000
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Andrew Morton <akpm@linux-foundation.org>
Cc: Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@HansenPartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: [PATCH 2/4] mm: add PTE_MARKER_GUARD PTE marker
Date: Thu, 17 Oct 2024 21:42:36 +0100
Message-ID: <4dcba8f8e3b6624c45eedc96345395002b052126.1729196871.git.lorenzo.stoakes@oracle.com>
X-Mailer: git-send-email 2.46.2
In-Reply-To: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: LO2P265CA0424.GBRP265.PROD.OUTLOOK.COM
 (2603:10a6:600:a0::28) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|DS7PR10MB5974:EE_
X-MS-Office365-Filtering-Correlation-Id: 6e92e92c-56cf-4de2-1032-08dceeec432f
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|7416014|376014|366016|1800799024;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?2z4ynNtYO50I4pb5/7AUa9GP0zEXrlNhCrOe1mA/8lu9ih6Uu1vW+faL0E5V?=
 =?us-ascii?Q?QWJeZuHmRmkvo5/BeVMFI0kG8z+QpCNeNBJYNLmxkhXliz0pTapywJjSUGGm?=
 =?us-ascii?Q?bekoN1/FO0YaMsgWV0i49HsT9uIMRg04hpRAgjU8TczBffWPqrWA17aZxQB5?=
 =?us-ascii?Q?E1YbPWJnPTaoxaLos8AETAnIUB/iBqbOo2ltuzXq6+n+3L3pQ+lJX1T847kd?=
 =?us-ascii?Q?FNXFb9yXBOcncTc8G7KIDNry3caETRAqfqitnQIsOqmkbxmFKpF7U3d47TVf?=
 =?us-ascii?Q?RKuiWMuFZSGLDZ4nr3oBhfic5LA7wjHSEPrgxA9Nk4t4co+zDY0Oi1oKOu5Z?=
 =?us-ascii?Q?Z3gy+XsaORrkohOVhj5Rvf/G/C4JNp1nOktYretwLS4/7X49VsrEFF3mREI1?=
 =?us-ascii?Q?JL82J2pLTwnaMCWpkTB/FWa42IHckcujiWS8bakTTi0uEviLDahCp1J9ysP0?=
 =?us-ascii?Q?jdZjXTvlaQIjEUQhH1KLiR68W+AeBo1kfIkaA8iCHck382zyg/JX9wpwDR8f?=
 =?us-ascii?Q?ToGNyv2gK+6sEz3BOC0alsWZSwFs1/msDjW8z/MOcCJgteLKUjXzaDNAXE79?=
 =?us-ascii?Q?0yHPMx5Rlm7JdAfWIxTm8+9QKO5iNSQCDv6FcuV++FL4br1vhdMMUHS9kSXG?=
 =?us-ascii?Q?mvROVx7+/AzksGNtHtjz9cGAj9LNy/E7dXFuM4NAaHhZbCcNMtVoADkgvSwW?=
 =?us-ascii?Q?SKA+CqXqHvmHDKhMgOm/XZYgAgP3HDLtxY75zRs1BQiwzHMGKzDN9WWrVc//?=
 =?us-ascii?Q?efGioxOidaG7k7cGVjGaPkFJp9bQPOYi4pm0LA+CfAs03jTTPj6icV4xXqDL?=
 =?us-ascii?Q?3UK9e8PWmJB9BfNr+OUGMK+COxi0ukei1BsPLE4k632y2ZgXCUFhWLXlmPFW?=
 =?us-ascii?Q?aOCDUggWftiSj5oRuGH1UGujfetBNdv5RpFqm6MRptwJmbHo5AeEtFByQgKj?=
 =?us-ascii?Q?t7eo5meO8iouThF5nolKgPBMnYmvI/lUJk+IXV2weB6wwC78galBPkEHLYcz?=
 =?us-ascii?Q?v/A1NgeJduWbz8pB8QduG+pYP1CPtx9Ldd9HaDa8X5W9VEQzxruAWZHghoSJ?=
 =?us-ascii?Q?YesLAXXuEs5J8stvE7FvBnfu8dAp+rEwVdR2rG6EmRZKgGsiSylkP0cHzT7T?=
 =?us-ascii?Q?8SLlEEZNdIqp0VSpPPv1J3IdnSnXAaY18fx1oVOjDQXmNYVzk/pzFTBMpF2Z?=
 =?us-ascii?Q?vCBA2+cDH9JcE6d612J/TcR7yXf4gm12/lwrFogTH2MhUrP8XS52JtNfz0Kj?=
 =?us-ascii?Q?AHJ7prQEivyOGbGw+cf4HjL131hk5UPG/FwalTnWx9iBrtQBL3uXWAyHtm/b?=
 =?us-ascii?Q?YnA=3D?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(7416014)(376014)(366016)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?R6i2khowzCHSfqb+tBqqVLvGlAdu0wceJOwRFrytQGhyxPgtXmxWVs9r31Ob?=
 =?us-ascii?Q?Ht7EoLdvS/vY9d4+Ixeueikt2b8J6qXbvqjiC7K3riJbDOY1s7VGON8PvA2T?=
 =?us-ascii?Q?pINL97+kmsfvSziyB97/mVvR6zjozkAkm58JTfGlDX5g4otv9L5mzOqA5sbW?=
 =?us-ascii?Q?z5vFSiXQH/2ALuGDuJ6nhVbUF9ntO7N6kF+jd6dJSPBLqvyjoDy5qO3QmdmU?=
 =?us-ascii?Q?gLJq8PDonRRlLe/vUL09Iu4rrVeGsvvpw9DzP8PvGyPVbuL7oXMfMM8HYyev?=
 =?us-ascii?Q?mK7Cb3ecUp2O3Oh+Bx7sPpSvOSYyIer7no83izvi2B7/UvubZwuz2S+LHwZe?=
 =?us-ascii?Q?YgbCtLicVdtPpvsw2sk12RhSJe8ODRpyWNMCA86y3GCKmDHZqa0D9VEUJpiE?=
 =?us-ascii?Q?LsM1AjwhhxZ2OxmWGHvBvSjkIu1rBE9VW3u+WjZ3eGSkuA1EnZPjpYLKbFK5?=
 =?us-ascii?Q?oTghVxnXYB8DMrpjAdvsWkTt+fmoNoZJZXkP+DAm8HbSR4iF4WEm3sq456NG?=
 =?us-ascii?Q?o9lWt1J1a4DVxwA+27mG9x5MZvLnTKu4C6yXTbxxv6osvd5yx3KgIQigyVYq?=
 =?us-ascii?Q?v8Eiw2eWcHlUmTDk/5wPVstj9guCIEC2U0M9YWbHqe1am8hTihmE9oMHUXPN?=
 =?us-ascii?Q?94N851W6kNrFxXzi41myQopIasCZ4ooykzFQIih/xdZ8shPy204z8VQbNJQQ?=
 =?us-ascii?Q?XpHWgRY+7cPTHIvGJjX/5MWf2zGIRuSXd+Gug9tFO4OFz0Ez8Jx6SVarLsvl?=
 =?us-ascii?Q?9tvCbJhtO5cuYNaNPAhDqY8ZfaZ7grDiuzAZvyt4KQNDvH2ipZgYz8OPKgPn?=
 =?us-ascii?Q?3DKctgll147YeiLsw7GTNIY6e2C09dBGp0H/6HRv7WLeRfUGvN6xJ3CCuydy?=
 =?us-ascii?Q?cXI4uXN2zmeHtOOHEV5ZKV7uWEn+iS/IceGQf4Lm8mDi/9u9OZQq8aYXYolB?=
 =?us-ascii?Q?thr1c30Dl7V20Rfli68K76xn3sQGvMy3x+frF5maElRjcZINhxruRpG7xzTW?=
 =?us-ascii?Q?WkuwTdgTgmZTEu49o429h5EwZQJYPLAFYoICItZawocGbdzJxOe149WNUXAs?=
 =?us-ascii?Q?wumm5mq/1+quaazA2/BsYrMAEonkdL45SPsGLxzKjxgbRIDtr8SXJaECsGFf?=
 =?us-ascii?Q?bFCuscLE8d8WlA0mxYdxWRCn8eV9aqUllEtQrByILYKmXh984cnGQ2Nr16Yi?=
 =?us-ascii?Q?rpjutP3wdPA8zSCKYhr4Koxc2Dt18h8bGcemYQ4/apC8xGVrQZGz+rDjui3V?=
 =?us-ascii?Q?C5iyTDy03ApGlN/EIi4TRTC6hqihRFoXSxx3mVPNxvWOFeA8CSQ2oJEgJxU6?=
 =?us-ascii?Q?kZ3/dCjyh8Lxs6KYjtOyxTuzxA5gzUkEtC19QayY8gRe28rXT9x8nXYjXOw4?=
 =?us-ascii?Q?0kr2HZmRNmxEpFmETOP17kBlaXBmgifd1n+J1oGEYbkxU2cYvuKRDPDq38BP?=
 =?us-ascii?Q?iqm46lZzy3OvocwlgfmQ/q7Jc4R3jnlLvUkKYsZhG7QSDI/mRt4NYN5kv+rF?=
 =?us-ascii?Q?q1lMmSxeDUdwLrW5szjKXi9D9MK5Gk+Fu0pozYTx6XoFGaGskB81MmaqFw/C?=
 =?us-ascii?Q?T9FJ5ahXMUjerf6Tpxl/s0VEKP21vtK5ueeMv6NXOcqgPPaix6r7ZPifnJZE?=
 =?us-ascii?Q?TQ=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	0DLXAEGk6vW+JzF6GXJCbzKEJVG32ekdGh4nyCHA2TDh1mdd7I8Y3kFX5qT28DP4iMDI+zV0WxCplhtePzjKK4KKgnIjiGZln2i45j4yriaWojbmzXdjyFOjAD/W6rFv87uNNt9Drz51mk7jFj0qn7DDr9InOMK9QDGtZf+jyxe3UHPtBzDorEVAzeejpI9xh337Ht16D9y8CS4VjxrDML7GgC5baq4q5c0VEXC8dCCTtKsCjp+Y9cOoGpNqADjljyaRVNfEd2cISCp81C07xoX07Zr6c5HrZba+fMLnaMlwFc4Msw7Qu7D0I6UXoaacAh3VkaGEeHVJkgtfsuY9VeIE7btyCzN7EqsChA8g6fP/GO0SwIN6aKrtMs7QrS/EVuGTPiN3AuYLNvARPw+1WCpL1LFpW8YL2II883u1C82bw6GySe1HHhXOimf9bBI/rNsP3iqHPbsAvOpmwo9pwued6/RNg8K5ScQZh0yZFMEn24keG14X5fFlLaA8PDyoYAk2ofVwiEAsQv7agzdk1LDhNDvK0uKj7GenTOgkpHEbe98pRLg4seNrzXthFSOn692QUzMkbLA1KyejBG7UWkX285dncFfl+xwI1b3vd+w=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 6e92e92c-56cf-4de2-1032-08dceeec432f
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Oct 2024 20:42:48.8848
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: PGZoLiN38AfyZVTCXrOFoI+2nkjXh/CfnlG7LlNHXqM15YpqISWUw3lYCfYxdG0k18m/pm8fbKBr77mQ84OseJrbOhDxDBS89nG0rj27J4s=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DS7PR10MB5974
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-17_23,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 malwarescore=0 phishscore=0 mlxscore=0
 mlxlogscore=999 bulkscore=0 spamscore=0 suspectscore=0 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2409260000
 definitions=main-2410170139
X-Proofpoint-GUID: YMsQOtJjLOBjYwyIJcXcyy4ZWW7gcLEO
X-Proofpoint-ORIG-GUID: YMsQOtJjLOBjYwyIJcXcyy4ZWW7gcLEO

Add a new PTE marker that results in any access causing the accessing
process to segfault.

This is preferable to PTE_MARKER_POISONED, which results in the same
handling as hardware poisoned memory, and is thus undesirable for cases
where we simply wish to 'soft' poison a range.

This is in preparation for implementing the ability to specify guard pages
at the page table level, i.e. ranges that, when accessed, should cause
process termination.

Additionally, rename zap_drop_file_uffd_wp() to zap_drop_markers() - the
function checks the ZAP_FLAG_DROP_MARKER flag so naming it for this single
purpose was simply incorrect.

We then reuse the same logic to determine whether a zap should clear a
guard entry - this should only be performed on teardown and never on
MADV_DONTNEED or the like.

Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
---
 include/linux/mm_inline.h |  2 +-
 include/linux/swapops.h   | 26 ++++++++++++++++++++++++--
 mm/hugetlb.c              |  3 +++
 mm/memory.c               | 18 +++++++++++++++---
 4 files changed, 43 insertions(+), 6 deletions(-)

diff --git a/include/linux/mm_inline.h b/include/linux/mm_inline.h
index 6f801c7b36e2..0d97a14bf051 100644
--- a/include/linux/mm_inline.h
+++ b/include/linux/mm_inline.h
@@ -531,7 +531,7 @@ static inline pte_marker copy_pte_marker(
 {
 	pte_marker srcm = pte_marker_get(entry);
 	/* Always copy error entries. */
-	pte_marker dstm = srcm & PTE_MARKER_POISONED;
+	pte_marker dstm = srcm & (PTE_MARKER_POISONED | PTE_MARKER_GUARD);
 
 	/* Only copy PTE markers if UFFD register matches. */
 	if ((srcm & PTE_MARKER_UFFD_WP) && userfaultfd_wp(dst_vma))
diff --git a/include/linux/swapops.h b/include/linux/swapops.h
index cb468e418ea1..4d0606df0791 100644
--- a/include/linux/swapops.h
+++ b/include/linux/swapops.h
@@ -426,9 +426,15 @@ typedef unsigned long pte_marker;
  * "Poisoned" here is meant in the very general sense of "future accesses are
  * invalid", instead of referring very specifically to hardware memory errors.
  * This marker is meant to represent any of various different causes of this.
+ *
+ * Note that, when encountered by the faulting logic, PTEs with this marker will
+ * result in VM_FAULT_HWPOISON and thus regardless trigger hardware memory error
+ * logic.
  */
 #define  PTE_MARKER_POISONED			BIT(1)
-#define  PTE_MARKER_MASK			(BIT(2) - 1)
+/* Indicates that, on fault, this PTE will case a SIGSEGV signal to be sent. */
+#define  PTE_MARKER_GUARD			BIT(2)
+#define  PTE_MARKER_MASK			(BIT(3) - 1)
 
 static inline swp_entry_t make_pte_marker_entry(pte_marker marker)
 {
@@ -461,9 +467,25 @@ static inline swp_entry_t make_poisoned_swp_entry(void)
 }
 
 static inline int is_poisoned_swp_entry(swp_entry_t entry)
+{
+	/*
+	 * We treat guard pages as poisoned too as these have the same semantics
+	 * as poisoned ranges, only with different fault handling.
+	 */
+	return is_pte_marker_entry(entry) &&
+		(pte_marker_get(entry) &
+		 (PTE_MARKER_POISONED | PTE_MARKER_GUARD));
+}
+
+static inline swp_entry_t make_guard_swp_entry(void)
+{
+	return make_pte_marker_entry(PTE_MARKER_GUARD);
+}
+
+static inline int is_guard_swp_entry(swp_entry_t entry)
 {
 	return is_pte_marker_entry(entry) &&
-	    (pte_marker_get(entry) & PTE_MARKER_POISONED);
+		(pte_marker_get(entry) & PTE_MARKER_GUARD);
 }
 
 /*
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index 906294ac85dc..50e3f6ed73ac 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -6353,6 +6353,9 @@ vm_fault_t hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 				ret = VM_FAULT_HWPOISON_LARGE |
 				      VM_FAULT_SET_HINDEX(hstate_index(h));
 				goto out_mutex;
+			} else if (marker & PTE_MARKER_GUARD) {
+				ret = VM_FAULT_SIGSEGV;
+				goto out_mutex;
 			}
 		}
 
diff --git a/mm/memory.c b/mm/memory.c
index 0f614523b9f4..551455cd453f 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1455,7 +1455,7 @@ static inline bool should_zap_folio(struct zap_details *details,
 	return !folio_test_anon(folio);
 }
 
-static inline bool zap_drop_file_uffd_wp(struct zap_details *details)
+static inline bool zap_drop_markers(struct zap_details *details)
 {
 	if (!details)
 		return false;
@@ -1476,7 +1476,7 @@ zap_install_uffd_wp_if_needed(struct vm_area_struct *vma,
 	if (vma_is_anonymous(vma))
 		return;
 
-	if (zap_drop_file_uffd_wp(details))
+	if (zap_drop_markers(details))
 		return;
 
 	for (;;) {
@@ -1671,7 +1671,15 @@ static unsigned long zap_pte_range(struct mmu_gather *tlb,
 			 * drop the marker if explicitly requested.
 			 */
 			if (!vma_is_anonymous(vma) &&
-			    !zap_drop_file_uffd_wp(details))
+			    !zap_drop_markers(details))
+				continue;
+		} else if (is_guard_swp_entry(entry)) {
+			/*
+			 * Ordinary zapping should not remove guard PTE
+			 * markers. Only do so if we should remove PTE markers
+			 * in general.
+			 */
+			if (!zap_drop_markers(details))
 				continue;
 		} else if (is_hwpoison_entry(entry) ||
 			   is_poisoned_swp_entry(entry)) {
@@ -4003,6 +4011,10 @@ static vm_fault_t handle_pte_marker(struct vm_fault *vmf)
 	if (marker & PTE_MARKER_POISONED)
 		return VM_FAULT_HWPOISON;
 
+	/* Hitting a guard page is always a fatal condition. */
+	if (marker & PTE_MARKER_GUARD)
+		return VM_FAULT_SIGSEGV;
+
 	if (pte_marker_entry_uffd_wp(entry))
 		return pte_marker_handle_uffd_wp(vmf);
 
-- 
2.46.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0b-00069f02.pphosted.com (mx0b-00069f02.pphosted.com [205.220.177.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 0037F229112;
	Thu, 17 Oct 2024 20:43:25 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.177.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729197813; cv=fail; b=acPq+baPX8T5QM1VZ8pp1rTcTgpqLXyUe9gZnYNebtpal/nLFot2Z1rwyoy6uY25geov2laTp5PoJjTOj54P8CvkhHvBGF+wkIrVwXJgQrAifahPwbsgNAZL02vEIy/KaDlc4UQOlDaekGqCzDFDzuQeLERv02qWstkQSdU+M3s=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729197813; c=relaxed/simple;
	bh=Oy7/o8wglmfF+9x1fu9vxrSv41Vr5NIQB/kW7G1fAU4=;
	h=From:To:Cc:Subject:Date:Message-ID:In-Reply-To:References:
	 Content-Type:MIME-Version; b=igko6vZ2r/uf60drocZeC1MJ65c9nl65sMieChFuW2KtgxYmQtiAoMLMRWcgSj2zPBcjkoGoRbRctAOGB0bU+dyXMl08IzhD9/3ERbLauMR2TmSKOoPLCp0Jo1pCLpPd6C0PNOZYBq+ee/Opuq24E6e9eXwdAlfArYqilhOEcRk=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=AI0E0RHH; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=Yem/bXVV; arc=fail smtp.client-ip=205.220.177.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="AI0E0RHH";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="Yem/bXVV"
Received: from pps.filterd (m0246631.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49HFBn6O002180;
	Thu, 17 Oct 2024 20:42:58 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-transfer-encoding:content-type:date:from:in-reply-to
	:message-id:mime-version:references:subject:to; s=
	corp-2023-11-20; bh=aC0TTOTg08sqzeqXSpodjeivk2FlCOxNysvsPwgWW5A=; b=
	AI0E0RHHUqviPaOoe9JpGs1GtBwzSs1RpBa5Qw/EbYMR5LvctZZbUalg1E4WNNk7
	qFP7pYEak343VXgW7VT2VpdtAxdZrPnl4WBEgivxDKXgh5KVgLfHlkzVViwQEGKR
	iOSmAbl2KwIXppv0XYoJyORyXVqrHNPl0CCeucnNDS3UF2YpVP/M1tMoSmRYw3tD
	0COK9aqrTaJiWHRTyhm1zy7q6Ijvk6reD04dCgo/XmvltMLkYaBtakJzxkw5Wlik
	Wf2loMu+MSlFgIOkaCgO+htexLIA3A1SYlIDbz4tSMX5QfD/u/SqjjHqsVIjqizJ
	q1Jn86l02rel5OSH724u2A==
Received: from phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (phxpaimrmta03.appoci.oracle.com [138.1.37.129])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427fw2qh6r-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:42:57 +0000 (GMT)
Received: from pps.filterd (phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com [127.0.0.1])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49HJD1MX013983;
	Thu, 17 Oct 2024 20:42:57 GMT
Received: from nam10-mw2-obe.outbound.protection.outlook.com (mail-mw2nam10lp2049.outbound.protection.outlook.com [104.47.55.49])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (PPS) with ESMTPS id 427fjares3-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:42:56 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=Hyi1Rv7n741QVgpMaZEjp0ZLq2ppQwStWINMIt6aSToQyBepKpeOfX/aGfUH3QxvleEdTxqAkoqfRiv5ygWo2mteeJMZN6Fvst6/VZd2KwcFwf7WoDZmdjuLX2CAjCIp38Q7G+4yLtxEqlUQf5n6i5l3aPk0kqG+rAtmiTLoorZ8bqg6NHCJu3p9nDWX+yOl7AQNkvObLvDdcZ+jHubXL9zK0lREye8+ASLooHWJzY5duGRq3rUl/mLPIWblss5SRVH9zOibDrvcc1SfQ4UK/0UjozhP5OmaI6cZlCbYZ35IU5VrQVJ0qSg5JPaoEGCkvBSuYOW3FQy+1Mp8BrsR2w==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=aC0TTOTg08sqzeqXSpodjeivk2FlCOxNysvsPwgWW5A=;
 b=I4fDKW8X/GJsQz/qwD+VogYTjVwRHRJZOyha8PRUI8qZPK/JlOFnbsdcf0C99VeUR+CtZaxffu4QfhtKE/GAeazJZjeaMdAKbbUh+cC3k1knQwtvWMKfdSezvIjpcl7Ra/yajM353VemxBB4ZOwv0iXFKkZX3DrqecrpX3+j4eYkYEKY04ne0zywGc9RV2Oj5st0/7tnNAv2vgu39k6L2q9F5r02AlnS3TP1h0+4CZo45+P7+3+jTXAWP6jw8eB6dKUrwwKMQ4aF8mWverWc5WBbA8oOWce/GUTD4Ufa32n8hbx3iSmwZ+7rIoIegOut2UT77+5E727GgeCm+RBXIw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=aC0TTOTg08sqzeqXSpodjeivk2FlCOxNysvsPwgWW5A=;
 b=Yem/bXVVd00EPHcTQu9i8zSqRpKKZ8ROXFw1oIO2tsPgP+UhvgV/VqCpgMXVQe+OSv+ucJoNfGk3nBxgPThQbW49ebyIHLeYhl663EcovcJIAv37iTzY0OdPhbQNC5Bu6jUoiNEtnlWypeJgwLW6XrCrukk4iK4SJFD03fJ6E7U=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by DS7PR10MB5974.namprd10.prod.outlook.com (2603:10b6:8:9e::10) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.18; Thu, 17 Oct
 2024 20:42:52 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Thu, 17 Oct 2024
 20:42:51 +0000
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Andrew Morton <akpm@linux-foundation.org>
Cc: Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@HansenPartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: [PATCH 3/4] mm: madvise: implement lightweight guard page mechanism
Date: Thu, 17 Oct 2024 21:42:37 +0100
Message-ID: <b7c9790037296c1a562d6686c9fbfa30d9d08241.1729196871.git.lorenzo.stoakes@oracle.com>
X-Mailer: git-send-email 2.46.2
In-Reply-To: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: LO6P123CA0059.GBRP123.PROD.OUTLOOK.COM
 (2603:10a6:600:310::17) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|DS7PR10MB5974:EE_
X-MS-Office365-Filtering-Correlation-Id: 63058d18-695a-414b-4903-08dceeec44ee
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|7416014|376014|366016|1800799024;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?gkqvje2KSh2LWletVpNujG+eklovnmEYZiGu5yKlZDywNbf70+cV28kKuF5r?=
 =?us-ascii?Q?COocnYJYWZiZzSL9qS69AWOMTT4slgzKxu5HW84tBEpyvrpU4vLyC7q7SN25?=
 =?us-ascii?Q?Agb7LVyTORphcJRC8K7ti6Z6zdbTTsv1+DKLTIP2QWbfHqmBOlV/PhmKMR+W?=
 =?us-ascii?Q?KwRND9H9q5xXSSD6V/sPMyIjfIKk3C7EoUECVXhmK7NA/mLLPyw06AgydADh?=
 =?us-ascii?Q?XKrDz1KZPZPbSk4+lXqnxNouD7dR2JrhB3YomWxSohBJaWUTuCJjNiDRWRUs?=
 =?us-ascii?Q?bn9a9ZTbWDvgX9jyC/XffhNAIDN6pI/VUHKMh4G32ql/CDG4huY4KL3sL1Ds?=
 =?us-ascii?Q?El3mluIk3/csjeswQze59GMqwGpAlRWbsxPwy2YoMY507sYK6R/D+8crkAOs?=
 =?us-ascii?Q?8G3PQ9tv827Ipn+FdUQrnJDwgLGQWCaMl+0Aa8BYka7EoyHfRp7LBI5Luzwz?=
 =?us-ascii?Q?PyuNHqctZKnxGVTULpjtqWj3vHF9gstnfQpKfZTC09azM3l74EFJMfPT7OFg?=
 =?us-ascii?Q?jUE+pNCicRwq1f6YOz4kuAqedP9fbNeK4oCG1G2nJtwPv7/fFEcNONjSXB5Z?=
 =?us-ascii?Q?YvkNA0aYnfeNWPHJtNiWagTAZf4ALwYq4kvxhF7MJ5o5jKyZgAcvAKXCl7AR?=
 =?us-ascii?Q?6jyl/UEBdPtte33IYeRwBr0HLaOr+KVJEcUpS6qncmphqm5O3eoU8mAgo0/n?=
 =?us-ascii?Q?F5mGjo+MIBR1NpeOurhPeOkU1Z9YfY3v9UUl2Vn1gi2SBUNOUamFNB077idv?=
 =?us-ascii?Q?SUcZQfIPThHS0wbFAqpQUysp5rgTEKL0tWd9LSOE6Vmccd1YS6egdpOGyYyp?=
 =?us-ascii?Q?mMeEPrkOS4Uvv9mfhpcbJ/VQ5FtHnVh9AMrTkD/wylItFnQxyI2sYOIs2kfL?=
 =?us-ascii?Q?Rlcc1q3f5c8u5OKbOJ/UnJDG5rGmzskpAywvm6/zk5DW1XXG7OGxxNwYnxZS?=
 =?us-ascii?Q?DZf/TGgPov2CCN3efA1VEVgJpgY3swspWRHe0ZSrTcqohous/CsSB7NBhvJo?=
 =?us-ascii?Q?6T76kFji9KwsQGhdt5eP7K/LI/b9ii19QemIdzGTjcYq0n6sPFdXfPZt0yVg?=
 =?us-ascii?Q?H9Cu2B5IxNLZlo12675+grJTdMrH+ouyZqRtjm3ac+GAwkF8sPl4OYHuJUz6?=
 =?us-ascii?Q?dPYXAuM0JGOtHayqETdNwzxXKEWeerbLwr/boc2P7w06V/dbC0rk/emMjQNq?=
 =?us-ascii?Q?ouJNFTgdT1w1XdhO5FImZ2wy2vB7UPoeyPcgyKlBTkYNskgH4U2+wVdns91A?=
 =?us-ascii?Q?7OJbuqNXj/cq3xelQESG5DFekDfLVDHEPPnZY+KygBkGuvKcLuG0qGmYy5bE?=
 =?us-ascii?Q?A8u6qgmPra2NBFZ0nxr4QvXw?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(7416014)(376014)(366016)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?cTSVOH0IuCLIutZbQqBfRrRhxxXXeyMm4Sf3uPbtfqJeNA95ZFahnp45UQ61?=
 =?us-ascii?Q?ebI7pKtfrDPse1fK9p/EIMH0SAP7reosRb1nU7Jp9d+2J71Q9VqF8xAFRbEk?=
 =?us-ascii?Q?kuYaQP1/ALaGrU7DCnvFOFSbnKsI3aLvaNIRWhhOgZNoK2vkRcdbrrCXps41?=
 =?us-ascii?Q?iihE1QVJjnCG0o27/LkikGpXODczwd7FAbhGCpC8VCQwBELhRrArcUbjOlx1?=
 =?us-ascii?Q?rEYuy4eJDGfxIUHyFebO82tlWwpkMiuRJVFHeyLiEppy+jEhdooQEJe7DpzJ?=
 =?us-ascii?Q?p2OzUwnN+3q8kKJnZ7rLxZEgZ3oGrF2K2WZn6svf5FylugHqxLPKfAZ1ToCq?=
 =?us-ascii?Q?Fi2BFRRPTY3hNgglWspoEcbUoFr7Fbi8Agf/13mbXSnLB185vuKK7MrCAjyD?=
 =?us-ascii?Q?YjuMyhyFmDVGfe+0jldnDtOB0nNzB6QLaekTKzJTTYpJlp7KLaUoODyhi7xW?=
 =?us-ascii?Q?eeYomYIdAuHr40L5er/ZfukNmSQbYH5WKxaSdMDphKU3Mq+x5IX/bpRYQHBn?=
 =?us-ascii?Q?2egGLGG2oVZnhITZsgCXfWaewPG4pToYJONhrJQT7pGnNUvPw7kcvHWXPXko?=
 =?us-ascii?Q?/gkbIvuXQHFcVZI5NMtTD1dT5ntNAjuzCXDuqJVZXjXzKkSiiPKvRizfgYZP?=
 =?us-ascii?Q?198mcIOkdKxi0bo/ODeRAjKoxDXl5IixO6Pprp/9Yd4cOb6ICInM1LXrruJ3?=
 =?us-ascii?Q?3VSaVQ7WKI63owT4cLWaMPgfE9190iuwmY2c/rWV8Cvn+YyyMa2CPz6V5pD7?=
 =?us-ascii?Q?g0PxcW51iVzXo3tKk5SofO1GHV48OKqtPLmG8EzzyeNIIuxqwXrOMNyEPPXp?=
 =?us-ascii?Q?cZfhuNSRN73ovQrmaDtvyEb6A7PBto+vUD8dcU8+uyQyOR6rNpRYuh+pvtC5?=
 =?us-ascii?Q?vfwIdNu2PbNUsQjYJeB+Vx+O9PjLWsb4tEVaAHX910GOShIkmAlx6/V3JyWC?=
 =?us-ascii?Q?e082OxjMETr9/SPUatuCNQOqQQgWpteTPJWnKcSaQVWJs4vpc1wg2DtCqX/S?=
 =?us-ascii?Q?kLDF715KRCLQ+1bBTQIDHyOmXejB6VRXpwPkd+WY3BY8LNDPsRsm79FkkKOL?=
 =?us-ascii?Q?Cwdeomyiom8jiR5v4z0zhw9N9qo62149vfYQHM2AOcT9JWOuvDdhlWhMdn2L?=
 =?us-ascii?Q?iY0YfDLSQS6XBMYMI6GvB61wSaZiu8EC27CP25jEOSUw3y7Gkk+bGxwSXKND?=
 =?us-ascii?Q?wyBQ/ObG3PnIKUBKL1LysvU55l1oCh49CMnHr79zyK2SlpMEYpo1S0LAS5Sy?=
 =?us-ascii?Q?DVoYoA0+qFZaBe8KABPx8w6l+O9QQ7662JwDmZZqlEDgF1uhqRoIygn5spAB?=
 =?us-ascii?Q?+7JPw/+X8GH0RJIqqs3sdfCX4Nggd7fRp2LQe4RF0OrcmTNiFs5c/Rlb2iWr?=
 =?us-ascii?Q?F/SWrwRTs9POArshk9q5NdgXVNwsnJ07TsuS6nRstKs0kG5zEMfoZXZzymCB?=
 =?us-ascii?Q?JXXBJ5U8qm2ADonj4P3nb9BKAofvrftj6btGmayQ4BDmNStrVt6ss8KZw1qv?=
 =?us-ascii?Q?Ynta6P7JIL2OcUwSdcm0tXzEgeTvHm3MQyHL9tdvUk9MP7Q9orUeNgAsZ+0V?=
 =?us-ascii?Q?sBtIlPQeeT1f0JMs0WQLeNk7DbuzzEp1H9uGqy4N7AcMHynppYZq7OkXDzrz?=
 =?us-ascii?Q?Iw=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	uBpO6uM/PBH9/iEHY6tB83dbgwHV0r6+QrccPURvydGJQckWUyOe5xnHhUNqe+LO/5yEAyTiaMbXa8hwdFInOSYfq46h84fuW/ytLc9ms7LPgUlv9D73psC/3imogt0GiZ7s2PM1l9C5EOP+mxmARDuY8yEF3t5wUfxI09ci9vPGvD0oDfWW52dc2w2B4d3lRyv7p1DmPCM+YWkvWppMZblJDaQbOEAQ1L8IlH4h3H4BIDxiFi9jqMD6IHxPxlp7DMjSP4TGEmDJuPzyQSwkx9Iot0GjWO2lvKACfWhWBrz6P+uAM1ThVAoh7pqZwwPagDybEyr0FB0EGkhqozkREDoauLNmtn4scD5/S2/ztTnWVVafVGlTQhtP8Geo0WMP43bN1pqReWjA1OhPS4Lmr5WcnHp8zXcnb9uy1q4wdWCp4yRy49Lzd/z+HkSgbtnvFByoB++1Ms/CgoV2TlVBBWcLk2AP0g1DXTrHKnFyDcTC0XkRTW6o+v6Yzox6vBxOxKDMQYrryHAmpJk3UUzR4pJGiUwt7deBLpLfeHEffitMAFX3RKJA5gj0iKH8mOpRFhKZCAbUHiFoP8N24wbhYJYLhBD46jhbZnl3Nr3d5g8=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 63058d18-695a-414b-4903-08dceeec44ee
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Oct 2024 20:42:51.8594
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: ROjkHTqRQ+o6oGFA2/TnQABLv1NEJaF6X4Sq35P61sCemeU2bmV5gsPRbIgrN26SMukoeeV+PsGgh352ZMrwFuOK19SCOWIb4znby0mmEgw=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DS7PR10MB5974
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-17_23,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 malwarescore=0 phishscore=0 mlxscore=0
 mlxlogscore=947 bulkscore=0 spamscore=0 suspectscore=0 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2409260000
 definitions=main-2410170139
X-Proofpoint-GUID: ZykuiTcn5RW2iX6RsIbwktgQtKIiNe7R
X-Proofpoint-ORIG-GUID: ZykuiTcn5RW2iX6RsIbwktgQtKIiNe7R

Implement a new lightweight guard page feature, that is regions of userland
virtual memory that, when accessed, cause a fatal signal to arise.

Currently users must establish PROT_NONE ranges to achieve this.

However this is very costly memory-wise - we need a VMA for each and every
one of these regions AND they become unmergeable with surrounding VMAs.

In addition repeated mmap() calls require repeated kernel context switches
and contention of the mmap lock to install these ranges, potentially also
having to unmap memory if installed over existing ranges.

The lightweight guard approach eliminates the VMA cost altogether - rather
than establishing a PROT_NONE VMA, it operates at the level of page table
entries - poisoning PTEs such that accesses to them cause a fault followed
by a SIGSGEV signal being raised.

This is achieved through the PTE marker mechanism, which a previous commit
in this series extended to permit this to be done, installed via the
generic page walking logic, also extended by a prior commit for this
purpose.

These poison ranges are established with MADV_GUARD_POISON, and if the
range in which they are installed contain any existing mappings, they will
be zapped, i.e. free the range and unmap memory (thus mimicking the
behaviour of MADV_DONTNEED in this respect).

Any existing poison entries will be left untouched. There is no nesting of
poisoned pages.

Poisoned ranges are NOT cleared by MADV_DONTNEED, as this would be rather
unexpected behaviour, but are cleared on process teardown or unmapping of
memory ranges.

Ranges can have the poison property removed by MADV_GUARD_UNPOISON -
'remedying' the poisoning. The ranges over which this is applied, should
they contain non-poison entries, will be untouched, only poison entries
will be cleared.

We permit this operation on anonymous memory only, and only VMAs which are
non-special, non-huge and not mlock()'d (if we permitted this we'd have to
drop locked pages which would be rather counterintuitive).

Suggested-by: Vlastimil Babka <vbabka@suze.cz>
Suggested-by: Jann Horn <jannh@google.com>
Suggested-by: David Hildenbrand <david@redhat.com>
Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
---
 arch/alpha/include/uapi/asm/mman.h     |   3 +
 arch/mips/include/uapi/asm/mman.h      |   3 +
 arch/parisc/include/uapi/asm/mman.h    |   3 +
 arch/xtensa/include/uapi/asm/mman.h    |   3 +
 include/uapi/asm-generic/mman-common.h |   3 +
 mm/madvise.c                           | 168 +++++++++++++++++++++++++
 mm/mprotect.c                          |   3 +-
 mm/mseal.c                             |   1 +
 8 files changed, 186 insertions(+), 1 deletion(-)

diff --git a/arch/alpha/include/uapi/asm/mman.h b/arch/alpha/include/uapi/asm/mman.h
index 763929e814e9..71e13f27742d 100644
--- a/arch/alpha/include/uapi/asm/mman.h
+++ b/arch/alpha/include/uapi/asm/mman.h
@@ -78,6 +78,9 @@
 
 #define MADV_COLLAPSE	25		/* Synchronous hugepage collapse */
 
+#define MADV_GUARD_POISON 102		/* fatal signal on access to range */
+#define MADV_GUARD_UNPOISON 103		/* revoke guard poisoning */
+
 /* compatibility flags */
 #define MAP_FILE	0
 
diff --git a/arch/mips/include/uapi/asm/mman.h b/arch/mips/include/uapi/asm/mman.h
index 9c48d9a21aa0..1a2222322f77 100644
--- a/arch/mips/include/uapi/asm/mman.h
+++ b/arch/mips/include/uapi/asm/mman.h
@@ -105,6 +105,9 @@
 
 #define MADV_COLLAPSE	25		/* Synchronous hugepage collapse */
 
+#define MADV_GUARD_POISON 102		/* fatal signal on access to range */
+#define MADV_GUARD_UNPOISON 103		/* revoke guard poisoning */
+
 /* compatibility flags */
 #define MAP_FILE	0
 
diff --git a/arch/parisc/include/uapi/asm/mman.h b/arch/parisc/include/uapi/asm/mman.h
index 68c44f99bc93..380905522397 100644
--- a/arch/parisc/include/uapi/asm/mman.h
+++ b/arch/parisc/include/uapi/asm/mman.h
@@ -75,6 +75,9 @@
 #define MADV_HWPOISON     100		/* poison a page for testing */
 #define MADV_SOFT_OFFLINE 101		/* soft offline page for testing */
 
+#define MADV_GUARD_POISON 102		/* fatal signal on access to range */
+#define MADV_GUARD_UNPOISON 103		/* revoke guard poisoning */
+
 /* compatibility flags */
 #define MAP_FILE	0
 
diff --git a/arch/xtensa/include/uapi/asm/mman.h b/arch/xtensa/include/uapi/asm/mman.h
index 1ff0c858544f..e8d5affceb28 100644
--- a/arch/xtensa/include/uapi/asm/mman.h
+++ b/arch/xtensa/include/uapi/asm/mman.h
@@ -113,6 +113,9 @@
 
 #define MADV_COLLAPSE	25		/* Synchronous hugepage collapse */
 
+#define MADV_GUARD_POISON 102		/* fatal signal on access to range */
+#define MADV_GUARD_UNPOISON 103		/* revoke guard poisoning */
+
 /* compatibility flags */
 #define MAP_FILE	0
 
diff --git a/include/uapi/asm-generic/mman-common.h b/include/uapi/asm-generic/mman-common.h
index 6ce1f1ceb432..5dfd3d442de4 100644
--- a/include/uapi/asm-generic/mman-common.h
+++ b/include/uapi/asm-generic/mman-common.h
@@ -79,6 +79,9 @@
 
 #define MADV_COLLAPSE	25		/* Synchronous hugepage collapse */
 
+#define MADV_GUARD_POISON 102		/* fatal signal on access to range */
+#define MADV_GUARD_UNPOISON 103		/* revoke guard poisoning */
+
 /* compatibility flags */
 #define MAP_FILE	0
 
diff --git a/mm/madvise.c b/mm/madvise.c
index e871a72a6c32..7b9a357b84d2 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -60,6 +60,8 @@ static int madvise_need_mmap_write(int behavior)
 	case MADV_POPULATE_READ:
 	case MADV_POPULATE_WRITE:
 	case MADV_COLLAPSE:
+	case MADV_GUARD_POISON:
+	case MADV_GUARD_UNPOISON:
 		return 0;
 	default:
 		/* be safe, default to 1. list exceptions explicitly */
@@ -1017,6 +1019,166 @@ static long madvise_remove(struct vm_area_struct *vma,
 	return error;
 }
 
+static bool is_valid_guard_vma(struct vm_area_struct *vma, bool allow_locked)
+{
+	vm_flags_t disallowed = VM_SPECIAL | VM_HUGETLB;
+
+	/*
+	 * A user could lock after poisoning but that's fine, as they'd not be
+	 * able to fault in. The issue arises when we try to zap existing locked
+	 * VMAs. We don't want to do that.
+	 */
+	if (!allow_locked)
+		disallowed |= VM_LOCKED;
+
+	if (!vma_is_anonymous(vma))
+		return false;
+
+	if ((vma->vm_flags & (VM_MAYWRITE | disallowed)) != VM_MAYWRITE)
+		return false;
+
+	return true;
+}
+
+static bool is_guard_pte_marker(pte_t ptent)
+{
+	return is_pte_marker(ptent) &&
+		is_guard_swp_entry(pte_to_swp_entry(ptent));
+}
+
+static int guard_poison_pud_entry(pud_t *pud, unsigned long addr, unsigned long next,
+				  struct mm_walk *walk)
+{
+	pud_t pudval = pudp_get(pud);
+
+	/* Do not split a huge pud - we do nothing with these so just ignore. */
+	if (pud_trans_huge(pudval) || pud_devmap(pudval))
+		walk->action = ACTION_CONTINUE;
+
+	return 0;
+}
+
+static int guard_poison_pmd_entry(pmd_t *pmd, unsigned long addr, unsigned long next,
+				  struct mm_walk *walk)
+{
+	pmd_t pmdval = pmdp_get(pmd);
+
+	/* Do not split a huge pmd - we do nothing with these so just ignore. */
+	if (pmd_trans_huge(pmdval) || pmd_devmap(pmdval))
+		walk->action = ACTION_CONTINUE;
+
+	return 0;
+}
+
+static int guard_poison_pte_entry(pte_t *pte, unsigned long addr,
+				  unsigned long next, struct mm_walk *walk)
+{
+	pte_t pteval = ptep_get(pte);
+
+	/*
+	 * If not a guard marker, simply abort the operation. We return a value
+	 * > 0 indicating a non-error abort.
+	 */
+	return !is_guard_pte_marker(pteval);
+}
+
+static int guard_poison_install_pte(unsigned long addr, unsigned long next,
+				    pte_t *ptep, struct mm_walk *walk)
+{
+	/* Simply install a PTE marker, this causes segfault on access. */
+	*ptep = make_pte_marker(PTE_MARKER_GUARD);
+
+	return 0;
+}
+
+static const struct mm_walk_ops guard_poison_walk_ops = {
+	.pud_entry		= guard_poison_pud_entry,
+	.pmd_entry		= guard_poison_pmd_entry,
+	.pte_entry		= guard_poison_pte_entry,
+	.install_pte		= guard_poison_install_pte,
+	.walk_lock		= PGWALK_RDLOCK,
+};
+
+static long madvise_guard_poison(struct vm_area_struct *vma,
+				 struct vm_area_struct **prev,
+				 unsigned long start, unsigned long end)
+{
+	long err;
+
+	*prev = vma;
+	if (!is_valid_guard_vma(vma, /* allow_locked = */false))
+		return -EINVAL;
+
+	/*
+	 * If we install poison markers, then the range is no longer
+	 * empty from a page table perspective and therefore it's
+	 * appropriate to have an anon_vma.
+	 *
+	 * This ensures that on fork, we copy page tables correctly.
+	 */
+	err = anon_vma_prepare(vma);
+	if (err)
+		return err;
+
+	/*
+	 * Optimistically try to install the guard poison pages first. If any
+	 * non-guard pages are encountered, give up and zap the range before
+	 * trying again.
+	 */
+	while (true) {
+		/* Returns < 0 on error, == 0 if success, > 0 if zap needed. */
+		err = walk_page_range_mm(vma->vm_mm, start, end,
+					 &guard_poison_walk_ops, NULL);
+		if (err <= 0)
+			return err;
+
+		/*
+		 * OK some of the range have non-guard pages mapped, zap
+		 * them. This leaves existing guard pages in place.
+		 */
+		zap_page_range_single(vma, start, end - start, NULL);
+
+		if (fatal_signal_pending(current))
+			return -EINTR;
+		cond_resched();
+	}
+}
+
+static int guard_unpoison_pte_entry(pte_t *pte, unsigned long addr,
+				    unsigned long next, struct mm_walk *walk)
+{
+	pte_t ptent = ptep_get(pte);
+
+	if (is_guard_pte_marker(ptent)) {
+		/* Simply clear the PTE marker. */
+		pte_clear_not_present_full(walk->mm, addr, pte, false);
+		update_mmu_cache(walk->vma, addr, pte);
+	}
+
+	return 0;
+}
+
+static const struct mm_walk_ops guard_unpoison_walk_ops = {
+	.pte_entry		= guard_unpoison_pte_entry,
+	.walk_lock		= PGWALK_RDLOCK,
+};
+
+static long madvise_guard_unpoison(struct vm_area_struct *vma,
+				   struct vm_area_struct **prev,
+				   unsigned long start, unsigned long end)
+{
+	*prev = vma;
+	/*
+	 * We're ok with unpoisoning mlock()'d ranges, as this is a
+	 * non-destructive action.
+	 */
+	if (!is_valid_guard_vma(vma, /* allow_locked = */true))
+		return -EINVAL;
+
+	return walk_page_range(vma->vm_mm, start, end,
+			       &guard_unpoison_walk_ops, NULL);
+}
+
 /*
  * Apply an madvise behavior to a region of a vma.  madvise_update_vma
  * will handle splitting a vm area into separate areas, each area with its own
@@ -1098,6 +1260,10 @@ static int madvise_vma_behavior(struct vm_area_struct *vma,
 		break;
 	case MADV_COLLAPSE:
 		return madvise_collapse(vma, prev, start, end);
+	case MADV_GUARD_POISON:
+		return madvise_guard_poison(vma, prev, start, end);
+	case MADV_GUARD_UNPOISON:
+		return madvise_guard_unpoison(vma, prev, start, end);
 	}
 
 	anon_name = anon_vma_name(vma);
@@ -1197,6 +1363,8 @@ madvise_behavior_valid(int behavior)
 	case MADV_DODUMP:
 	case MADV_WIPEONFORK:
 	case MADV_KEEPONFORK:
+	case MADV_GUARD_POISON:
+	case MADV_GUARD_UNPOISON:
 #ifdef CONFIG_MEMORY_FAILURE
 	case MADV_SOFT_OFFLINE:
 	case MADV_HWPOISON:
diff --git a/mm/mprotect.c b/mm/mprotect.c
index 0c5d6d06107d..d0e3ebfadef8 100644
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@ -236,7 +236,8 @@ static long change_pte_range(struct mmu_gather *tlb,
 			} else if (is_pte_marker_entry(entry)) {
 				/*
 				 * Ignore error swap entries unconditionally,
-				 * because any access should sigbus anyway.
+				 * because any access should sigbus/sigsegv
+				 * anyway.
 				 */
 				if (is_poisoned_swp_entry(entry))
 					continue;
diff --git a/mm/mseal.c b/mm/mseal.c
index ece977bd21e1..21bf5534bcf5 100644
--- a/mm/mseal.c
+++ b/mm/mseal.c
@@ -30,6 +30,7 @@ static bool is_madv_discard(int behavior)
 	case MADV_REMOVE:
 	case MADV_DONTFORK:
 	case MADV_WIPEONFORK:
+	case MADV_GUARD_POISON:
 		return true;
 	}
 
-- 
2.46.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0b-00069f02.pphosted.com (mx0b-00069f02.pphosted.com [205.220.177.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id CA196229118;
	Thu, 17 Oct 2024 20:43:29 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.177.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729197812; cv=fail; b=Ngnk8j4HvufyaY5Lc9Mo2o5KCDXEW6fMC+zm/ILG5qXvEj90v+6OE+QDzqjKerokmaGSDNCQSL9fT/oobL4wuaP+CeJwjesSHnk/8rNeICOouXcyA3199e1Fgox557Zj1kFvv4kaDHoxzi2klJFqZ0sStcOvwDJMpKVQo49bhuU=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729197812; c=relaxed/simple;
	bh=i2BWEZvg5N6ekd6YZfDt4VKQbhuivxhjme7fb8k90S0=;
	h=From:To:Cc:Subject:Date:Message-ID:In-Reply-To:References:
	 Content-Type:MIME-Version; b=VKO/wxuAavm6+CS1m3tPqAL9W3HPuC1vEk+IDl6pw/5eFBOOMFqBSvpMo8CWOSqY9u5e9pogRgf0xl7loVbI3nvCRgXxa7xRhUop2DMAPflIirxkpnRJobyOLLMH56Sam8s26qDjnn9WShCi+ZO6i0M/v66dvBRiSjx5nyPc2lE=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=OAp/1SyS; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=iRSr+/+j; arc=fail smtp.client-ip=205.220.177.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="OAp/1SyS";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="iRSr+/+j"
Received: from pps.filterd (m0246630.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49HFBvsg024511;
	Thu, 17 Oct 2024 20:43:02 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-transfer-encoding:content-type:date:from:in-reply-to
	:message-id:mime-version:references:subject:to; s=
	corp-2023-11-20; bh=mjxjOr5wbvhvGFQe1h5NBiR5xNC7dPyxjLQzSwUhIwM=; b=
	OAp/1SySMGppl18V/KhFgU2tOSo3vG/Sy80u2kK5aWj6JYi6ePtpuNbE8XIi0d9K
	JS4L037IWJ3PfmLcMyJvdFZSJDk0COugmTu9QxDTlnPVr8ehFQPeZTLIZBCZNIac
	iPm0wG1UFKO7se2yj4vl6xXH+/euuBmUC6IRgjUqQxF8k/bHrFpGDH5khUB6lDWA
	RhAINtscNMxmvGqPwr5OmVBoQR4cRXaJ4K7bkuSBxy9qFEhna0osOiIabBIZFxug
	fSD8uf/vPdJcTilLXUwUE3Ha1SVetW+qDwBfDKick32G9eN2L0+POoi3bYKm5z3L
	JImrUwlhvnxjoDPbhIqLPQ==
Received: from iadpaimrmta03.imrmtpd1.prodappiadaev1.oraclevcn.com (iadpaimrmta03.appoci.oracle.com [130.35.103.27])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427fhcpyra-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:43:01 +0000 (GMT)
Received: from pps.filterd (iadpaimrmta03.imrmtpd1.prodappiadaev1.oraclevcn.com [127.0.0.1])
	by iadpaimrmta03.imrmtpd1.prodappiadaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49HJMt9V010406;
	Thu, 17 Oct 2024 20:43:01 GMT
Received: from nam10-mw2-obe.outbound.protection.outlook.com (mail-mw2nam10lp2043.outbound.protection.outlook.com [104.47.55.43])
	by iadpaimrmta03.imrmtpd1.prodappiadaev1.oraclevcn.com (PPS) with ESMTPS id 427fjh3tdj-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Thu, 17 Oct 2024 20:43:00 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=Uy+INrThlIIDsngA/8TMuSKYW13u9bphqdMPddFOvrOiZOKPTVrNtlarMhXfo8RlAcNtvj02YBTMw2kvEKbht8DN+A97L5i8oXAcxwgNXkwO1NvV/CHOdYn9QCb5czlOEZIX4gYZclvnFFqk9rlTNVFPVQKfTL9EOQOAma2a8lCYmdj0PtBQU7+2wOxo4vuZS8J26lKQwnbjqEdhvbezKzSDZT/vl0yEFX6f9OfRRYodMzLHZXI8/jOyvzYNx2VTomFneL6oH2dmLrpdVhrWFDA3/1KSv+FQVwPXnSqlncwKmAcBnw1RR7s58naxB6xroyUYgdh7OZeARhAy77G9ew==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=mjxjOr5wbvhvGFQe1h5NBiR5xNC7dPyxjLQzSwUhIwM=;
 b=JODkMTEJQ++0A/yyBIW0WuTvt9hnfrEqsjuOMcsOyL3cQ7EiPIlJYZoIGtKex2ZbqiJ6ZSmg+wUdqhb8np28fZWGt7T1hswc+X52bj59M47Drg9xCctfIl+fItDkcnsBklgJHyk9cV82gHAFf0V6UX+zecOVBT0QpnOk2WKuHOnMkrfIj2ixLoBMOx7Bdfk3+/RDzYp6pYmXUxoYnzmY2vI4dyCwQTlY9vWmL+zx1VArupvgHzgKBrvTNpTwQzm6rzkFGpLGtBRN/oDdmcwpIpcxH/VnJfjbxJTKi/2bDXEF0/5LMxK4sWcJksVYfeD0Fr9b9m0Y0jRWGbuws5KGvw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=mjxjOr5wbvhvGFQe1h5NBiR5xNC7dPyxjLQzSwUhIwM=;
 b=iRSr+/+jPHC4uEpBBTPosZgS0zvqAscXYOjYRk+jEJOMZCnbUIhvVpvExgvXMKaIM1N//bS7lHRsEhTTVX5nikqn+plHbBiQEJaxZBSkb2ZFBdnOimyLXGoYaxqNcTAaVbhl0yLax8JHK3r5pht9ICozLUhSJU2bllmky+ninbE=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by DS7PR10MB5974.namprd10.prod.outlook.com (2603:10b6:8:9e::10) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.18; Thu, 17 Oct
 2024 20:42:56 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Thu, 17 Oct 2024
 20:42:56 +0000
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Andrew Morton <akpm@linux-foundation.org>
Cc: Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@HansenPartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: [PATCH 4/4] selftests/mm: add self tests for guard page feature
Date: Thu, 17 Oct 2024 21:42:38 +0100
Message-ID: <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
X-Mailer: git-send-email 2.46.2
In-Reply-To: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: LO4P123CA0105.GBRP123.PROD.OUTLOOK.COM
 (2603:10a6:600:191::20) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|DS7PR10MB5974:EE_
X-MS-Office365-Filtering-Correlation-Id: 0568faa4-f6f6-48a9-f027-08dceeec4756
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|7416014|376014|366016|1800799024;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?KlXYLE+sqEfFMwDgDjumHLO9Z1J6CvRpcvTLMgjRsFgbaTk+WL0ZkDyZtTWz?=
 =?us-ascii?Q?Srd8KqfbsujSRLt9Ie7eA6tpDKXQDLarhBPQxHF1PnoJIM7qXSXKweNsqshF?=
 =?us-ascii?Q?XpLoTsbaWCa9nZj1ke8icMgeBYz1n9PwvMGiBcfd+D5fUX/2gRLG1EZSPLE0?=
 =?us-ascii?Q?ictngLts2DJZgLhzIhah9vEvPUIsMa6fD8Mv9FjAuGgizH1uCjvtrk7ikY1M?=
 =?us-ascii?Q?NfxOruJeN8+ACq12O9ExNVBJpfuQzGzdnFleisoTrfxx5k/2jh4h4DFKNFDN?=
 =?us-ascii?Q?AuUqlDoK6IreC8AbtUXSpWp2YDglQTXD6ZOtZdmMSyY2UNulnBDh5MAh7g23?=
 =?us-ascii?Q?LW394dHinBBA0N8RkFLSHqZGqJIjsbnMvAobq21SqT22rtP0YZchV6SwjOSh?=
 =?us-ascii?Q?lv72APTt43kIPe9kBeDrubd5FvwEiLAOdQviJM0Prk1FYJt/6VHLUk+BfWt5?=
 =?us-ascii?Q?TI0nCxcp3vYrNOP9uL2Jw9/IFng2qslwTF2BTARSwTt/iAZ/WeAFlMQ2EKvd?=
 =?us-ascii?Q?/icM3prj6V7vFQ0yYCS1sMJ22LCXN0GpjmY64xhMAf1eJA5+VGy4jjTLFhbO?=
 =?us-ascii?Q?pvUl0IaxxvCIqmqPPZniNRLFMM35neEaSI8j9rDXMUea6mHzx5tGZBHfPQS8?=
 =?us-ascii?Q?767g9Ng6Tj/NKkwnKI+eSagdQgdQXmuFFFFIshGygd/+Gt2GiMiN7w1rgnjY?=
 =?us-ascii?Q?48N2JtseE/+X6UUkVThXbChZpyBKT6ATr/n+5xpGM35hDNHD0YaYdzNl/oD7?=
 =?us-ascii?Q?GyD8hAGgt9MKUXVCqZI9FhBZG+fBBYNFbwiPCKkTtBU0akbemgGadsdQOe9S?=
 =?us-ascii?Q?z0AdVmuWDITNMFkp/1oGHxoMd9Quem5lWlNJ41eYeMIRUyq9fMi6xOtTW0wD?=
 =?us-ascii?Q?o3r8M3MSlO8GJU+JPsySreOts3feu4JqzjnP4F1PJifamCq5D7mjQ/ZG+MXS?=
 =?us-ascii?Q?dATDFJTDhKUHUEdz+Wo069DOK1OdyWEAKLrmd5Co98bdxUcXqk1hNxhz0xC/?=
 =?us-ascii?Q?g1St/W0/ClKzvu6L7gXIzqdx+SuYa2CQaYQumTJKZum/LSF/5jTHf6TQ/uXr?=
 =?us-ascii?Q?bfFREPApJEKFEvMuDFFT95WsgwcNdMEUCEt3C2eWipSCBGITS21eBkiC0RGB?=
 =?us-ascii?Q?jTqmq0aHLadwjLF1COs5ltJLdZgs/H1N8aLcAlaAU22vcXhREuFnMVkywAC+?=
 =?us-ascii?Q?IuWYqVTg3W/1Q/0Ch3AbGq6W6NmQRnSfRyG0YhhO4IkTMwapA0kJ4bu9SaOF?=
 =?us-ascii?Q?tBxdS7bGXJ9z1CSkXIcy5yEF347ZUR+wQ+ZF83l1nR0X4mwYK0vIp/THa5x1?=
 =?us-ascii?Q?9LfubLI6pSbkKfZHntXX6pLh?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(7416014)(376014)(366016)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?FWVj69PC51iEuYP4xFt1a76f16tPuuYvQGD9aw55ZwnFr0jGO+8hnPj75/Ta?=
 =?us-ascii?Q?HP5Xa3yGuHW60WWS6z1XN2YKsmR610gGUNN7fA7aCOtHqfE6OJornn8Li+7O?=
 =?us-ascii?Q?gDEb56GzIhd3e7IVfLUNTSND1TBeaTRWuJ98HRQOJmsee8WrI8j5IpJ+rQ+j?=
 =?us-ascii?Q?qS49om1/dV2GdyFKpzmTrzNGNHWjpOPUQuYq28CxT4lDGFiKKkxSkxEFISPR?=
 =?us-ascii?Q?RswMDf9gKGdAJrslGJcsc2qn5ArX2LggFCpTUD2d+zam+SqjHHO87Fnid8rF?=
 =?us-ascii?Q?TjfBycmMrazdDRk3VdPZiqy2eVR1vhUdf8PygJJH1/vhNS8uOo66OZgVWVYe?=
 =?us-ascii?Q?4aS8fCwSuXhq6SNOGgB4VUEq5KIbzBTiBw4yk8b6EAbtW/Uc0hU1LZxkzXdR?=
 =?us-ascii?Q?bZOiGlYAZpA5waZVn7T2GxSRAPggEGSH6UygRp95/b+/52HKTdEsrbUgaj5d?=
 =?us-ascii?Q?G0Ed/jKvizZ/uBsouzZFEBKGtFJgfv2xoKf8DGdtColg4T6I+FMZLCEy/uUp?=
 =?us-ascii?Q?v7sGVX/Ky06d2kB92vj9OD5V/EkgAJVi+0CsHbZag6StgWrtBk1IxNO4d5zA?=
 =?us-ascii?Q?0c5lYyd/hfJKZ9bSUlN921BZG0aCnKZ4zXfjV/xws1IeNZd+QDmWuVChT2sh?=
 =?us-ascii?Q?KgNBorNiqWS5JjQdZ2w30pJCkVtKoQLuYV9KQudPc6eRS698iqZdsTTHJ0bt?=
 =?us-ascii?Q?Zf+U+4Lp2MtjDtcGbrTU0gjnlvbftWBcY16ncfiboWeHk0Z6Egth5yh0YaFC?=
 =?us-ascii?Q?TNnw/EZsGKzeMerO9A+B0+GFaihGIHGgEnfQ6vTuducQB3ns7Bf0cUqjalMS?=
 =?us-ascii?Q?UUBqof5TUOepFf5ukm3b8KFRbenaD7eGCP9/36f+jK7OfksCD5QxDfYEq43X?=
 =?us-ascii?Q?4OVlo6dHpi4fxI4lp9gN6gWsQC7cdClANIryWEmKdzMVyupZuqxnsSFixsmZ?=
 =?us-ascii?Q?rVrunC+Ssb5UhaikVpg5YwgWMbLPovpz3Gb28yaWAi3f99NZtFFyBUHq1FnG?=
 =?us-ascii?Q?Ns2w4CfedZaxY3cOaBvnLO9A5uyNi3WGtjVJ3O2HOmBXYknOEmMTfZJuXRYB?=
 =?us-ascii?Q?5zVT4snJASPMZkfr/RjkhVZ/TfGNPMfD8AQ+jrmcnchWiq6Pg06cJozOGuZp?=
 =?us-ascii?Q?7ITVwYZnIu7ykhXib+LDdbaDEnjqmRlEw4cn/5CJpMknXEHU6uJALFoNfEM3?=
 =?us-ascii?Q?D474M9wv8yJoxIZksVOs7T410GwlmOIgbeLHGNVBx/nicQUtFCxTBn+H3/Mk?=
 =?us-ascii?Q?QVC8c0dMflNplQ7bAvi2kszDWIvrRgyMXwEUEmRrU25TVXrNZJcbQYuFr6cj?=
 =?us-ascii?Q?ALct3z3lq3FdteJUULYb2v7oyfY9TLjbFfwyRIURAuTo9yVrlGeCf0v5L+g2?=
 =?us-ascii?Q?Rxs2fwvI31tlHrnr9n/II35Tnhh5ZzvKU1KjFLU2pDiRlWY1iiiEvXg2g1h7?=
 =?us-ascii?Q?VrlncJTNfV/KiYldhlzYhIk7oTgdNbn9bB034kIHflp7hfvWw/DJyvURGFDo?=
 =?us-ascii?Q?tXj/Pu45IB5ybSOBD8tn5AJ6OfJKaVMwAefdaBIPRxMukhkKeLXCBOCpt+XV?=
 =?us-ascii?Q?F9exF2PhjwAF/kL/9CufJOo6qFN+BQrzdBPUczW01cSwDeH7mLLqlx+uibuS?=
 =?us-ascii?Q?rg=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	04IdAJTyJc6CGpLI/yDpzFed1E2pY9pCFLXiEQEbR8YvY3uMzrvz5+r7cIivnXKRlWemHh8AD+rOxs85M2xNVUpDjVmUYemJN6fZSD5Lm4JFOAKwQOMGFdjtoLVpshG1F/ov6CkUP1g+9UwWcmmlpMywUta+3nN8hX4MvzNCuh9pCULRYYpSxN3tex50ub8YiWvcHkl/hG19RTLUPqbFt2kBhpunYHzVacoLcvvZunT43EGSbKarBg1x5rSl2wE7Odhr0/qUqOMabEawot4xfZ4JVdQxCetZR7zzVjeVrIELo1mB7LduvtlKnj0IXy2mZp2Z3zJ1o6kymoTj0B4Cnr/ahpOJZ1HXfvfRJmgDzF43XZpypyrXT1VMv7JTasL+QI46WkMfsoYO/CskT+ecDr1o3uuLiUBRB74vUtfcTGWwokTJk5epILzo++Ihm/JwI3H2N4Gcwja9dsbd7LtXLWwuI+l2Gm0zI+MBgZzeJFGJ8FNmHPZq4lpTwF9jr6zHTSTS+Jm23ccBp1z7po79X1jVd79wakTqYJelwfnfqobPMpr/msJBv2f2UwiSdJR875YkPhEBHAGm2kt2juOZZ6mqkUJ5fcXFATyfWTAdS1c=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 0568faa4-f6f6-48a9-f027-08dceeec4756
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Oct 2024 20:42:56.0310
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: EUF5vtC6Y9VQoLi62ktxGtokhKhnN3FvZFMVLA3AWylfF2Dy3ilOsOSBHMN0o4Zm0rDT1rRDfLFNmHUcQ4g/85lIiK9wN1qCa2fpO89fV6E=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DS7PR10MB5974
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-17_23,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 phishscore=0 malwarescore=0
 adultscore=0 spamscore=0 mlxscore=0 suspectscore=0 bulkscore=0
 mlxlogscore=999 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2409260000 definitions=main-2410170139
X-Proofpoint-GUID: N2SY7OGOE6phBldDY_DAovJ8Y1yR9Xii
X-Proofpoint-ORIG-GUID: N2SY7OGOE6phBldDY_DAovJ8Y1yR9Xii

Utilise the kselftest harmness to implement tests for the guard page
implementation.

We start by implement basic tests asserting that guard pages can be
established (poisoned), cleared (remedied) and that touching poisoned pages
result in SIGSEGV. We also assert that, in remedying a range, non-poison
pages remain intact.

We then examine different operations on regions containing poison markers
behave to ensure correct behaviour:

* Operations over multiple VMAs operate as expected.
* Invoking MADV_GUARD_POISION / MADV_GUARD_REMEDY via process_madvise() in
  batches works correctly.
* Ensuring that munmap() correctly tears down poison markers.
* Using mprotect() to adjust protection bits does not in any way override
  or cause issues with poison markers.
* Ensuring that splitting and merging VMAs around poison markers causes no
  issue - i.e. that a marker which 'belongs' to one VMA can function just
  as well 'belonging' to another.
* Ensuring that madvise(..., MADV_DONTNEED) does not remove poison markers.
* Ensuring that mlock()'ing a range containing poison markers does not
  cause issues.
* Ensuring that mremap() can move a poisoned range and retain poison
  markers.
* Ensuring that mremap() can expand a poisoned range and retain poison
  markers (perhaps moving the range).
* Ensuring that mremap() can shrink a poisoned range and retain poison
  markers.
* Ensuring that forking a process correctly retains poison markers.
* Ensuring that forking a VMA with VM_WIPEONFORK set behaves sanely.
* Ensuring that lazyfree simply clears poison markers.
* Ensuring that userfaultfd can co-exist with guard pages.
* Ensuring that madvise(..., MADV_POPULATE_READ) and
  madvise(..., MADV_POPULATE_WRITE) error out when encountering
  poison markers.
* Ensuring that madvise(..., MADV_COLD) and madvise(..., MADV_PAGEOUT) do
  not remove poison markers.

Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
---
 tools/testing/selftests/mm/.gitignore    |    1 +
 tools/testing/selftests/mm/Makefile      |    1 +
 tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
 3 files changed, 1170 insertions(+)
 create mode 100644 tools/testing/selftests/mm/guard-pages.c

diff --git a/tools/testing/selftests/mm/Makefile b/tools/testing/selftests/mm/Makefile
index 02e1204971b0..15c734d6cfec 100644
--- a/tools/testing/selftests/mm/Makefile
+++ b/tools/testing/selftests/mm/Makefile
@@ -79,6 +79,7 @@ TEST_GEN_FILES += hugetlb_fault_after_madv
 TEST_GEN_FILES += hugetlb_madv_vs_map
 TEST_GEN_FILES += hugetlb_dio
 TEST_GEN_FILES += droppable
+TEST_GEN_FILES += guard-pages
 
 ifneq ($(ARCH),arm64)
 TEST_GEN_FILES += soft-dirty
diff --git a/tools/testing/selftests/mm/guard-pages.c b/tools/testing/selftests/mm/guard-pages.c
new file mode 100644
index 000000000000..2ab0ff3ba5a0
--- /dev/null
+++ b/tools/testing/selftests/mm/guard-pages.c
@@ -0,0 +1,1168 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#define _GNU_SOURCE
+#include "../kselftest_harness.h"
+#include <assert.h>
+#include <fcntl.h>
+#include <setjmp.h>
+#include <errno.h>
+#include <linux/userfaultfd.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+#include <sys/uio.h>
+#include <unistd.h>
+
+/* These may not yet be available in the uAPI so define if not. */
+
+#ifndef MADV_GUARD_POISON
+#define MADV_GUARD_POISON	102
+#endif
+
+#ifndef MADV_GUARD_UNPOISON
+#define MADV_GUARD_UNPOISON	103
+#endif
+
+volatile bool signal_jump_set;
+sigjmp_buf signal_jmp_buf;
+
+static int userfaultfd(int flags)
+{
+	return syscall(SYS_userfaultfd, flags);
+}
+
+static void handle_fatal(int c)
+{
+	if (!signal_jump_set)
+		return;
+
+	siglongjmp(signal_jmp_buf, c);
+}
+
+static int pidfd_open(pid_t pid, unsigned int flags)
+{
+	return syscall(SYS_pidfd_open, pid, flags);
+}
+
+/*
+ * Enable our signal catcher and try to read/write the specified buffer. The
+ * return value indicates whether the read/write succeeds without a fatal
+ * signal.
+ */
+static bool try_access_buf(char *ptr, bool write)
+{
+	bool failed;
+
+	/* Tell signal handler to jump back here on fatal signal. */
+	signal_jump_set = true;
+	/* If a fatal signal arose, we will jump back here and failed is set. */
+	failed = sigsetjmp(signal_jmp_buf, 0) != 0;
+
+	if (!failed) {
+		if (write) {
+			*ptr = 'x';
+		} else {
+			const volatile char *chr = ptr;
+
+			/* Force read. */
+			(void)*chr;
+		}
+	}
+
+	signal_jump_set = false;
+	return !failed;
+}
+
+/* Try and read from a buffer, return true if no fatal signal. */
+static bool try_read_buf(char *ptr)
+{
+	return try_access_buf(ptr, false);
+}
+
+/* Try and write to a buffer, return true if no fatal signal. */
+static bool try_write_buf(char *ptr)
+{
+	return try_access_buf(ptr, true);
+}
+
+/*
+ * Try and BOTH read from AND write to a buffer, return true if BOTH operations
+ * succeed.
+ */
+static bool try_read_write_buf(char *ptr)
+{
+	return try_read_buf(ptr) && try_write_buf(ptr);
+}
+
+FIXTURE(guard_pages)
+{
+	unsigned long page_size;
+};
+
+FIXTURE_SETUP(guard_pages)
+{
+	struct sigaction act = {
+		.sa_handler = &handle_fatal,
+		.sa_flags = SA_NODEFER,
+	};
+
+	sigemptyset(&act.sa_mask);
+	if (sigaction(SIGSEGV, &act, NULL)) {
+		perror("sigaction");
+		ksft_exit_fail();
+	}
+
+	self->page_size = (unsigned long)sysconf(_SC_PAGESIZE);
+};
+
+FIXTURE_TEARDOWN(guard_pages)
+{
+	struct sigaction act = {
+		.sa_handler = SIG_DFL,
+		.sa_flags = SA_NODEFER,
+	};
+
+	sigemptyset(&act.sa_mask);
+	sigaction(SIGSEGV, &act, NULL);
+}
+
+TEST_F(guard_pages, basic)
+{
+	const unsigned long NUM_PAGES = 10;
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	int i;
+
+	ptr = mmap(NULL, NUM_PAGES * page_size, PROT_READ | PROT_WRITE,
+		   MAP_PRIVATE | MAP_ANON, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Trivially assert we can touch the first page. */
+	ASSERT_TRUE(try_read_write_buf(ptr));
+
+	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
+
+	/* Establish that 1st page SIGSEGV's. */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+
+	/* Ensure we can touch everything else.*/
+	for (i = 1; i < NUM_PAGES; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Establish a guard page at the end of the mapping. */
+	ASSERT_EQ(madvise(&ptr[(NUM_PAGES - 1) * page_size], page_size,
+			  MADV_GUARD_POISON), 0);
+
+	/* Check that both guard pages result in SIGSEGV. */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+	ASSERT_FALSE(try_read_write_buf(&ptr[(NUM_PAGES - 1) * page_size]));
+
+	/* Unpoison the first. */
+	ASSERT_FALSE(madvise(ptr, page_size, MADV_GUARD_UNPOISON));
+
+	/* Make sure we can touch it. */
+	ASSERT_TRUE(try_read_write_buf(ptr));
+
+	/* Unpoison the last. */
+	ASSERT_FALSE(madvise(&ptr[(NUM_PAGES - 1) * page_size], page_size,
+			     MADV_GUARD_UNPOISON));
+
+	/* Make sure we can touch it. */
+	ASSERT_TRUE(try_read_write_buf(&ptr[(NUM_PAGES - 1) * page_size]));
+
+	/*
+	 *  Test setting a _range_ of pages, namely the first 3. The first of
+	 *  these be faulted in, so this also tests that we can poison backed
+	 *  pages.
+	 */
+	ASSERT_EQ(madvise(ptr, 3 * page_size, MADV_GUARD_POISON), 0);
+
+	/* Make sure they are all poisoned. */
+	for (i = 0; i < 3; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Make sure the rest are not. */
+	for (i = 3; i < NUM_PAGES; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Unpoison them. */
+	ASSERT_EQ(madvise(ptr, NUM_PAGES * page_size, MADV_GUARD_UNPOISON), 0);
+
+	/* Now make sure we can touch everything. */
+	for (i = 0; i < NUM_PAGES; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Now unpoison everything, make sure we don't remove existing entries */
+	ASSERT_EQ(madvise(ptr, NUM_PAGES * page_size, MADV_GUARD_UNPOISON), 0);
+
+	for (i = 0; i < NUM_PAGES * page_size; i += page_size) {
+		ASSERT_EQ(ptr[i], 'x');
+	}
+
+	ASSERT_EQ(munmap(ptr, NUM_PAGES * page_size), 0);
+}
+
+/* Assert that operations applied across multiple VMAs work as expected. */
+TEST_F(guard_pages, multi_vma)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr_region, *ptr, *ptr1, *ptr2, *ptr3;
+	int i;
+
+	/* Reserve a 100 page region over which we can install VMAs. */
+	ptr_region = mmap(NULL, 100 * page_size, PROT_NONE,
+			  MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr_region, MAP_FAILED);
+
+	/* Place a VMA of 10 pages size at the start of the region. */
+	ptr1 = mmap(ptr_region, 10 * page_size, PROT_READ | PROT_WRITE,
+		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr1, MAP_FAILED);
+
+	/* Place a VMA of 5 pages size 50 pages into the region. */
+	ptr2 = mmap(&ptr_region[50 * page_size], 5 * page_size,
+		    PROT_READ | PROT_WRITE,
+		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr2, MAP_FAILED);
+
+	/* Place a VMA of 20 pages size at the end of the region. */
+	ptr3 = mmap(&ptr_region[80 * page_size], 20 * page_size,
+		    PROT_READ | PROT_WRITE,
+		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr3, MAP_FAILED);
+
+	/* Unmap gaps. */
+	ASSERT_EQ(munmap(&ptr_region[10 * page_size], 40 * page_size), 0);
+	ASSERT_EQ(munmap(&ptr_region[55 * page_size], 25 * page_size), 0);
+
+	/*
+	 * We end up with VMAs like this:
+	 *
+	 * 0    10 .. 50   55 .. 80   100
+	 * [---]      [---]      [---]
+	 */
+
+	/* Now poison the whole range and make sure all VMAs are poisoned. */
+
+	/*
+	 * madvise() is certifiable and lets you perform operations over gaps,
+	 * everything works, but it indicates an error and errno is set to
+	 * -ENOMEM. Also if anything runs out of memory it is set to
+	 * -ENOMEM. You are meant to guess which is which.
+	 */
+	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_POISON), -1);
+	ASSERT_EQ(errno, ENOMEM);
+
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr1[i * page_size]));
+	}
+
+	for (i = 0; i < 5; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr2[i * page_size]));
+	}
+
+	for (i = 0; i < 20; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr3[i * page_size]));
+	}
+
+	/* Now unpoison the range and assert the opposite. */
+
+	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_UNPOISON), -1);
+	ASSERT_EQ(errno, ENOMEM);
+
+	for (i = 0; i < 10; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr1[i * page_size]));
+	}
+
+	for (i = 0; i < 5; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr2[i * page_size]));
+	}
+
+	for (i = 0; i < 20; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr3[i * page_size]));
+	}
+
+	/* Now map incompatible VMAs in the gaps. */
+	ptr = mmap(&ptr_region[10 * page_size], 40 * page_size,
+		   PROT_READ | PROT_WRITE | PROT_EXEC,
+		   MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+	ptr = mmap(&ptr_region[55 * page_size], 25 * page_size,
+		   PROT_READ | PROT_WRITE | PROT_EXEC,
+		   MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/*
+	 * We end up with VMAs like this:
+	 *
+	 * 0    10 .. 50   55 .. 80   100
+	 * [---][xxxx][---][xxxx][---]
+	 *
+	 * Where 'x' signifies VMAs that cannot be merged with those adjacent to
+	 * them.
+	 */
+
+	/* Multiple VMAs adjacent to one another should result in no error. */
+	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_POISON), 0);
+	for (i = 0; i < 100; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr_region[i * page_size]));
+	}
+	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_UNPOISON), 0);
+	for (i = 0; i < 100; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr_region[i * page_size]));
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr_region, 100 * page_size), 0);
+}
+
+/*
+ * Assert that batched operations performed using process_madvise() work as
+ * expected.
+ */
+TEST_F(guard_pages, process_madvise)
+{
+	const unsigned long page_size = self->page_size;
+	pid_t pid = getpid();
+	int pidfd = pidfd_open(pid, 0);
+	char *ptr_region, *ptr1, *ptr2, *ptr3;
+	ssize_t count;
+	struct iovec vec[6];
+
+	ASSERT_NE(pidfd, -1);
+
+	/* Reserve region to map over. */
+	ptr_region = mmap(NULL, 100 * page_size, PROT_NONE,
+			  MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr_region, MAP_FAILED);
+
+	/* 10 pages offset 1 page into reserve region. */
+	ptr1 = mmap(&ptr_region[page_size], 10 * page_size,
+		    PROT_READ | PROT_WRITE,
+		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr1, MAP_FAILED);
+	/* We want poison markers at start/end of each VMA. */
+	vec[0].iov_base = ptr1;
+	vec[0].iov_len = page_size;
+	vec[1].iov_base = &ptr1[9 * page_size];
+	vec[1].iov_len = page_size;
+
+	/* 5 pages offset 50 pages into reserve region. */
+	ptr2 = mmap(&ptr_region[50 * page_size], 5 * page_size,
+		    PROT_READ | PROT_WRITE,
+		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr2, MAP_FAILED);
+	vec[2].iov_base = ptr2;
+	vec[2].iov_len = page_size;
+	vec[3].iov_base = &ptr2[4 * page_size];
+	vec[3].iov_len = page_size;
+
+	/* 20 pages offset 79 pages into reserve region. */
+	ptr3 = mmap(&ptr_region[79 * page_size], 20 * page_size,
+		    PROT_READ | PROT_WRITE,
+		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr3, MAP_FAILED);
+	vec[4].iov_base = ptr3;
+	vec[4].iov_len = page_size;
+	vec[5].iov_base = &ptr3[19 * page_size];
+	vec[5].iov_len = page_size;
+
+	/* Free surrounding VMAs. */
+	ASSERT_EQ(munmap(ptr_region, page_size), 0);
+	ASSERT_EQ(munmap(&ptr_region[11 * page_size], 39 * page_size), 0);
+	ASSERT_EQ(munmap(&ptr_region[55 * page_size], 24 * page_size), 0);
+	ASSERT_EQ(munmap(&ptr_region[99 * page_size], page_size), 0);
+
+	/* Now poison in one step. */
+	count = process_madvise(pidfd, vec, 6, MADV_GUARD_POISON, 0);
+
+	/* OK we don't have permission to do this, skip. */
+	if (count == -1 && errno == EPERM)
+		ksft_exit_skip("No process_madvise() permissions\n");
+
+	/* Returns the number of bytes advised. */
+	ASSERT_EQ(count, 6 * page_size);
+
+	/* Now make sure the poisoning was applied. */
+
+	ASSERT_FALSE(try_read_write_buf(ptr1));
+	ASSERT_FALSE(try_read_write_buf(&ptr1[9 * page_size]));
+
+	ASSERT_FALSE(try_read_write_buf(ptr2));
+	ASSERT_FALSE(try_read_write_buf(&ptr2[4 * page_size]));
+
+	ASSERT_FALSE(try_read_write_buf(ptr3));
+	ASSERT_FALSE(try_read_write_buf(&ptr3[19 * page_size]));
+
+	/* Now do the same with unpoison... */
+	count = process_madvise(pidfd, vec, 6, MADV_GUARD_UNPOISON, 0);
+
+	/* ...and everything should now succeed. */
+
+	ASSERT_TRUE(try_read_write_buf(ptr1));
+	ASSERT_TRUE(try_read_write_buf(&ptr1[9 * page_size]));
+
+	ASSERT_TRUE(try_read_write_buf(ptr2));
+	ASSERT_TRUE(try_read_write_buf(&ptr2[4 * page_size]));
+
+	ASSERT_TRUE(try_read_write_buf(ptr3));
+	ASSERT_TRUE(try_read_write_buf(&ptr3[19 * page_size]));
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr1, 10 * page_size), 0);
+	ASSERT_EQ(munmap(ptr2, 5 * page_size), 0);
+	ASSERT_EQ(munmap(ptr3, 20 * page_size), 0);
+	close(pidfd);
+}
+
+/* Assert that unmapping ranges does not leave poison behind. */
+TEST_F(guard_pages, munmap)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr, *ptr_new1, *ptr_new2;
+
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Poison first and last pages. */
+	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
+	ASSERT_EQ(madvise(&ptr[9 * page_size], page_size, MADV_GUARD_POISON), 0);
+
+	/* Assert that they are poisoned. */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+	ASSERT_FALSE(try_read_write_buf(&ptr[9 * page_size]));
+
+	/* Unmap them. */
+	ASSERT_EQ(munmap(ptr, page_size), 0);
+	ASSERT_EQ(munmap(&ptr[9 * page_size], page_size), 0);
+
+	/* Map over them.*/
+	ptr_new1 = mmap(ptr, page_size, PROT_READ | PROT_WRITE,
+			MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr_new1, MAP_FAILED);
+	ptr_new2 = mmap(&ptr[9 * page_size], page_size, PROT_READ | PROT_WRITE,
+			MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr_new2, MAP_FAILED);
+
+	/* Assert that they are now not poisoned. */
+	ASSERT_TRUE(try_read_write_buf(ptr_new1));
+	ASSERT_TRUE(try_read_write_buf(ptr_new2));
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/* Assert that mprotect() operations have no bearing on guard poison markers. */
+TEST_F(guard_pages, mprotect)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	int i;
+
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Poison the middle of the range. */
+	ASSERT_EQ(madvise(&ptr[5 * page_size], 2 * page_size,
+			  MADV_GUARD_POISON), 0);
+
+	/* Assert that it is indeed poisoned. */
+	ASSERT_FALSE(try_read_write_buf(&ptr[5 * page_size]));
+	ASSERT_FALSE(try_read_write_buf(&ptr[6 * page_size]));
+
+	/* Now make these pages read-only. */
+	ASSERT_EQ(mprotect(&ptr[5 * page_size], 2 * page_size, PROT_READ), 0);
+
+	/* Make sure the range is still poisoned. */
+	ASSERT_FALSE(try_read_buf(&ptr[5 * page_size]));
+	ASSERT_FALSE(try_read_buf(&ptr[6 * page_size]));
+
+	/* Make sure we can poison again without issue.*/
+	ASSERT_EQ(madvise(&ptr[5 * page_size], 2 * page_size,
+			  MADV_GUARD_POISON), 0);
+
+	/* Make sure the range is, yet again, still poisoned. */
+	ASSERT_FALSE(try_read_buf(&ptr[5 * page_size]));
+	ASSERT_FALSE(try_read_buf(&ptr[6 * page_size]));
+
+	/* Now unpoison the whole range. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
+
+	/* Make sure the whole range is readable. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_TRUE(try_read_buf(&ptr[i * page_size]));
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/* Split and merge VMAs and make sure guard pages still behave. */
+TEST_F(guard_pages, split_merge)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr, *ptr_new;
+	int i;
+
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Poison the whole range. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
+
+	/* Make sure the whole range is poisoned. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Now unmap some pages in the range so we split. */
+	ASSERT_EQ(munmap(&ptr[2 * page_size], page_size), 0);
+	ASSERT_EQ(munmap(&ptr[5 * page_size], page_size), 0);
+	ASSERT_EQ(munmap(&ptr[8 * page_size], page_size), 0);
+
+	/* Make sure the remaining ranges are poisoned post-split. */
+	for (i = 0; i < 2; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+	for (i = 2; i < 5; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+	for (i = 6; i < 8; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+	for (i = 9; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Now map them again - the unmap will have cleared the poison. */
+	ptr_new = mmap(&ptr[2 * page_size], page_size, PROT_READ | PROT_WRITE,
+		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr_new, MAP_FAILED);
+	ptr_new = mmap(&ptr[5 * page_size], page_size, PROT_READ | PROT_WRITE,
+		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr_new, MAP_FAILED);
+	ptr_new = mmap(&ptr[8 * page_size], page_size, PROT_READ | PROT_WRITE,
+		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr_new, MAP_FAILED);
+
+	/* Now make sure poisoning is as expected. */
+	for (i = 0; i < 10; i++) {
+		bool result = try_read_write_buf(&ptr[i * page_size]);
+
+		if (i == 2 || i == 5 || i == 8) {
+			ASSERT_TRUE(result);
+		} else {
+			ASSERT_FALSE(result);
+		}
+	}
+
+	/* Now poison everything again. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
+
+	/* Make sure the whole range is poisoned. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Now split the range into three. */
+	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ), 0);
+	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size, PROT_READ), 0);
+
+	/* Make sure the whole range is poisoned for read. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_buf(&ptr[i * page_size]));
+	}
+
+	/* Now reset protection bits so we merge the whole thing. */
+	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ | PROT_WRITE), 0);
+	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size,
+			   PROT_READ | PROT_WRITE), 0);
+
+	/* Make sure the whole range is still poisoned. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Split range into 3 again... */
+	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ), 0);
+	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size, PROT_READ), 0);
+
+	/* ...and unpoison the whole range. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
+
+	/* Make sure the whole range is remedied for read. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_TRUE(try_read_buf(&ptr[i * page_size]));
+	}
+
+	/* Merge them again. */
+	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ | PROT_WRITE), 0);
+	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size,
+			   PROT_READ | PROT_WRITE), 0);
+
+	/* Now ensure the merged range is remedied for read/write. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/* Assert that MADV_DONTNEED does not remove guard poison markers. */
+TEST_F(guard_pages, dontneed)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	int i;
+
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Back the whole range. */
+	for (i = 0; i < 10; i++) {
+		ptr[i * page_size] = 'y';
+	}
+
+	/* Poison every other page. */
+	for (i = 0; i < 10; i += 2) {
+		ASSERT_EQ(madvise(&ptr[i * page_size],
+				  page_size, MADV_GUARD_POISON), 0);
+	}
+
+	/* Indicate that we don't need any of the range. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_DONTNEED), 0);
+
+	/* Check to ensure poison markers are still in place. */
+	for (i = 0; i < 10; i++) {
+		bool result = try_read_buf(&ptr[i * page_size]);
+
+		if (i % 2 == 0) {
+			ASSERT_FALSE(result);
+		} else {
+			ASSERT_TRUE(result);
+			/* Make sure we really did get reset to zero page. */
+			ASSERT_EQ(ptr[i * page_size], '\0');
+		}
+
+		/* Now write... */
+		result = try_write_buf(&ptr[i * page_size]);
+
+		/* ...and make sure same result. */
+		if (i % 2 == 0) {
+			ASSERT_FALSE(result);
+		} else {
+			ASSERT_TRUE(result);
+		}
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/* Assert that mlock()'ed pages work correctly with poison markers. */
+TEST_F(guard_pages, mlock)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	int i;
+
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Populate. */
+	for (i = 0; i < 10; i++) {
+		ptr[i * page_size] = 'y';
+	}
+
+	/* Lock. */
+	ASSERT_EQ(mlock(ptr, 10 * page_size), 0);
+
+	/* Now try to poison, should fail with EINVAL. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), -1);
+	ASSERT_EQ(errno, EINVAL);
+
+	/* OK unlock. */
+	ASSERT_EQ(munlock(ptr, 10 * page_size), 0);
+
+	/* Poison first half of range, should now succeed. */
+	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
+
+	/* Make sure poison works. */
+	for (i = 0; i < 10; i++) {
+		bool result = try_read_write_buf(&ptr[i * page_size]);
+
+		if (i < 5) {
+			ASSERT_FALSE(result);
+		} else {
+			ASSERT_TRUE(result);
+			ASSERT_EQ(ptr[i * page_size], 'x');
+		}
+	}
+
+	/*
+	 * Now lock the latter part of the range. We can't lock the poisoned
+	 * pages, as this would result in the pages being populated and the
+	 * poisoning would cause this to error out.
+	 */
+	ASSERT_EQ(mlock(&ptr[5 * page_size], 5 * page_size), 0);
+
+	/*
+	 * Now unpoison, we do not permit mlock()'d ranges to be remedied as it is
+	 * a non-destructive operation.
+	 */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
+
+	/* Now check that everything is remedied. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/*
+ * Assert that moving, extending and shrinking memory via mremap() retains
+ * poison markers where possible.
+ *
+ * - Moving a mapping alone should retain markers as they are.
+ */
+TEST_F(guard_pages, mremap_move)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr, *ptr_new;
+
+	/* Map 5 pages. */
+	ptr = mmap(NULL, 5 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Place poison markers at both ends of the 5 page span. */
+	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
+	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
+
+	/* Make sure the poison is in effect. */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
+
+	/* Map a new region we will move this range into. Doing this ensures
+	 * that we have reserved a range to map into.
+	 */
+	ptr_new = mmap(NULL, 5 * page_size, PROT_NONE, MAP_ANON | MAP_PRIVATE,
+		       -1, 0);
+	ASSERT_NE(ptr_new, MAP_FAILED);
+
+	ASSERT_EQ(mremap(ptr, 5 * page_size, 5 * page_size,
+			 MREMAP_MAYMOVE | MREMAP_FIXED, ptr_new), ptr_new);
+
+	/* Make sure the poison is retained. */
+	ASSERT_FALSE(try_read_write_buf(ptr_new));
+	ASSERT_FALSE(try_read_write_buf(&ptr_new[4 * page_size]));
+
+	/*
+	 * Clean up - we only need reference the new pointer as we overwrote the
+	 * PROT_NONE range and moved the existing one.
+	 */
+	munmap(ptr_new, 5 * page_size);
+}
+
+/*
+ * Assert that moving, extending and shrinking memory via mremap() retains
+ * poison markers where possible.
+ *
+ * - Expanding should retain, only now in different position. The user will have
+ *   to unpoison manually to fix up (they'd have to do the same if it were a
+ *   PROT_NONE mapping)
+ */
+TEST_F(guard_pages, mremap_expand)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr, *ptr_new;
+
+	/* Map 10 pages... */
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+	/* ...But unmap the last 5 so we can ensure we can expand into them. */
+	ASSERT_EQ(munmap(&ptr[5 * page_size], 5 * page_size), 0);
+
+	/* Place poison markers at both ends of the 5 page span. */
+	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
+	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
+
+	/* Make sure the poison is in effect. */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
+
+	/* Now expand to 10 pages. */
+	ptr = mremap(ptr, 5 * page_size, 10 * page_size, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Make sure the poison is retained in its original positions. */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
+
+	/* Reserve a region which we can move to and expand into. */
+	ptr_new = mmap(NULL, 20 * page_size, PROT_NONE,
+		       MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr_new, MAP_FAILED);
+
+	/* Now move and expand into it. */
+	ptr = mremap(ptr, 10 * page_size, 20 * page_size,
+		     MREMAP_MAYMOVE | MREMAP_FIXED, ptr_new);
+	ASSERT_EQ(ptr, ptr_new);
+
+	/* Again, make sure the poison is retained in its original
+	 * positions. */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
+
+	/*
+	 * A real user would have to unpoison, but would reasonably expect all
+	 * characteristics of the mapping to be retained, including poison
+	 * markers.
+	 */
+
+	/* Cleanup. */
+	munmap(ptr, 20 * page_size);
+}
+/*
+ * Assert that moving, extending and shrinking memory via mremap() retains
+ * poison markers where possible.
+ *
+ * - Shrinking will result in markers that are shrunk over being removed. Again,
+ *   if the user were using a PROT_NONE mapping they'd have to manually fix this
+ *   up also so this is OK.
+ */
+TEST_F(guard_pages, mremap_shrink)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	int i;
+
+	/* Map 5 pages. */
+	ptr = mmap(NULL, 5 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Place poison markers at both ends of the 5 page span. */
+	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
+	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
+
+	/* Make sure the poison is in effect. */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
+
+	/* Now shrink to 3 pages. */
+	ptr = mremap(ptr, 5 * page_size, 3 * page_size, MREMAP_MAYMOVE);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* We expect the poison marker at the start to be retained... */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+
+	/* ...But remaining pages will not have poison markers. */
+	for (i = 1; i < 3; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr[i + page_size]));
+	}
+
+	/*
+	 * As with expansion, a real user would have to unpoison and fixup. But
+	 * you'd have to do similar manual things with PROT_NONE mappings too.
+	 */
+
+	/*
+	 * If we expand back to the original size, the end marker will, of
+	 * course, no longer be present.
+	 */
+	ptr = mremap(ptr, 3 * page_size, 5 * page_size, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Again, we expect the poison marker at the start to be retained... */
+	ASSERT_FALSE(try_read_write_buf(ptr));
+
+	/* ...But remaining pages will not have poison markers. */
+	for (i = 1; i < 5; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr[i + page_size]));
+	}
+
+	/* Cleanup. */
+	munmap(ptr, 5 * page_size);
+}
+
+/*
+ * Assert that forking a process with VMAs that do not have VM_WIPEONFORK set
+ * retain guard pages.
+ */
+TEST_F(guard_pages, fork)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	pid_t pid;
+	int i;
+
+	/* Map 10 pages. */
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Poison the first 5 pages. */
+	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
+
+	pid = fork();
+	ASSERT_NE(pid, -1);
+	if (!pid) {
+		/* This is the child process now. */
+
+		/* Assert that the poisoning is in effect. */
+		for (i = 0; i < 10; i++) {
+			bool result = try_read_write_buf(&ptr[i * page_size]);
+
+			if (i < 5) {
+				ASSERT_FALSE(result);
+			} else {
+				ASSERT_TRUE(result);
+			}
+		}
+
+		/* Now unpoison the range.*/
+		ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
+
+		exit(0);
+	}
+
+	/* Parent process. */
+
+	/* Parent simply waits on child. */
+	waitpid(pid, NULL, 0);
+
+	/* Child unpoison does not impact parent page table state. */
+	for (i = 0; i < 10; i++) {
+		bool result = try_read_write_buf(&ptr[i * page_size]);
+
+		if (i < 5) {
+			ASSERT_FALSE(result);
+		} else {
+			ASSERT_TRUE(result);
+		}
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/*
+ * Assert that forking a process with VMAs that do have VM_WIPEONFORK set
+ * behave as expected.
+ */
+TEST_F(guard_pages, fork_wipeonfork)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	pid_t pid;
+	int i;
+
+	/* Map 10 pages. */
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Mark wipe on fork. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_WIPEONFORK), 0);
+
+	/* Poison the first 5 pages. */
+	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
+
+	pid = fork();
+	ASSERT_NE(pid, -1);
+	if (!pid) {
+		/* This is the child process now. */
+
+		/* Poison will have been wiped. */
+		for (i = 0; i < 10; i++) {
+			ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
+		}
+
+		exit(0);
+	}
+
+	/* Parent process. */
+
+	waitpid(pid, NULL, 0);
+
+	/* Poison should be in effect.*/
+	for (i = 0; i < 10; i++) {
+		bool result = try_read_write_buf(&ptr[i * page_size]);
+
+		if (i < 5) {
+			ASSERT_FALSE(result);
+		} else {
+			ASSERT_TRUE(result);
+		}
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/* Ensure that MADV_FREE frees poison entries as expected. */
+TEST_F(guard_pages, lazyfree)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	int i;
+
+	/* Map 10 pages. */
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Poison range. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
+
+	/* Ensure poisoned. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Lazyfree range. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_FREE), 0);
+
+	/* This should simply clear the poison markers. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/* Ensure that MADV_POPULATE_READ, MADV_POPULATE_WRITE behave as expected. */
+TEST_F(guard_pages, populate)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+
+	/* Map 10 pages. */
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Poison range. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
+
+	/* Populate read should error out... */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_POPULATE_READ), -1);
+	ASSERT_EQ(errno, EFAULT);
+
+	/* ...as should populate write. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_POPULATE_WRITE), -1);
+	ASSERT_EQ(errno, EFAULT);
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/* Ensure that MADV_COLD, MADV_PAGEOUT do not remove poison markers. */
+TEST_F(guard_pages, cold_pageout)
+{
+	const unsigned long page_size = self->page_size;
+	char *ptr;
+	int i;
+
+	/* Map 10 pages. */
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Poison range. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
+
+	/* Ensured poisoned. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Now mark cold. This should have no impact on poison markers. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_COLD), 0);
+
+	/* Should remain poisoned. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* OK, now page out. This should equally, have no effect on markers. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_PAGEOUT), 0);
+
+	/* Should remain poisoned. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+/* Ensure that guard pages do not break userfaultd. */
+TEST_F(guard_pages, uffd)
+{
+	const unsigned long page_size = self->page_size;
+	int uffd;
+	char *ptr;
+	int i;
+	struct uffdio_api api = {
+		.api = UFFD_API,
+		.features = 0,
+	};
+	struct uffdio_register reg;
+	struct uffdio_range range;
+
+	/* Set up uffd. */
+	uffd = userfaultfd(0);
+	if (uffd == -1 && errno == EPERM)
+		ksft_exit_skip("No uffd permissions\n");
+	ASSERT_NE(uffd, -1);
+
+	ASSERT_EQ(ioctl(uffd, UFFDIO_API, &api), 0);
+
+	/* Map 10 pages. */
+	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
+		   MAP_ANON | MAP_PRIVATE, -1, 0);
+	ASSERT_NE(ptr, MAP_FAILED);
+
+	/* Register the range with uffd. */
+	range.start = (unsigned long)ptr;
+	range.len = 10 * page_size;
+	reg.range = range;
+	reg.mode = UFFDIO_REGISTER_MODE_MISSING;
+	ASSERT_EQ(ioctl(uffd, UFFDIO_REGISTER, &reg), 0);
+
+	/* Poison the range. This should not trigger the uffd. */
+	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
+
+	/* The poisoning should behave as usual with no uffd intervention. */
+	for (i = 0; i < 10; i++) {
+		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
+	}
+
+	/* Cleanup. */
+	ASSERT_EQ(ioctl(uffd, UFFDIO_UNREGISTER, &range), 0);
+	close(uffd);
+	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
+}
+
+TEST_HARNESS_MAIN
-- 
2.46.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mail-io1-f51.google.com (mail-io1-f51.google.com [209.85.166.51])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 95AFD1D3182
	for <linux-kernel@vger.kernel.org>; Thu, 17 Oct 2024 21:24:53 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=209.85.166.51
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729200296; cv=none; b=eD3Ck1hX8DBauqIm6MHn6xbGDoQcIbgMIwsICf6UFQjqD8KBAcGJ/eTcKOfPe7Q9sxgYdoHs/KFErjpn1G7pfJutpjZ3ybsaIt0Ymdewbz/aXINsqAuBVLUyks+TUOGb6NxgLn2JNm4ZWub0kTf+TcPDaURmAP+lAqry/cNiaOQ=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729200296; c=relaxed/simple;
	bh=J0wFClx5q4an3jKKOjmI+yKpwbKx7FbSqCKGCyDXRI0=;
	h=Message-ID:Date:MIME-Version:Subject:To:Cc:References:From:
	 In-Reply-To:Content-Type; b=uf29WpjUWAmaEjbXSP5AfKeywJKg3S8kYB7ZhxU9Qn6W96/qoRqOefwQuaB3oolK5+dua62RzFf3eb4ILyK8OT3tO6m1OMJhO+7jNwAWoBp90Lxj8bclsYi38CZKVP+R9AQ/EWmkdx4aKrI0GQ8jVMDdeIbvQM+MQSiDiHpm9aw=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=linuxfoundation.org; spf=pass smtp.mailfrom=linuxfoundation.org; dkim=pass (1024-bit key) header.d=linuxfoundation.org header.i=@linuxfoundation.org header.b=J672Ox+o; arc=none smtp.client-ip=209.85.166.51
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=linuxfoundation.org
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=linuxfoundation.org
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=linuxfoundation.org header.i=@linuxfoundation.org header.b="J672Ox+o"
Received: by mail-io1-f51.google.com with SMTP id ca18e2360f4ac-83ab21c269eso46161939f.2
        for <linux-kernel@vger.kernel.org>; Thu, 17 Oct 2024 14:24:53 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=linuxfoundation.org; s=google; t=1729200292; x=1729805092; darn=vger.kernel.org;
        h=content-transfer-encoding:in-reply-to:from:content-language
         :references:cc:to:subject:user-agent:mime-version:date:message-id
         :from:to:cc:subject:date:message-id:reply-to;
        bh=gMbCxgTGFZeo8xghXumUnHGUAo1uXMmJhzYDvhqP+2w=;
        b=J672Ox+ol+vxDGiEc+jtAx5gYCV7IATsVmTgLpuoamxNmGlePGAiovMDzR/fRNLX4+
         Gz4ou2j2npkbQ2+E+Mk/6rtlEuMPfl23c4FMxT2oHX3nHvrkPHRTwNgS4jBor2E1KmTO
         tUd+kS8Rootm7ApB9jbfRVDC/ONX8B6KHRbC4=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1729200292; x=1729805092;
        h=content-transfer-encoding:in-reply-to:from:content-language
         :references:cc:to:subject:user-agent:mime-version:date:message-id
         :x-gm-message-state:from:to:cc:subject:date:message-id:reply-to;
        bh=gMbCxgTGFZeo8xghXumUnHGUAo1uXMmJhzYDvhqP+2w=;
        b=ryBBNqZ4GG4SIFrR2P0VQRVm74QofWwmsNnysm1t/IbfhRUa9M2b/FcEoHgg3NGXPW
         8h/GNRkZ7k84qU1eGkTy3Xj9Bl4fVaTz/9CenL5zZQopb6ojZVscmooqewT0s1acsbvr
         rkoO3hGKeTEN0NVkjRH8//7MNH6WTPw5ySkJ6/mU0nymEkSUjbP0JcFoTGK3vHxXPlx6
         gMu0KeW1dx8/hgzXGFgSEnjLggPiV/tPhIJgqeujukpp857VDQySIlPHrLThG5FOK9y/
         kp3F43Zq0yq8Dry7RiiVZAfcAl5OaiabBRejmyWNFUbH7ZTzndnXY5g/A+5fL98Dwc/T
         BynA==
X-Forwarded-Encrypted: i=1; AJvYcCW5otKxcZKU/4LPpL3l3zFRUtbBZQmuB/frVrrsjBZEm3I+BEmcRvqipTSDOZuiV1rMuVukW0ic+yBxIso=@vger.kernel.org
X-Gm-Message-State: AOJu0Yws8zdO2+ZNw4/PsmmeBNF8MD+wIbd6+FvUlwk1jv12kp/SGfiY
	JYgbyaSQJcwLjfLfEOz05gpfJ9k4wjcIKxd+fnld1eCxFW9HbsQPDTPSQ4acXPc=
X-Google-Smtp-Source: AGHT+IHC3/MvC+py8nduUW2aOgWAkhavkA1wA78l3+pmvg9lkRGXKBxpxvl3gpbXsZYPTh4UEQlbNw==
X-Received: by 2002:a05:6e02:16cf:b0:3a3:af94:461f with SMTP id e9e14a558f8ab-3a3f4050131mr2223035ab.1.1729200292152;
        Thu, 17 Oct 2024 14:24:52 -0700 (PDT)
Received: from [192.168.1.128] ([38.175.170.29])
        by smtp.gmail.com with ESMTPSA id 8926c6da1cb9f-4dc10c2b54esm67348173.110.2024.10.17.14.24.50
        (version=TLS1_3 cipher=TLS_AES_128_GCM_SHA256 bits=128/128);
        Thu, 17 Oct 2024 14:24:51 -0700 (PDT)
Message-ID: <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
Date: Thu, 17 Oct 2024 15:24:49 -0600
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
User-Agent: Mozilla Thunderbird
Subject: Re: [PATCH 4/4] selftests/mm: add self tests for guard page feature
To: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>,
 Andrew Morton <akpm@linux-foundation.org>
Cc: Suren Baghdasaryan <surenb@google.com>,
 "Liam R . Howlett" <Liam.Howlett@oracle.com>,
 Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
 "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
 David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
 linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
 Richard Henderson <richard.henderson@linaro.org>,
 Ivan Kokshaysky <ink@jurassic.park.msu.ru>, Matt Turner
 <mattst88@gmail.com>, Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
 "James E . J . Bottomley" <James.Bottomley@HansenPartnership.com>,
 Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
 Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
 linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
 linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
 Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
 linux-kselftest@vger.kernel.org, Sidhartha Kumar
 <sidhartha.kumar@oracle.com>, Jeff Xu <jeffxu@chromium.org>,
 Christoph Hellwig <hch@infradead.org>, Shuah Khan <skhan@linuxfoundation.org>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
Content-Language: en-US
From: Shuah Khan <skhan@linuxfoundation.org>
In-Reply-To: <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit

On 10/17/24 14:42, Lorenzo Stoakes wrote:
> Utilise the kselftest harmness to implement tests for the guard page

Splleing NIT - harmness -> harness

> implementation.
> 
> We start by implement basic tests asserting that guard pages can be

implmenting? By the way checkpatch will catch spelling stuuf.
Please see comments about warnings below.

> established (poisoned), cleared (remedied) and that touching poisoned pages
> result in SIGSEGV. We also assert that, in remedying a range, non-poison
> pages remain intact.
> 
> We then examine different operations on regions containing poison markers
> behave to ensure correct behaviour:
> 
> * Operations over multiple VMAs operate as expected.
> * Invoking MADV_GUARD_POISION / MADV_GUARD_REMEDY via process_madvise() in
>    batches works correctly.
> * Ensuring that munmap() correctly tears down poison markers.
> * Using mprotect() to adjust protection bits does not in any way override
>    or cause issues with poison markers.
> * Ensuring that splitting and merging VMAs around poison markers causes no
>    issue - i.e. that a marker which 'belongs' to one VMA can function just
>    as well 'belonging' to another.
> * Ensuring that madvise(..., MADV_DONTNEED) does not remove poison markers.
> * Ensuring that mlock()'ing a range containing poison markers does not
>    cause issues.
> * Ensuring that mremap() can move a poisoned range and retain poison
>    markers.
> * Ensuring that mremap() can expand a poisoned range and retain poison
>    markers (perhaps moving the range).
> * Ensuring that mremap() can shrink a poisoned range and retain poison
>    markers.
> * Ensuring that forking a process correctly retains poison markers.
> * Ensuring that forking a VMA with VM_WIPEONFORK set behaves sanely.
> * Ensuring that lazyfree simply clears poison markers.
> * Ensuring that userfaultfd can co-exist with guard pages.
> * Ensuring that madvise(..., MADV_POPULATE_READ) and
>    madvise(..., MADV_POPULATE_WRITE) error out when encountering
>    poison markers.
> * Ensuring that madvise(..., MADV_COLD) and madvise(..., MADV_PAGEOUT) do
>    not remove poison markers.

Good summary of test. Does the test require root access?
If so does it check and skip appropriately?

> 
> Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
> ---
>   tools/testing/selftests/mm/.gitignore    |    1 +
>   tools/testing/selftests/mm/Makefile      |    1 +
>   tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
>   3 files changed, 1170 insertions(+)
>   create mode 100644 tools/testing/selftests/mm/guard-pages.c
> 
> diff --git a/tools/testing/selftests/mm/.gitignore b/tools/testing/selftests/mm/.gitignore
> index 689bbd520296..8f01f4da1c0d 100644
> --- a/tools/testing/selftests/mm/.gitignore
> +++ b/tools/testing/selftests/mm/.gitignore
> @@ -54,3 +54,4 @@ droppable
>   hugetlb_dio
>   pkey_sighandler_tests_32
>   pkey_sighandler_tests_64
> +guard-pages
> diff --git a/tools/testing/selftests/mm/Makefile b/tools/testing/selftests/mm/Makefile
> index 02e1204971b0..15c734d6cfec 100644
> --- a/tools/testing/selftests/mm/Makefile
> +++ b/tools/testing/selftests/mm/Makefile
> @@ -79,6 +79,7 @@ TEST_GEN_FILES += hugetlb_fault_after_madv
>   TEST_GEN_FILES += hugetlb_madv_vs_map
>   TEST_GEN_FILES += hugetlb_dio
>   TEST_GEN_FILES += droppable
> +TEST_GEN_FILES += guard-pages
>   
>   ifneq ($(ARCH),arm64)
>   TEST_GEN_FILES += soft-dirty
> diff --git a/tools/testing/selftests/mm/guard-pages.c b/tools/testing/selftests/mm/guard-pages.c
> new file mode 100644
> index 000000000000..2ab0ff3ba5a0
> --- /dev/null
> +++ b/tools/testing/selftests/mm/guard-pages.c
> @@ -0,0 +1,1168 @@
> +// SPDX-License-Identifier: GPL-2.0-or-later
> +
> +#define _GNU_SOURCE
> +#include "../kselftest_harness.h"
> +#include <assert.h>
> +#include <fcntl.h>
> +#include <setjmp.h>
> +#include <errno.h>
> +#include <linux/userfaultfd.h>
> +#include <signal.h>
> +#include <stdbool.h>
> +#include <stdio.h>
> +#include <stdlib.h>
> +#include <string.h>
> +#include <sys/ioctl.h>
> +#include <sys/mman.h>
> +#include <sys/syscall.h>
> +#include <sys/uio.h>
> +#include <unistd.h>
> +
> +/* These may not yet be available in the uAPI so define if not. */
> +
> +#ifndef MADV_GUARD_POISON
> +#define MADV_GUARD_POISON	102
> +#endif
> +
> +#ifndef MADV_GUARD_UNPOISON
> +#define MADV_GUARD_UNPOISON	103
> +#endif
> +
> +volatile bool signal_jump_set;

Can you add a comment about why volatile is needed.
By the way did you happen to run checkpatck on this. There are
several instances where single statement blocks with braces {}

I noticed a few and ran checkpatch on your patch. There are
45 warnings regarding codeing style.

Please run checkpatch and clean them up so we can avoid followup
checkpatch cleanup patches.

> +sigjmp_buf signal_jmp_buf;
> +
> +static int userfaultfd(int flags)
> +{
> +	return syscall(SYS_userfaultfd, flags);
> +}
> +
> +static void handle_fatal(int c)
> +{
> +	if (!signal_jump_set)
> +		return;
> +
> +	siglongjmp(signal_jmp_buf, c);
> +}
> +
> +static int pidfd_open(pid_t pid, unsigned int flags)
> +{
> +	return syscall(SYS_pidfd_open, pid, flags);
> +}
> +
> +/*
> + * Enable our signal catcher and try to read/write the specified buffer. The
> + * return value indicates whether the read/write succeeds without a fatal
> + * signal.
> + */
> +static bool try_access_buf(char *ptr, bool write)
> +{
> +	bool failed;
> +
> +	/* Tell signal handler to jump back here on fatal signal. */
> +	signal_jump_set = true;
> +	/* If a fatal signal arose, we will jump back here and failed is set. */
> +	failed = sigsetjmp(signal_jmp_buf, 0) != 0;
> +
> +	if (!failed) {
> +		if (write) {
> +			*ptr = 'x';
> +		} else {
> +			const volatile char *chr = ptr;
> +
> +			/* Force read. */
> +			(void)*chr;
> +		}
> +	}
> +
> +	signal_jump_set = false;
> +	return !failed;
> +}
> +
> +/* Try and read from a buffer, return true if no fatal signal. */
> +static bool try_read_buf(char *ptr)
> +{
> +	return try_access_buf(ptr, false);
> +}
> +
> +/* Try and write to a buffer, return true if no fatal signal. */
> +static bool try_write_buf(char *ptr)
> +{
> +	return try_access_buf(ptr, true);
> +}
> +
> +/*
> + * Try and BOTH read from AND write to a buffer, return true if BOTH operations
> + * succeed.
> + */
> +static bool try_read_write_buf(char *ptr)
> +{
> +	return try_read_buf(ptr) && try_write_buf(ptr);
> +}
> +
> +FIXTURE(guard_pages)
> +{
> +	unsigned long page_size;
> +};
> +
> +FIXTURE_SETUP(guard_pages)
> +{
> +	struct sigaction act = {
> +		.sa_handler = &handle_fatal,
> +		.sa_flags = SA_NODEFER,
> +	};
> +
> +	sigemptyset(&act.sa_mask);
> +	if (sigaction(SIGSEGV, &act, NULL)) {
> +		perror("sigaction");
> +		ksft_exit_fail();

Replase the above two with ksft_exit_fail_perror()
There is no need for perror("sigaction"); followed by
ksft_exit_fail();

> +	}
> +
> +	self->page_size = (unsigned long)sysconf(_SC_PAGESIZE);
> +};
> +
> +FIXTURE_TEARDOWN(guard_pages)
> +{
> +	struct sigaction act = {
> +		.sa_handler = SIG_DFL,
> +		.sa_flags = SA_NODEFER,
> +	};
> +
> +	sigemptyset(&act.sa_mask);
> +	sigaction(SIGSEGV, &act, NULL);
> +}
> +
> +TEST_F(guard_pages, basic)
> +{
> +	const unsigned long NUM_PAGES = 10;
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	int i;
> +
> +	ptr = mmap(NULL, NUM_PAGES * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_PRIVATE | MAP_ANON, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Trivially assert we can touch the first page. */
> +	ASSERT_TRUE(try_read_write_buf(ptr));
> +
> +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Establish that 1st page SIGSEGV's. */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +
> +	/* Ensure we can touch everything else.*/
> +	for (i = 1; i < NUM_PAGES; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Establish a guard page at the end of the mapping. */
> +	ASSERT_EQ(madvise(&ptr[(NUM_PAGES - 1) * page_size], page_size,
> +			  MADV_GUARD_POISON), 0);
> +
> +	/* Check that both guard pages result in SIGSEGV. */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +	ASSERT_FALSE(try_read_write_buf(&ptr[(NUM_PAGES - 1) * page_size]));
> +
> +	/* Unpoison the first. */
> +	ASSERT_FALSE(madvise(ptr, page_size, MADV_GUARD_UNPOISON));
> +
> +	/* Make sure we can touch it. */
> +	ASSERT_TRUE(try_read_write_buf(ptr));
> +
> +	/* Unpoison the last. */
> +	ASSERT_FALSE(madvise(&ptr[(NUM_PAGES - 1) * page_size], page_size,
> +			     MADV_GUARD_UNPOISON));
> +
> +	/* Make sure we can touch it. */
> +	ASSERT_TRUE(try_read_write_buf(&ptr[(NUM_PAGES - 1) * page_size]));
> +
> +	/*
> +	 *  Test setting a _range_ of pages, namely the first 3. The first of
> +	 *  these be faulted in, so this also tests that we can poison backed
> +	 *  pages.
> +	 */
> +	ASSERT_EQ(madvise(ptr, 3 * page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Make sure they are all poisoned. */
> +	for (i = 0; i < 3; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +

This one here and
> +	/* Make sure the rest are not. */
> +	for (i = 3; i < NUM_PAGES; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Unpoison them. */
> +	ASSERT_EQ(madvise(ptr, NUM_PAGES * page_size, MADV_GUARD_UNPOISON), 0);
> +
> +	/* Now make sure we can touch everything. */
> +	for (i = 0; i < NUM_PAGES; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Now unpoison everything, make sure we don't remove existing entries */
> +	ASSERT_EQ(madvise(ptr, NUM_PAGES * page_size, MADV_GUARD_UNPOISON), 0);
> +
> +	for (i = 0; i < NUM_PAGES * page_size; i += page_size) {
> +		ASSERT_EQ(ptr[i], 'x');
> +	}
> +
> +	ASSERT_EQ(munmap(ptr, NUM_PAGES * page_size), 0);
> +}
> +
> +/* Assert that operations applied across multiple VMAs work as expected. */
> +TEST_F(guard_pages, multi_vma)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr_region, *ptr, *ptr1, *ptr2, *ptr3;
> +	int i;
> +
> +	/* Reserve a 100 page region over which we can install VMAs. */
> +	ptr_region = mmap(NULL, 100 * page_size, PROT_NONE,
> +			  MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr_region, MAP_FAILED);
> +
> +	/* Place a VMA of 10 pages size at the start of the region. */
> +	ptr1 = mmap(ptr_region, 10 * page_size, PROT_READ | PROT_WRITE,
> +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr1, MAP_FAILED);
> +
> +	/* Place a VMA of 5 pages size 50 pages into the region. */
> +	ptr2 = mmap(&ptr_region[50 * page_size], 5 * page_size,
> +		    PROT_READ | PROT_WRITE,
> +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr2, MAP_FAILED);
> +
> +	/* Place a VMA of 20 pages size at the end of the region. */
> +	ptr3 = mmap(&ptr_region[80 * page_size], 20 * page_size,
> +		    PROT_READ | PROT_WRITE,
> +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr3, MAP_FAILED);
> +
> +	/* Unmap gaps. */
> +	ASSERT_EQ(munmap(&ptr_region[10 * page_size], 40 * page_size), 0);
> +	ASSERT_EQ(munmap(&ptr_region[55 * page_size], 25 * page_size), 0);
> +
> +	/*
> +	 * We end up with VMAs like this:
> +	 *
> +	 * 0    10 .. 50   55 .. 80   100
> +	 * [---]      [---]      [---]
> +	 */
> +
> +	/* Now poison the whole range and make sure all VMAs are poisoned. */
> +
> +	/*
> +	 * madvise() is certifiable and lets you perform operations over gaps,
> +	 * everything works, but it indicates an error and errno is set to
> +	 * -ENOMEM. Also if anything runs out of memory it is set to
> +	 * -ENOMEM. You are meant to guess which is which.
> +	 */
> +	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_POISON), -1);
> +	ASSERT_EQ(errno, ENOMEM);
> +
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr1[i * page_size]));
> +	}
> +
> +	for (i = 0; i < 5; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr2[i * page_size]));
> +	}
> +
> +	for (i = 0; i < 20; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr3[i * page_size]));
> +	}
> +
> +	/* Now unpoison the range and assert the opposite. */
> +
> +	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_UNPOISON), -1);
> +	ASSERT_EQ(errno, ENOMEM);
> +
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr1[i * page_size]));
> +	}
> +
> +	for (i = 0; i < 5; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr2[i * page_size]));
> +	}
> +
> +	for (i = 0; i < 20; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr3[i * page_size]));
> +	}
> +
> +	/* Now map incompatible VMAs in the gaps. */
> +	ptr = mmap(&ptr_region[10 * page_size], 40 * page_size,
> +		   PROT_READ | PROT_WRITE | PROT_EXEC,
> +		   MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +	ptr = mmap(&ptr_region[55 * page_size], 25 * page_size,
> +		   PROT_READ | PROT_WRITE | PROT_EXEC,
> +		   MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/*
> +	 * We end up with VMAs like this:
> +	 *
> +	 * 0    10 .. 50   55 .. 80   100
> +	 * [---][xxxx][---][xxxx][---]
> +	 *
> +	 * Where 'x' signifies VMAs that cannot be merged with those adjacent to
> +	 * them.
> +	 */
> +
> +	/* Multiple VMAs adjacent to one another should result in no error. */
> +	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_POISON), 0);
> +	for (i = 0; i < 100; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr_region[i * page_size]));
> +	}
> +	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_UNPOISON), 0);
> +	for (i = 0; i < 100; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr_region[i * page_size]));
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr_region, 100 * page_size), 0);
> +}
> +
> +/*
> + * Assert that batched operations performed using process_madvise() work as
> + * expected.
> + */
> +TEST_F(guard_pages, process_madvise)
> +{
> +	const unsigned long page_size = self->page_size;
> +	pid_t pid = getpid();
> +	int pidfd = pidfd_open(pid, 0);
> +	char *ptr_region, *ptr1, *ptr2, *ptr3;
> +	ssize_t count;
> +	struct iovec vec[6];
> +
> +	ASSERT_NE(pidfd, -1);
> +
> +	/* Reserve region to map over. */
> +	ptr_region = mmap(NULL, 100 * page_size, PROT_NONE,
> +			  MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr_region, MAP_FAILED);
> +
> +	/* 10 pages offset 1 page into reserve region. */
> +	ptr1 = mmap(&ptr_region[page_size], 10 * page_size,
> +		    PROT_READ | PROT_WRITE,
> +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr1, MAP_FAILED);
> +	/* We want poison markers at start/end of each VMA. */
> +	vec[0].iov_base = ptr1;
> +	vec[0].iov_len = page_size;
> +	vec[1].iov_base = &ptr1[9 * page_size];
> +	vec[1].iov_len = page_size;
> +
> +	/* 5 pages offset 50 pages into reserve region. */
> +	ptr2 = mmap(&ptr_region[50 * page_size], 5 * page_size,
> +		    PROT_READ | PROT_WRITE,
> +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr2, MAP_FAILED);
> +	vec[2].iov_base = ptr2;
> +	vec[2].iov_len = page_size;
> +	vec[3].iov_base = &ptr2[4 * page_size];
> +	vec[3].iov_len = page_size;
> +
> +	/* 20 pages offset 79 pages into reserve region. */
> +	ptr3 = mmap(&ptr_region[79 * page_size], 20 * page_size,
> +		    PROT_READ | PROT_WRITE,
> +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr3, MAP_FAILED);
> +	vec[4].iov_base = ptr3;
> +	vec[4].iov_len = page_size;
> +	vec[5].iov_base = &ptr3[19 * page_size];
> +	vec[5].iov_len = page_size;
> +
> +	/* Free surrounding VMAs. */
> +	ASSERT_EQ(munmap(ptr_region, page_size), 0);
> +	ASSERT_EQ(munmap(&ptr_region[11 * page_size], 39 * page_size), 0);
> +	ASSERT_EQ(munmap(&ptr_region[55 * page_size], 24 * page_size), 0);
> +	ASSERT_EQ(munmap(&ptr_region[99 * page_size], page_size), 0);
> +
> +	/* Now poison in one step. */
> +	count = process_madvise(pidfd, vec, 6, MADV_GUARD_POISON, 0);
> +
> +	/* OK we don't have permission to do this, skip. */
> +	if (count == -1 && errno == EPERM)
> +		ksft_exit_skip("No process_madvise() permissions\n");

Can you make this a bit more informative? What would user do
if they see this message? Are they supposed to run the test
as root?

> +
> +	/* Returns the number of bytes advised. */
> +	ASSERT_EQ(count, 6 * page_size);
> +
> +	/* Now make sure the poisoning was applied. */
> +
> +	ASSERT_FALSE(try_read_write_buf(ptr1));
> +	ASSERT_FALSE(try_read_write_buf(&ptr1[9 * page_size]));
> +
> +	ASSERT_FALSE(try_read_write_buf(ptr2));
> +	ASSERT_FALSE(try_read_write_buf(&ptr2[4 * page_size]));
> +
> +	ASSERT_FALSE(try_read_write_buf(ptr3));
> +	ASSERT_FALSE(try_read_write_buf(&ptr3[19 * page_size]));
> +
> +	/* Now do the same with unpoison... */
> +	count = process_madvise(pidfd, vec, 6, MADV_GUARD_UNPOISON, 0);
> +
> +	/* ...and everything should now succeed. */
> +
> +	ASSERT_TRUE(try_read_write_buf(ptr1));
> +	ASSERT_TRUE(try_read_write_buf(&ptr1[9 * page_size]));
> +
> +	ASSERT_TRUE(try_read_write_buf(ptr2));
> +	ASSERT_TRUE(try_read_write_buf(&ptr2[4 * page_size]));
> +
> +	ASSERT_TRUE(try_read_write_buf(ptr3));
> +	ASSERT_TRUE(try_read_write_buf(&ptr3[19 * page_size]));
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr1, 10 * page_size), 0);
> +	ASSERT_EQ(munmap(ptr2, 5 * page_size), 0);
> +	ASSERT_EQ(munmap(ptr3, 20 * page_size), 0);
> +	close(pidfd);
> +}
> +
> +/* Assert that unmapping ranges does not leave poison behind. */
> +TEST_F(guard_pages, munmap)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr, *ptr_new1, *ptr_new2;
> +
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Poison first and last pages. */
> +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> +	ASSERT_EQ(madvise(&ptr[9 * page_size], page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Assert that they are poisoned. */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +	ASSERT_FALSE(try_read_write_buf(&ptr[9 * page_size]));
> +
> +	/* Unmap them. */
> +	ASSERT_EQ(munmap(ptr, page_size), 0);
> +	ASSERT_EQ(munmap(&ptr[9 * page_size], page_size), 0);
> +
> +	/* Map over them.*/
> +	ptr_new1 = mmap(ptr, page_size, PROT_READ | PROT_WRITE,
> +			MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr_new1, MAP_FAILED);
> +	ptr_new2 = mmap(&ptr[9 * page_size], page_size, PROT_READ | PROT_WRITE,
> +			MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr_new2, MAP_FAILED);
> +
> +	/* Assert that they are now not poisoned. */
> +	ASSERT_TRUE(try_read_write_buf(ptr_new1));
> +	ASSERT_TRUE(try_read_write_buf(ptr_new2));
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/* Assert that mprotect() operations have no bearing on guard poison markers. */
> +TEST_F(guard_pages, mprotect)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	int i;
> +
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Poison the middle of the range. */
> +	ASSERT_EQ(madvise(&ptr[5 * page_size], 2 * page_size,
> +			  MADV_GUARD_POISON), 0);
> +
> +	/* Assert that it is indeed poisoned. */
> +	ASSERT_FALSE(try_read_write_buf(&ptr[5 * page_size]));
> +	ASSERT_FALSE(try_read_write_buf(&ptr[6 * page_size]));
> +
> +	/* Now make these pages read-only. */
> +	ASSERT_EQ(mprotect(&ptr[5 * page_size], 2 * page_size, PROT_READ), 0);
> +
> +	/* Make sure the range is still poisoned. */
> +	ASSERT_FALSE(try_read_buf(&ptr[5 * page_size]));
> +	ASSERT_FALSE(try_read_buf(&ptr[6 * page_size]));
> +
> +	/* Make sure we can poison again without issue.*/
> +	ASSERT_EQ(madvise(&ptr[5 * page_size], 2 * page_size,
> +			  MADV_GUARD_POISON), 0);
> +
> +	/* Make sure the range is, yet again, still poisoned. */
> +	ASSERT_FALSE(try_read_buf(&ptr[5 * page_size]));
> +	ASSERT_FALSE(try_read_buf(&ptr[6 * page_size]));
> +
> +	/* Now unpoison the whole range. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
> +
> +	/* Make sure the whole range is readable. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_TRUE(try_read_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/* Split and merge VMAs and make sure guard pages still behave. */
> +TEST_F(guard_pages, split_merge)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr, *ptr_new;
> +	int i;
> +
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Poison the whole range. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Make sure the whole range is poisoned. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Now unmap some pages in the range so we split. */
> +	ASSERT_EQ(munmap(&ptr[2 * page_size], page_size), 0);
> +	ASSERT_EQ(munmap(&ptr[5 * page_size], page_size), 0);
> +	ASSERT_EQ(munmap(&ptr[8 * page_size], page_size), 0);
> +
> +	/* Make sure the remaining ranges are poisoned post-split. */
> +	for (i = 0; i < 2; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +	for (i = 2; i < 5; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +	for (i = 6; i < 8; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +	for (i = 9; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Now map them again - the unmap will have cleared the poison. */
> +	ptr_new = mmap(&ptr[2 * page_size], page_size, PROT_READ | PROT_WRITE,
> +		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr_new, MAP_FAILED);
> +	ptr_new = mmap(&ptr[5 * page_size], page_size, PROT_READ | PROT_WRITE,
> +		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr_new, MAP_FAILED);
> +	ptr_new = mmap(&ptr[8 * page_size], page_size, PROT_READ | PROT_WRITE,
> +		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr_new, MAP_FAILED);
> +
> +	/* Now make sure poisoning is as expected. */
> +	for (i = 0; i < 10; i++) {
> +		bool result = try_read_write_buf(&ptr[i * page_size]);
> +
> +		if (i == 2 || i == 5 || i == 8) {
> +			ASSERT_TRUE(result);
> +		} else {
> +			ASSERT_FALSE(result);
> +		}
> +	}
> +
> +	/* Now poison everything again. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Make sure the whole range is poisoned. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Now split the range into three. */
> +	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ), 0);
> +	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size, PROT_READ), 0);
> +
> +	/* Make sure the whole range is poisoned for read. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Now reset protection bits so we merge the whole thing. */
> +	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ | PROT_WRITE), 0);
> +	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size,
> +			   PROT_READ | PROT_WRITE), 0);
> +
> +	/* Make sure the whole range is still poisoned. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Split range into 3 again... */
> +	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ), 0);
> +	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size, PROT_READ), 0);
> +
> +	/* ...and unpoison the whole range. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
> +
> +	/* Make sure the whole range is remedied for read. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_TRUE(try_read_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Merge them again. */
> +	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ | PROT_WRITE), 0);
> +	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size,
> +			   PROT_READ | PROT_WRITE), 0);
> +
> +	/* Now ensure the merged range is remedied for read/write. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/* Assert that MADV_DONTNEED does not remove guard poison markers. */
> +TEST_F(guard_pages, dontneed)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	int i;
> +
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Back the whole range. */
> +	for (i = 0; i < 10; i++) {
> +		ptr[i * page_size] = 'y';
> +	}
> +
> +	/* Poison every other page. */
> +	for (i = 0; i < 10; i += 2) {
> +		ASSERT_EQ(madvise(&ptr[i * page_size],
> +				  page_size, MADV_GUARD_POISON), 0);
> +	}
> +
> +	/* Indicate that we don't need any of the range. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_DONTNEED), 0);
> +
> +	/* Check to ensure poison markers are still in place. */
> +	for (i = 0; i < 10; i++) {
> +		bool result = try_read_buf(&ptr[i * page_size]);
> +
> +		if (i % 2 == 0) {
> +			ASSERT_FALSE(result);
> +		} else {
> +			ASSERT_TRUE(result);
> +			/* Make sure we really did get reset to zero page. */
> +			ASSERT_EQ(ptr[i * page_size], '\0');
> +		}
> +
> +		/* Now write... */
> +		result = try_write_buf(&ptr[i * page_size]);
> +
> +		/* ...and make sure same result. */
> +		if (i % 2 == 0) {

You don't need  { here
> +			ASSERT_FALSE(result);
> +		} else {
> +			ASSERT_TRUE(result);
> +		}

Same here.
  
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/* Assert that mlock()'ed pages work correctly with poison markers. */
> +TEST_F(guard_pages, mlock)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	int i;
> +
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Populate. */
> +	for (i = 0; i < 10; i++) {
> +		ptr[i * page_size] = 'y';
> +	}
> +
> +	/* Lock. */
> +	ASSERT_EQ(mlock(ptr, 10 * page_size), 0);
> +
> +	/* Now try to poison, should fail with EINVAL. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), -1);
> +	ASSERT_EQ(errno, EINVAL);
> +
> +	/* OK unlock. */
> +	ASSERT_EQ(munlock(ptr, 10 * page_size), 0);
> +
> +	/* Poison first half of range, should now succeed. */
> +	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Make sure poison works. */
> +	for (i = 0; i < 10; i++) {
> +		bool result = try_read_write_buf(&ptr[i * page_size]);
> +
> +		if (i < 5) {
> +			ASSERT_FALSE(result);
> +		} else {
> +			ASSERT_TRUE(result);
> +			ASSERT_EQ(ptr[i * page_size], 'x');
> +		}
> +	}
> +
> +	/*
> +	 * Now lock the latter part of the range. We can't lock the poisoned
> +	 * pages, as this would result in the pages being populated and the
> +	 * poisoning would cause this to error out.
> +	 */
> +	ASSERT_EQ(mlock(&ptr[5 * page_size], 5 * page_size), 0);
> +
> +	/*
> +	 * Now unpoison, we do not permit mlock()'d ranges to be remedied as it is
> +	 * a non-destructive operation.
> +	 */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
> +
> +	/* Now check that everything is remedied. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/*
> + * Assert that moving, extending and shrinking memory via mremap() retains
> + * poison markers where possible.
> + *
> + * - Moving a mapping alone should retain markers as they are.
> + */
> +TEST_F(guard_pages, mremap_move)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr, *ptr_new;
> +
> +	/* Map 5 pages. */
> +	ptr = mmap(NULL, 5 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Place poison markers at both ends of the 5 page span. */
> +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> +	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Make sure the poison is in effect. */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> +
> +	/* Map a new region we will move this range into. Doing this ensures
> +	 * that we have reserved a range to map into.
> +	 */
> +	ptr_new = mmap(NULL, 5 * page_size, PROT_NONE, MAP_ANON | MAP_PRIVATE,
> +		       -1, 0);
> +	ASSERT_NE(ptr_new, MAP_FAILED);
> +
> +	ASSERT_EQ(mremap(ptr, 5 * page_size, 5 * page_size,
> +			 MREMAP_MAYMOVE | MREMAP_FIXED, ptr_new), ptr_new);
> +
> +	/* Make sure the poison is retained. */
> +	ASSERT_FALSE(try_read_write_buf(ptr_new));
> +	ASSERT_FALSE(try_read_write_buf(&ptr_new[4 * page_size]));
> +
> +	/*
> +	 * Clean up - we only need reference the new pointer as we overwrote the
> +	 * PROT_NONE range and moved the existing one.
> +	 */
> +	munmap(ptr_new, 5 * page_size);
> +}
> +
> +/*
> + * Assert that moving, extending and shrinking memory via mremap() retains
> + * poison markers where possible.
> + *
> + * - Expanding should retain, only now in different position. The user will have
> + *   to unpoison manually to fix up (they'd have to do the same if it were a
> + *   PROT_NONE mapping)
> + */
> +TEST_F(guard_pages, mremap_expand)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr, *ptr_new;
> +
> +	/* Map 10 pages... */
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +	/* ...But unmap the last 5 so we can ensure we can expand into them. */
> +	ASSERT_EQ(munmap(&ptr[5 * page_size], 5 * page_size), 0);
> +
> +	/* Place poison markers at both ends of the 5 page span. */
> +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> +	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Make sure the poison is in effect. */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> +
> +	/* Now expand to 10 pages. */
> +	ptr = mremap(ptr, 5 * page_size, 10 * page_size, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Make sure the poison is retained in its original positions. */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> +
> +	/* Reserve a region which we can move to and expand into. */
> +	ptr_new = mmap(NULL, 20 * page_size, PROT_NONE,
> +		       MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr_new, MAP_FAILED);
> +
> +	/* Now move and expand into it. */
> +	ptr = mremap(ptr, 10 * page_size, 20 * page_size,
> +		     MREMAP_MAYMOVE | MREMAP_FIXED, ptr_new);
> +	ASSERT_EQ(ptr, ptr_new);
> +
> +	/* Again, make sure the poison is retained in its original
> +	 * positions. */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> +
> +	/*
> +	 * A real user would have to unpoison, but would reasonably expect all
> +	 * characteristics of the mapping to be retained, including poison
> +	 * markers.
> +	 */
> +
> +	/* Cleanup. */
> +	munmap(ptr, 20 * page_size);
> +}
> +/*
> + * Assert that moving, extending and shrinking memory via mremap() retains
> + * poison markers where possible.
> + *
> + * - Shrinking will result in markers that are shrunk over being removed. Again,
> + *   if the user were using a PROT_NONE mapping they'd have to manually fix this
> + *   up also so this is OK.
> + */
> +TEST_F(guard_pages, mremap_shrink)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	int i;
> +
> +	/* Map 5 pages. */
> +	ptr = mmap(NULL, 5 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Place poison markers at both ends of the 5 page span. */
> +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> +	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Make sure the poison is in effect. */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> +
> +	/* Now shrink to 3 pages. */
> +	ptr = mremap(ptr, 5 * page_size, 3 * page_size, MREMAP_MAYMOVE);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* We expect the poison marker at the start to be retained... */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +
> +	/* ...But remaining pages will not have poison markers. */
> +	for (i = 1; i < 3; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr[i + page_size]));
> +	}
> +
> +	/*
> +	 * As with expansion, a real user would have to unpoison and fixup. But
> +	 * you'd have to do similar manual things with PROT_NONE mappings too.
> +	 */
> +
> +	/*
> +	 * If we expand back to the original size, the end marker will, of
> +	 * course, no longer be present.
> +	 */
> +	ptr = mremap(ptr, 3 * page_size, 5 * page_size, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Again, we expect the poison marker at the start to be retained... */
> +	ASSERT_FALSE(try_read_write_buf(ptr));
> +
> +	/* ...But remaining pages will not have poison markers. */
> +	for (i = 1; i < 5; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr[i + page_size]));
> +	}
> +
> +	/* Cleanup. */
> +	munmap(ptr, 5 * page_size);
> +}
> +
> +/*
> + * Assert that forking a process with VMAs that do not have VM_WIPEONFORK set
> + * retain guard pages.
> + */
> +TEST_F(guard_pages, fork)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	pid_t pid;
> +	int i;
> +
> +	/* Map 10 pages. */
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Poison the first 5 pages. */
> +	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
> +
> +	pid = fork();
> +	ASSERT_NE(pid, -1);
> +	if (!pid) {
> +		/* This is the child process now. */
> +
> +		/* Assert that the poisoning is in effect. */
> +		for (i = 0; i < 10; i++) {
> +			bool result = try_read_write_buf(&ptr[i * page_size]);
> +
> +			if (i < 5) {
> +				ASSERT_FALSE(result);
> +			} else {
> +				ASSERT_TRUE(result);
> +			}
> +		}
> +
> +		/* Now unpoison the range.*/
> +		ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
> +
> +		exit(0);
> +	}
> +
> +	/* Parent process. */
> +
> +	/* Parent simply waits on child. */
> +	waitpid(pid, NULL, 0);
> +
> +	/* Child unpoison does not impact parent page table state. */
> +	for (i = 0; i < 10; i++) {
> +		bool result = try_read_write_buf(&ptr[i * page_size]);
> +
> +		if (i < 5) {
> +			ASSERT_FALSE(result);
> +		} else {
> +			ASSERT_TRUE(result);
> +		}
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/*
> + * Assert that forking a process with VMAs that do have VM_WIPEONFORK set
> + * behave as expected.
> + */
> +TEST_F(guard_pages, fork_wipeonfork)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	pid_t pid;
> +	int i;
> +
> +	/* Map 10 pages. */
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Mark wipe on fork. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_WIPEONFORK), 0);
> +
> +	/* Poison the first 5 pages. */
> +	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
> +
> +	pid = fork();
> +	ASSERT_NE(pid, -1);
> +	if (!pid) {
> +		/* This is the child process now. */
> +
> +		/* Poison will have been wiped. */
> +		for (i = 0; i < 10; i++) {
> +			ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> +		}
> +
> +		exit(0);
> +	}
> +
> +	/* Parent process. */
> +
> +	waitpid(pid, NULL, 0);
> +
> +	/* Poison should be in effect.*/
> +	for (i = 0; i < 10; i++) {
> +		bool result = try_read_write_buf(&ptr[i * page_size]);
> +
> +		if (i < 5) {
> +			ASSERT_FALSE(result);
> +		} else {
> +			ASSERT_TRUE(result);
> +		}
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/* Ensure that MADV_FREE frees poison entries as expected. */
> +TEST_F(guard_pages, lazyfree)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	int i;
> +
> +	/* Map 10 pages. */
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Poison range. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Ensure poisoned. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Lazyfree range. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_FREE), 0);
> +
> +	/* This should simply clear the poison markers. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/* Ensure that MADV_POPULATE_READ, MADV_POPULATE_WRITE behave as expected. */
> +TEST_F(guard_pages, populate)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +
> +	/* Map 10 pages. */
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Poison range. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Populate read should error out... */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_POPULATE_READ), -1);
> +	ASSERT_EQ(errno, EFAULT);
> +
> +	/* ...as should populate write. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_POPULATE_WRITE), -1);
> +	ASSERT_EQ(errno, EFAULT);
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/* Ensure that MADV_COLD, MADV_PAGEOUT do not remove poison markers. */
> +TEST_F(guard_pages, cold_pageout)
> +{
> +	const unsigned long page_size = self->page_size;
> +	char *ptr;
> +	int i;
> +
> +	/* Map 10 pages. */
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Poison range. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> +
> +	/* Ensured poisoned. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Now mark cold. This should have no impact on poison markers. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_COLD), 0);
> +
> +	/* Should remain poisoned. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* OK, now page out. This should equally, have no effect on markers. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_PAGEOUT), 0);
> +
> +	/* Should remain poisoned. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +/* Ensure that guard pages do not break userfaultd. */
> +TEST_F(guard_pages, uffd)
> +{
> +	const unsigned long page_size = self->page_size;
> +	int uffd;
> +	char *ptr;
> +	int i;
> +	struct uffdio_api api = {
> +		.api = UFFD_API,
> +		.features = 0,
> +	};
> +	struct uffdio_register reg;
> +	struct uffdio_range range;
> +
> +	/* Set up uffd. */
> +	uffd = userfaultfd(0);
> +	if (uffd == -1 && errno == EPERM)
> +		ksft_exit_skip("No uffd permissions\n");

Same comment here about a user friendly message that say what
user shoul do

> +	ASSERT_NE(uffd, -1);
> +
> +	ASSERT_EQ(ioctl(uffd, UFFDIO_API, &api), 0);
> +
> +	/* Map 10 pages. */
> +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> +	ASSERT_NE(ptr, MAP_FAILED);
> +
> +	/* Register the range with uffd. */
> +	range.start = (unsigned long)ptr;
> +	range.len = 10 * page_size;
> +	reg.range = range;
> +	reg.mode = UFFDIO_REGISTER_MODE_MISSING;
> +	ASSERT_EQ(ioctl(uffd, UFFDIO_REGISTER, &reg), 0);
> +
> +	/* Poison the range. This should not trigger the uffd. */
> +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> +
> +	/* The poisoning should behave as usual with no uffd intervention. */
> +	for (i = 0; i < 10; i++) {
> +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> +	}
> +
> +	/* Cleanup. */
> +	ASSERT_EQ(ioctl(uffd, UFFDIO_UNREGISTER, &range), 0);
> +	close(uffd);
> +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> +}
> +
> +TEST_HARNESS_MAIN

thanks,
-- Shuah


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0a-00069f02.pphosted.com (mx0a-00069f02.pphosted.com [205.220.165.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id D8913178389;
	Fri, 18 Oct 2024 07:13:50 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.165.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729235634; cv=fail; b=b6C6O/Qzz4CFQK0srjc3o/j7kX2VS5HwbvXFssQktTjq19n4SJdnzuex5iwb081aH7jI3N7wskG9GHAEj43MsxEzkz/Jmj4bCWcRcgdjt83LdRn08ule9kPOpIdt3vJ5m7WT1KI0N2xguzjegHF0PBtTQoMglRBAqk4TDNlZ9jI=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729235634; c=relaxed/simple;
	bh=IapYk8BiSE+fzHqoT1g8LMNgY0HHjJOuXRbvy5yb4+M=;
	h=Date:From:To:Cc:Subject:Message-ID:References:Content-Type:
	 Content-Disposition:In-Reply-To:MIME-Version; b=I9KDZMB+NQelzEgf1XC4ZWVgAC6xWc/p64JgwYrI/tUHSfcnbmQVLV59Zw8gAxM3Qfw2fzVIV6neKE2hFo9lrB7DXltUMtshGUX7ZIiU8e43IgjCFgXESkx3rPxyMBDhLUW/uvZovFydoui8QtwcGZhGkA+jpTSsTQJmeAsx8Wc=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=Lt4ebuZf; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=Y5BtN8d/; arc=fail smtp.client-ip=205.220.165.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="Lt4ebuZf";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="Y5BtN8d/"
Received: from pps.filterd (m0246617.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49HNnP71000495;
	Fri, 18 Oct 2024 07:13:00 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-type:date:from:in-reply-to:message-id:mime-version
	:references:subject:to; s=corp-2023-11-20; bh=W2vnaBQk3XevzdlfK4
	ezPRRVe8nFOz7xrAxpN47xCxo=; b=Lt4ebuZfqwBojr/sut+y6JLYTqwM6DC+gw
	4FfbNGuQPYMXaAsPPcgstJadar3pQ6VVLyc6jziQHL8lW6Y/y1Ygq6SvF4lSXt60
	iyLyYNg2SvTq02jXfbzVjV+vaVlbgPVf5K486XMCdjKwtTBqoy0eAHFnE6mDin5l
	O/W8+s2/rDCWEopcWnnIEJvKvOr2mU0frGlZQaKy+gYXiGoc3Bv34aT88PD2EFZ5
	AyDAO5HZ4cvg0GVSVFC50ubdsn1pbzje2EKhQzimKH0rni/J4bKzqNOqQUoCCIGO
	dXNicuf+X47QJ6ZFK7whoTwcLWZF8RKlF1a254maM5lYk0ZJ73mQ==
Received: from iadpaimrmta03.imrmtpd1.prodappiadaev1.oraclevcn.com (iadpaimrmta03.appoci.oracle.com [130.35.103.27])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427hntg3wd-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 07:13:00 +0000 (GMT)
Received: from pps.filterd (iadpaimrmta03.imrmtpd1.prodappiadaev1.oraclevcn.com [127.0.0.1])
	by iadpaimrmta03.imrmtpd1.prodappiadaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49I650wx010406;
	Fri, 18 Oct 2024 07:12:58 GMT
Received: from nam11-co1-obe.outbound.protection.outlook.com (mail-co1nam11lp2169.outbound.protection.outlook.com [104.47.56.169])
	by iadpaimrmta03.imrmtpd1.prodappiadaev1.oraclevcn.com (PPS) with ESMTPS id 427fjhkr1d-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 07:12:58 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=DcRPB7L4xsTljqeszP6xf3ZNR9J+TQT+4c5pzbkmnB5gJWtyiRYZ4OJKrWBKnj0Roh1qlgvCBMapiH9MZ7kl/uLxlz0OJAnjXFwJ1B5aJH4OQZDRa29uNbBJcbpa0b0pBZfKTc5NtMsvsB5KEuxlm0TGQUpvGxJqso4jHeN68wD8xsTnmFUU3enUbQtlpWoGdP5nZkzpHMdshkV2MG8NhxnOpGPqvGUBwHhT0uas0ILzAFU0+6x04seS0sfuBty3ZnSH+r9yGL0N+ooVA5zUJwB7aYe2fqtiEMZrLzAByh5hLfiD/8eNGxbNmYubFIirWIukqR75el97h6nRwNZIwg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=W2vnaBQk3XevzdlfK4ezPRRVe8nFOz7xrAxpN47xCxo=;
 b=wszw+Ft3Ysn+dJH+diLK6W8vFSFCL0k8Zj9DjkOzEAQ1Tbb5Mx9fHsiUEwOcx6hPiPYxPp4Gqi/qtl1LPcy1FtQPr9j2oIRZGhskwDUsq9YFZ65k6hD+q5jmBzB4FeqxeoNomhtBwyBB43YQoXIKphm675V+Q3XZ2gTSaoMROOhfKjJICyGdqlde0rLn6BL3yqCcpXaJRN5A0a8iozls/zpTbTNRF/TCIYO03ZDBSCaR4l75F9E4e4iIObVBqkbbhUp8ih2joCi4bYFXpS0/uaxDhzBMjAZmBjFuHO7jc5sLb/sWRdApSSC2Cw+pmfz4ci6q88RGVrp3QyXxVP+CrA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=W2vnaBQk3XevzdlfK4ezPRRVe8nFOz7xrAxpN47xCxo=;
 b=Y5BtN8d/EX8VqLzFxz5V9iFbYc9pTd0uvkaacbHTkceLqBMrzQNcxz+hWWrVBD1u39sce26uC0F+EC2Bqa+ml8MJe7wPccKezfIGMWaMdW7y7mmunhf7v+XJc4n5X2yUTsfwTk8QIbTGyXO6ekRaSMKcl+oTC8BKvao++6YAU2I=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by SA1PR10MB5821.namprd10.prod.outlook.com (2603:10b6:806:232::19) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.17; Fri, 18 Oct
 2024 07:12:53 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Fri, 18 Oct 2024
 07:12:53 +0000
Date: Fri, 18 Oct 2024 08:12:49 +0100
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Shuah Khan <skhan@linuxfoundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>,
        Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: Re: [PATCH 4/4] selftests/mm: add self tests for guard page feature
Message-ID: <dfbf9ccb-6834-4181-a382-35c9c9af8064@lucifer.local>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
 <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
X-ClientProxiedBy: LO4P265CA0259.GBRP265.PROD.OUTLOOK.COM
 (2603:10a6:600:37c::9) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|SA1PR10MB5821:EE_
X-MS-Office365-Filtering-Correlation-Id: 987472fe-f827-456b-6c21-08dcef444827
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam:
	BCL:0;ARA:13230040|366016|7416014|10070799003|1800799024|376014;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?FHWHPQGr5jh+UuElKKyhkzA3wY9I/vt3Alu97dvHl4rQwA4I/fUg5UwUFXLP?=
 =?us-ascii?Q?DXafM7llevwE9tHvcKDgOTQmS0S02uskTutN172JIgzerFkkgevhyiq+ljsl?=
 =?us-ascii?Q?KgV7QW9TmhsUGyRTWL4v1uUnY2RI23TDBD6mtKgcLfuxHHB6Nrokf9JBv3On?=
 =?us-ascii?Q?FDEpR9WV7s3bFy03Nt2fcrg25j0IzWM8yecJQr+luezqzgIXlcYq1CR/zY+S?=
 =?us-ascii?Q?B3K/3sWZceXBzq/pOvNv0242O1TRVLNxjMEgJU5wuRqy88wAXP4QVW5SxuAT?=
 =?us-ascii?Q?DnSTnGkzgQYY/8KhDezn54Xc3ELmw2UWwvbp0lJBdZwFpKeMnFKdecgHSR9O?=
 =?us-ascii?Q?moRPIGv18m+g13LPvmLHdVixoLyNcwL3QgVl2H94nJpkumPSNrYMrDTlkIB+?=
 =?us-ascii?Q?eyCZYjcHExByCGM3CXDsmbnaOVyhZ53O12VfcSaE9sqArbejPBplSng39NfB?=
 =?us-ascii?Q?+BS8vamnycI92nPqMJbjTGIMz4hXKEo5s+Llampx3+CA8R70foLUSc1arjLQ?=
 =?us-ascii?Q?6K767ujXCbZqO/fhWzIDIHIYtjVYdZEso/TSf2eUZ2za7LkRrSbLa1D98Mak?=
 =?us-ascii?Q?XKLyfL9BbJvnRRRwLrGBswMHaLx4rJLb/gtJWvzx/XTHNnlyYrKET45je4gf?=
 =?us-ascii?Q?Qm4tNmeN/ASGfwb3NfxZbvgB4xHGNIC35+l4m5C1+xvEVTHDGD0F1nLUvBdY?=
 =?us-ascii?Q?I6mgFLwkLk350Qb7wO31WtZ34C7YloNOtmR/MNiEeBL2A1XwigoRTOQ5D1an?=
 =?us-ascii?Q?YGF5u/OhxshRGF7gR9M53V+AmCkaugFc94W0wcdAedjxKUq+k4tpOoR+3XVK?=
 =?us-ascii?Q?v9R320MKWaszeL+OmkBEBpRkM+2Iatu77uXkbGSKsy6YhTEw9e8P9q89SjSv?=
 =?us-ascii?Q?cZPzK6UJnk6vxOo08tQFSgK+p7S6bt44WwAvj1z2XF9326y52xNfl0gCCD2E?=
 =?us-ascii?Q?hDOd0VntXPskqapqLYsQfajD4xA/k8Ht9ayajSdq5/hGREMkvjtzsOS5fhLK?=
 =?us-ascii?Q?XwX6VGP/obLsOcuHBVjKeL735pjcdakRN+FulQU+27c7mt6oMpGz+3EJ7ss3?=
 =?us-ascii?Q?KoN47A2aH4TKlHZswLLx4hKviY9HU4G6HECMsvZqk4aSJkshw9Q0nSzwwcnK?=
 =?us-ascii?Q?sE852kGESmGmsKlN0P3LVOfnapsr3nqkg3IgCSNKb+W05vPkZf4gFTVlv6kq?=
 =?us-ascii?Q?w9AtSKafwx6dKiaWW9zesIGleBpONXyCye0aUAWkyW57gF0kVykKx6vNfL5a?=
 =?us-ascii?Q?IBS+fuvDXSowMuX1pG2iXS04RU9TKj5ykdYMt+NIJVf5R90udz8xv8sXkGQ8?=
 =?us-ascii?Q?hg+KmLPnWiFtwn+ePwElzsXz?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(7416014)(10070799003)(1800799024)(376014);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?RSEzTeMNDDX0r4UlPWLIX0D72e69i++rDagJi4yAjUNXiK1P9QCMyiRupFKw?=
 =?us-ascii?Q?6Tvz08b5Qz2+AGhr4tOYNYphA32LenErahi5PCNgDetft+lZbUNI/1t/S0lI?=
 =?us-ascii?Q?ZkW2vElOZzmoZ6LIiqpT4dd4OZdmV23ILWwNAOVIVRinHDegHb0WeQL1xVNh?=
 =?us-ascii?Q?InOUeRYR/PFGJPhkOwEyJYMDSBANacNmnJ/9lee+FkUTwYX4Wb8a4Deedr7x?=
 =?us-ascii?Q?g0kSojgIi2gb43NXiqrpe+4zRQ8KDtjX5TKH51j12UNgFgyibho/JRnf7Eh+?=
 =?us-ascii?Q?GCFQ6kTR2r61LX417xmxs0M+5gA3cA6Flf1qiidh056kGCT3CFLg7aatjkrY?=
 =?us-ascii?Q?kKXhDfIF1xalFrZMy4ZcvO9H9AAX3JGctxb9SAtk2A+GSuNeKfonZz4c0nkt?=
 =?us-ascii?Q?f6qabYyIyHU4zrCeFdVAsuOwFKRpMCHhz/zmb2mJWjRqvnPq+R7T8R6YriRf?=
 =?us-ascii?Q?n2kLWKR82HpoQ/dz1KNCxuj/SvygwYeBt05BkDLHVtw6ODjz2Fu32RcftJdR?=
 =?us-ascii?Q?wRGQJMIQTG2NniQqjHIW2ZbqBoT05zW7l7PwUCLFXeL3scnAkrqL4yDP3Wx2?=
 =?us-ascii?Q?xRMT9IRaenauvKUHbnMKn9EN6rY6G6qYfPQqi8Q2PjE1Dea2RdJqIWvDXF3e?=
 =?us-ascii?Q?LTMNs85+5opg/EbizFqbDeESuSA4hWn926L/xfYlS/g/4oI0SrqchFwhjVBB?=
 =?us-ascii?Q?zhJ7UtIZQuQQu+E/4Qk0HCMPkljSnR5RVEfNDuclpbsMmDHcqPM66GD6b9WB?=
 =?us-ascii?Q?XbveiFZkm/k4Ke84ajWMRJxw+PorrvXXjqejOpiZEKXCzRFK5N/0xazie8Hm?=
 =?us-ascii?Q?1oibUKxYe2q9B0U6Lo67V6I7yW+02yqWVDCBzOShgfR7eEnAd57K4lRKQfCm?=
 =?us-ascii?Q?vZf+W0YWTq5n1a7EqcMQYxOBEeFvCJs66+5Pzdj97qyRFKExen8IKzFy3cdC?=
 =?us-ascii?Q?muaHkqw2XGjGLqQGuVP6RfOPS+bFNa7zzfXOYkMRr7NDyptE8rN52zw07OHK?=
 =?us-ascii?Q?gCfDyXo08ClD0EyRBn7vGivsk0YMQlsAwjPSQE33WasCBCBfjRB41DWAxwwD?=
 =?us-ascii?Q?nvGuipClkAM06Vx9k9SO4m6PtXcEDprKFESJ6EUYiySyr3XiUWCwPRTDCgS1?=
 =?us-ascii?Q?5/MgRh8bIC2GnkGaLSakJQ+rbWLUDC6rXwOwEKGHY65R15GL4BUDYannj8wq?=
 =?us-ascii?Q?KM31QxVfHrNR88N4oKmCzKuq/SJJkGc872sbDsS9PPHTjG7yZjrr/leOOGdR?=
 =?us-ascii?Q?Jy1lBZDCYxWXzSL67x0fp8Mc1bot6QMNJMx+EJiNobT8p4dEK4570T4OMftD?=
 =?us-ascii?Q?Raag2hSC+XmiVsiBWcMtZHKAdXixtMTge/pCCIzpr89BCyk+bt0s4xzbpAAG?=
 =?us-ascii?Q?mnVSTJnb441NeyYTQa4jDD6gYS9q+2lHvnchYWdMmGMz9fY37FR1EBfbHHny?=
 =?us-ascii?Q?YLFkPXFHFMLccUhxndNBiHnTD06olldKO+kGtExkeHZEIjx089P8DbA7eL6w?=
 =?us-ascii?Q?a2Q0epe+xMUQBiccbqkHrUaXBDjGSv6KBqdcu2lFQNvMJLIO0Qj49MZSWzNE?=
 =?us-ascii?Q?PQ0hY1kCZg/ncaF1FPVdTxpMRUQKY0gWhNaFejtbfeTfKm1L0lUJVS1jJ33P?=
 =?us-ascii?Q?8+Vv4o74CTbrSgYutZgEb6720a9MoDWQv0PJxBRP/pp2+GTHfEtDSLyn9qfn?=
 =?us-ascii?Q?MNpvWw=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	s5Nbja+GYBpbfedDaRs8rx11tdh4FBMS6ZTEOeK5FSH5T6mxG6LuP959aBSGvmvG9e+ErYnIiOrEVU5zFVLhYpfybcrFSoMkLadzHTd+K64KP1FvG1DcieOC/knr43tpsXzWELlQ4xhay9nXyjA6szCkYLxrNk7vrVhMKjf+4T8Fj7Oi+sUhlo5nz1cuRHbk5ICT5Mrpq5VpNL99j+4vyQMSqCefPVjQqTcaAba/rz+WL1C/NDPxg213c5yJ6zMjTvaQHGSuCyr5IZRDRBy045yiy8fb5A9yhJLyt+2+hn/T3vEfNMZovntLWs/Dlt2MIQ2TYr1TZVND6zvUAuMJ8ZKMfs5O2jrNkBW5RLdWuOTy6boBxxvQYfaymNFI9mKmGALLxRRJpUWNvftgqIS8SK8X0CDUXpHnN0Roe8FWc2oHHs5ZMplbp696o7zyWtxRm1rtoCAdmRcjuPbtgPNjpXgir2QA8R/GApXmjxT4SRYzOQ6fiL6Q9YS3EMo6cp8vcbunLl1bZqFJuKPOJ2YI2i+mQPmCoYoTgvgRKD7A6ccRfVu7kAzYjvai0DDowUG1qIwamH8tofYu6sZdgs9CoHQi34x/QLYTtrWvg/NdLFU=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 987472fe-f827-456b-6c21-08dcef444827
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Oct 2024 07:12:53.0047
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: z0Hx0HuBBVtfNLRMMarsd3pO7p/UQka1N7dWli906jKBPtj9y2OKv3DXLKAFdsBWFy/eT/RR5lhPk+Wv1Cq6/61yHBoYFzbbnYbmi6aLVTw=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA1PR10MB5821
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-18_02,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 phishscore=0 malwarescore=0
 adultscore=0 spamscore=0 mlxscore=0 suspectscore=0 bulkscore=0
 mlxlogscore=999 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2409260000 definitions=main-2410180044
X-Proofpoint-ORIG-GUID: mPtsHFRUJLAp8_Nt_y7NvWlhKBIIeug6
X-Proofpoint-GUID: mPtsHFRUJLAp8_Nt_y7NvWlhKBIIeug6

On Thu, Oct 17, 2024 at 03:24:49PM -0600, Shuah Khan wrote:
> On 10/17/24 14:42, Lorenzo Stoakes wrote:
> > Utilise the kselftest harmness to implement tests for the guard page
>
> Splleing NIT - harmness -> harness
>
> > implementation.
> >
> > We start by implement basic tests asserting that guard pages can be
>
> implmenting? By the way checkpatch will catch spelling stuuf.
> Please see comments about warnings below.

Thanks. The majority of the checkpatch warnings are invalid so I missed
this. Will fix on respin.

>
> > established (poisoned), cleared (remedied) and that touching poisoned pages
> > result in SIGSEGV. We also assert that, in remedying a range, non-poison
> > pages remain intact.
> >
> > We then examine different operations on regions containing poison markers
> > behave to ensure correct behaviour:
> >
> > * Operations over multiple VMAs operate as expected.
> > * Invoking MADV_GUARD_POISION / MADV_GUARD_REMEDY via process_madvise() in
> >    batches works correctly.
> > * Ensuring that munmap() correctly tears down poison markers.
> > * Using mprotect() to adjust protection bits does not in any way override
> >    or cause issues with poison markers.
> > * Ensuring that splitting and merging VMAs around poison markers causes no
> >    issue - i.e. that a marker which 'belongs' to one VMA can function just
> >    as well 'belonging' to another.
> > * Ensuring that madvise(..., MADV_DONTNEED) does not remove poison markers.
> > * Ensuring that mlock()'ing a range containing poison markers does not
> >    cause issues.
> > * Ensuring that mremap() can move a poisoned range and retain poison
> >    markers.
> > * Ensuring that mremap() can expand a poisoned range and retain poison
> >    markers (perhaps moving the range).
> > * Ensuring that mremap() can shrink a poisoned range and retain poison
> >    markers.
> > * Ensuring that forking a process correctly retains poison markers.
> > * Ensuring that forking a VMA with VM_WIPEONFORK set behaves sanely.
> > * Ensuring that lazyfree simply clears poison markers.
> > * Ensuring that userfaultfd can co-exist with guard pages.
> > * Ensuring that madvise(..., MADV_POPULATE_READ) and
> >    madvise(..., MADV_POPULATE_WRITE) error out when encountering
> >    poison markers.
> > * Ensuring that madvise(..., MADV_COLD) and madvise(..., MADV_PAGEOUT) do
> >    not remove poison markers.
>
> Good summary of test. Does the test require root access?
> If so does it check and skip appropriately?

Thanks and some do, in those cases we skip.

>
> >
> > Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
> > ---
> >   tools/testing/selftests/mm/.gitignore    |    1 +
> >   tools/testing/selftests/mm/Makefile      |    1 +
> >   tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
> >   3 files changed, 1170 insertions(+)
> >   create mode 100644 tools/testing/selftests/mm/guard-pages.c
> >
> > diff --git a/tools/testing/selftests/mm/.gitignore b/tools/testing/selftests/mm/.gitignore
> > index 689bbd520296..8f01f4da1c0d 100644
> > --- a/tools/testing/selftests/mm/.gitignore
> > +++ b/tools/testing/selftests/mm/.gitignore
> > @@ -54,3 +54,4 @@ droppable
> >   hugetlb_dio
> >   pkey_sighandler_tests_32
> >   pkey_sighandler_tests_64
> > +guard-pages
> > diff --git a/tools/testing/selftests/mm/Makefile b/tools/testing/selftests/mm/Makefile
> > index 02e1204971b0..15c734d6cfec 100644
> > --- a/tools/testing/selftests/mm/Makefile
> > +++ b/tools/testing/selftests/mm/Makefile
> > @@ -79,6 +79,7 @@ TEST_GEN_FILES += hugetlb_fault_after_madv
> >   TEST_GEN_FILES += hugetlb_madv_vs_map
> >   TEST_GEN_FILES += hugetlb_dio
> >   TEST_GEN_FILES += droppable
> > +TEST_GEN_FILES += guard-pages
> >   ifneq ($(ARCH),arm64)
> >   TEST_GEN_FILES += soft-dirty
> > diff --git a/tools/testing/selftests/mm/guard-pages.c b/tools/testing/selftests/mm/guard-pages.c
> > new file mode 100644
> > index 000000000000..2ab0ff3ba5a0
> > --- /dev/null
> > +++ b/tools/testing/selftests/mm/guard-pages.c
> > @@ -0,0 +1,1168 @@
> > +// SPDX-License-Identifier: GPL-2.0-or-later
> > +
> > +#define _GNU_SOURCE
> > +#include "../kselftest_harness.h"
> > +#include <assert.h>
> > +#include <fcntl.h>
> > +#include <setjmp.h>
> > +#include <errno.h>
> > +#include <linux/userfaultfd.h>
> > +#include <signal.h>
> > +#include <stdbool.h>
> > +#include <stdio.h>
> > +#include <stdlib.h>
> > +#include <string.h>
> > +#include <sys/ioctl.h>
> > +#include <sys/mman.h>
> > +#include <sys/syscall.h>
> > +#include <sys/uio.h>
> > +#include <unistd.h>
> > +
> > +/* These may not yet be available in the uAPI so define if not. */
> > +
> > +#ifndef MADV_GUARD_POISON
> > +#define MADV_GUARD_POISON	102
> > +#endif
> > +
> > +#ifndef MADV_GUARD_UNPOISON
> > +#define MADV_GUARD_UNPOISON	103
> > +#endif
> > +
> > +volatile bool signal_jump_set;
>
> Can you add a comment about why volatile is needed.

I'm not sure it's really necessary, it's completely standard to do this
with signal handling and is one of the exceptions to the 'volatile
considered harmful' rule.

> By the way did you happen to run checkpatck on this. There are
> several instances where single statement blocks with braces {}
>
> I noticed a few and ran checkpatch on your patch. There are
> 45 warnings regarding codeing style.
>
> Please run checkpatch and clean them up so we can avoid followup
> checkpatch cleanup patches.

No sorry I won't, checkpatch isn't infallible and series trying to 'clean
up' things that aren't issues will be a waste of everybody's time.

There are cases where removing the braces results in compilation error so
obviously we can't remove them, in others it seriously hurts readability.

>
> > +sigjmp_buf signal_jmp_buf;
> > +
> > +static int userfaultfd(int flags)
> > +{
> > +	return syscall(SYS_userfaultfd, flags);
> > +}
> > +
> > +static void handle_fatal(int c)
> > +{
> > +	if (!signal_jump_set)
> > +		return;
> > +
> > +	siglongjmp(signal_jmp_buf, c);
> > +}
> > +
> > +static int pidfd_open(pid_t pid, unsigned int flags)
> > +{
> > +	return syscall(SYS_pidfd_open, pid, flags);
> > +}
> > +
> > +/*
> > + * Enable our signal catcher and try to read/write the specified buffer. The
> > + * return value indicates whether the read/write succeeds without a fatal
> > + * signal.
> > + */
> > +static bool try_access_buf(char *ptr, bool write)
> > +{
> > +	bool failed;
> > +
> > +	/* Tell signal handler to jump back here on fatal signal. */
> > +	signal_jump_set = true;
> > +	/* If a fatal signal arose, we will jump back here and failed is set. */
> > +	failed = sigsetjmp(signal_jmp_buf, 0) != 0;
> > +
> > +	if (!failed) {
> > +		if (write) {
> > +			*ptr = 'x';
> > +		} else {
> > +			const volatile char *chr = ptr;
> > +
> > +			/* Force read. */
> > +			(void)*chr;
> > +		}
> > +	}
> > +
> > +	signal_jump_set = false;
> > +	return !failed;
> > +}
> > +
> > +/* Try and read from a buffer, return true if no fatal signal. */
> > +static bool try_read_buf(char *ptr)
> > +{
> > +	return try_access_buf(ptr, false);
> > +}
> > +
> > +/* Try and write to a buffer, return true if no fatal signal. */
> > +static bool try_write_buf(char *ptr)
> > +{
> > +	return try_access_buf(ptr, true);
> > +}
> > +
> > +/*
> > + * Try and BOTH read from AND write to a buffer, return true if BOTH operations
> > + * succeed.
> > + */
> > +static bool try_read_write_buf(char *ptr)
> > +{
> > +	return try_read_buf(ptr) && try_write_buf(ptr);
> > +}
> > +
> > +FIXTURE(guard_pages)
> > +{
> > +	unsigned long page_size;
> > +};
> > +
> > +FIXTURE_SETUP(guard_pages)
> > +{
> > +	struct sigaction act = {
> > +		.sa_handler = &handle_fatal,
> > +		.sa_flags = SA_NODEFER,
> > +	};
> > +
> > +	sigemptyset(&act.sa_mask);
> > +	if (sigaction(SIGSEGV, &act, NULL)) {
> > +		perror("sigaction");
> > +		ksft_exit_fail();
>
> Replase the above two with ksft_exit_fail_perror()
> There is no need for perror("sigaction"); followed by
> ksft_exit_fail();

Ack will do on respin. Thanks for the tip! Wasn't aware of that.

>
> > +	}
> > +
> > +	self->page_size = (unsigned long)sysconf(_SC_PAGESIZE);
> > +};
> > +
> > +FIXTURE_TEARDOWN(guard_pages)
> > +{
> > +	struct sigaction act = {
> > +		.sa_handler = SIG_DFL,
> > +		.sa_flags = SA_NODEFER,
> > +	};
> > +
> > +	sigemptyset(&act.sa_mask);
> > +	sigaction(SIGSEGV, &act, NULL);
> > +}
> > +
> > +TEST_F(guard_pages, basic)
> > +{
> > +	const unsigned long NUM_PAGES = 10;
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	int i;
> > +
> > +	ptr = mmap(NULL, NUM_PAGES * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_PRIVATE | MAP_ANON, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Trivially assert we can touch the first page. */
> > +	ASSERT_TRUE(try_read_write_buf(ptr));
> > +
> > +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Establish that 1st page SIGSEGV's. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +
> > +	/* Ensure we can touch everything else.*/
> > +	for (i = 1; i < NUM_PAGES; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Establish a guard page at the end of the mapping. */
> > +	ASSERT_EQ(madvise(&ptr[(NUM_PAGES - 1) * page_size], page_size,
> > +			  MADV_GUARD_POISON), 0);
> > +
> > +	/* Check that both guard pages result in SIGSEGV. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[(NUM_PAGES - 1) * page_size]));
> > +
> > +	/* Unpoison the first. */
> > +	ASSERT_FALSE(madvise(ptr, page_size, MADV_GUARD_UNPOISON));
> > +
> > +	/* Make sure we can touch it. */
> > +	ASSERT_TRUE(try_read_write_buf(ptr));
> > +
> > +	/* Unpoison the last. */
> > +	ASSERT_FALSE(madvise(&ptr[(NUM_PAGES - 1) * page_size], page_size,
> > +			     MADV_GUARD_UNPOISON));
> > +
> > +	/* Make sure we can touch it. */
> > +	ASSERT_TRUE(try_read_write_buf(&ptr[(NUM_PAGES - 1) * page_size]));
> > +
> > +	/*
> > +	 *  Test setting a _range_ of pages, namely the first 3. The first of
> > +	 *  these be faulted in, so this also tests that we can poison backed
> > +	 *  pages.
> > +	 */
> > +	ASSERT_EQ(madvise(ptr, 3 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Make sure they are all poisoned. */
> > +	for (i = 0; i < 3; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
>
> This one here and

Refer you to other comments around this, it hurts readability to do that.

> > +	/* Make sure the rest are not. */
> > +	for (i = 3; i < NUM_PAGES; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Unpoison them. */
> > +	ASSERT_EQ(madvise(ptr, NUM_PAGES * page_size, MADV_GUARD_UNPOISON), 0);
> > +
> > +	/* Now make sure we can touch everything. */
> > +	for (i = 0; i < NUM_PAGES; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Now unpoison everything, make sure we don't remove existing entries */
> > +	ASSERT_EQ(madvise(ptr, NUM_PAGES * page_size, MADV_GUARD_UNPOISON), 0);
> > +
> > +	for (i = 0; i < NUM_PAGES * page_size; i += page_size) {
> > +		ASSERT_EQ(ptr[i], 'x');
> > +	}
> > +
> > +	ASSERT_EQ(munmap(ptr, NUM_PAGES * page_size), 0);
> > +}
> > +
> > +/* Assert that operations applied across multiple VMAs work as expected. */
> > +TEST_F(guard_pages, multi_vma)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr_region, *ptr, *ptr1, *ptr2, *ptr3;
> > +	int i;
> > +
> > +	/* Reserve a 100 page region over which we can install VMAs. */
> > +	ptr_region = mmap(NULL, 100 * page_size, PROT_NONE,
> > +			  MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr_region, MAP_FAILED);
> > +
> > +	/* Place a VMA of 10 pages size at the start of the region. */
> > +	ptr1 = mmap(ptr_region, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr1, MAP_FAILED);
> > +
> > +	/* Place a VMA of 5 pages size 50 pages into the region. */
> > +	ptr2 = mmap(&ptr_region[50 * page_size], 5 * page_size,
> > +		    PROT_READ | PROT_WRITE,
> > +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr2, MAP_FAILED);
> > +
> > +	/* Place a VMA of 20 pages size at the end of the region. */
> > +	ptr3 = mmap(&ptr_region[80 * page_size], 20 * page_size,
> > +		    PROT_READ | PROT_WRITE,
> > +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr3, MAP_FAILED);
> > +
> > +	/* Unmap gaps. */
> > +	ASSERT_EQ(munmap(&ptr_region[10 * page_size], 40 * page_size), 0);
> > +	ASSERT_EQ(munmap(&ptr_region[55 * page_size], 25 * page_size), 0);
> > +
> > +	/*
> > +	 * We end up with VMAs like this:
> > +	 *
> > +	 * 0    10 .. 50   55 .. 80   100
> > +	 * [---]      [---]      [---]
> > +	 */
> > +
> > +	/* Now poison the whole range and make sure all VMAs are poisoned. */
> > +
> > +	/*
> > +	 * madvise() is certifiable and lets you perform operations over gaps,
> > +	 * everything works, but it indicates an error and errno is set to
> > +	 * -ENOMEM. Also if anything runs out of memory it is set to
> > +	 * -ENOMEM. You are meant to guess which is which.
> > +	 */
> > +	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_POISON), -1);
> > +	ASSERT_EQ(errno, ENOMEM);
> > +
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr1[i * page_size]));
> > +	}
> > +
> > +	for (i = 0; i < 5; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr2[i * page_size]));
> > +	}
> > +
> > +	for (i = 0; i < 20; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr3[i * page_size]));
> > +	}
> > +
> > +	/* Now unpoison the range and assert the opposite. */
> > +
> > +	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_UNPOISON), -1);
> > +	ASSERT_EQ(errno, ENOMEM);
> > +
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr1[i * page_size]));
> > +	}
> > +
> > +	for (i = 0; i < 5; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr2[i * page_size]));
> > +	}
> > +
> > +	for (i = 0; i < 20; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr3[i * page_size]));
> > +	}
> > +
> > +	/* Now map incompatible VMAs in the gaps. */
> > +	ptr = mmap(&ptr_region[10 * page_size], 40 * page_size,
> > +		   PROT_READ | PROT_WRITE | PROT_EXEC,
> > +		   MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +	ptr = mmap(&ptr_region[55 * page_size], 25 * page_size,
> > +		   PROT_READ | PROT_WRITE | PROT_EXEC,
> > +		   MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/*
> > +	 * We end up with VMAs like this:
> > +	 *
> > +	 * 0    10 .. 50   55 .. 80   100
> > +	 * [---][xxxx][---][xxxx][---]
> > +	 *
> > +	 * Where 'x' signifies VMAs that cannot be merged with those adjacent to
> > +	 * them.
> > +	 */
> > +
> > +	/* Multiple VMAs adjacent to one another should result in no error. */
> > +	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_POISON), 0);
> > +	for (i = 0; i < 100; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr_region[i * page_size]));
> > +	}
> > +	ASSERT_EQ(madvise(ptr_region, 100 * page_size, MADV_GUARD_UNPOISON), 0);
> > +	for (i = 0; i < 100; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr_region[i * page_size]));
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr_region, 100 * page_size), 0);
> > +}
> > +
> > +/*
> > + * Assert that batched operations performed using process_madvise() work as
> > + * expected.
> > + */
> > +TEST_F(guard_pages, process_madvise)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	pid_t pid = getpid();
> > +	int pidfd = pidfd_open(pid, 0);
> > +	char *ptr_region, *ptr1, *ptr2, *ptr3;
> > +	ssize_t count;
> > +	struct iovec vec[6];
> > +
> > +	ASSERT_NE(pidfd, -1);
> > +
> > +	/* Reserve region to map over. */
> > +	ptr_region = mmap(NULL, 100 * page_size, PROT_NONE,
> > +			  MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr_region, MAP_FAILED);
> > +
> > +	/* 10 pages offset 1 page into reserve region. */
> > +	ptr1 = mmap(&ptr_region[page_size], 10 * page_size,
> > +		    PROT_READ | PROT_WRITE,
> > +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr1, MAP_FAILED);
> > +	/* We want poison markers at start/end of each VMA. */
> > +	vec[0].iov_base = ptr1;
> > +	vec[0].iov_len = page_size;
> > +	vec[1].iov_base = &ptr1[9 * page_size];
> > +	vec[1].iov_len = page_size;
> > +
> > +	/* 5 pages offset 50 pages into reserve region. */
> > +	ptr2 = mmap(&ptr_region[50 * page_size], 5 * page_size,
> > +		    PROT_READ | PROT_WRITE,
> > +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr2, MAP_FAILED);
> > +	vec[2].iov_base = ptr2;
> > +	vec[2].iov_len = page_size;
> > +	vec[3].iov_base = &ptr2[4 * page_size];
> > +	vec[3].iov_len = page_size;
> > +
> > +	/* 20 pages offset 79 pages into reserve region. */
> > +	ptr3 = mmap(&ptr_region[79 * page_size], 20 * page_size,
> > +		    PROT_READ | PROT_WRITE,
> > +		    MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr3, MAP_FAILED);
> > +	vec[4].iov_base = ptr3;
> > +	vec[4].iov_len = page_size;
> > +	vec[5].iov_base = &ptr3[19 * page_size];
> > +	vec[5].iov_len = page_size;
> > +
> > +	/* Free surrounding VMAs. */
> > +	ASSERT_EQ(munmap(ptr_region, page_size), 0);
> > +	ASSERT_EQ(munmap(&ptr_region[11 * page_size], 39 * page_size), 0);
> > +	ASSERT_EQ(munmap(&ptr_region[55 * page_size], 24 * page_size), 0);
> > +	ASSERT_EQ(munmap(&ptr_region[99 * page_size], page_size), 0);
> > +
> > +	/* Now poison in one step. */
> > +	count = process_madvise(pidfd, vec, 6, MADV_GUARD_POISON, 0);
> > +
> > +	/* OK we don't have permission to do this, skip. */
> > +	if (count == -1 && errno == EPERM)
> > +		ksft_exit_skip("No process_madvise() permissions\n");
>
> Can you make this a bit more informative? What would user do
> if they see this message? Are they supposed to run the test
> as root?

OK can update on respin.

>
> > +
> > +	/* Returns the number of bytes advised. */
> > +	ASSERT_EQ(count, 6 * page_size);
> > +
> > +	/* Now make sure the poisoning was applied. */
> > +
> > +	ASSERT_FALSE(try_read_write_buf(ptr1));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr1[9 * page_size]));
> > +
> > +	ASSERT_FALSE(try_read_write_buf(ptr2));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr2[4 * page_size]));
> > +
> > +	ASSERT_FALSE(try_read_write_buf(ptr3));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr3[19 * page_size]));
> > +
> > +	/* Now do the same with unpoison... */
> > +	count = process_madvise(pidfd, vec, 6, MADV_GUARD_UNPOISON, 0);
> > +
> > +	/* ...and everything should now succeed. */
> > +
> > +	ASSERT_TRUE(try_read_write_buf(ptr1));
> > +	ASSERT_TRUE(try_read_write_buf(&ptr1[9 * page_size]));
> > +
> > +	ASSERT_TRUE(try_read_write_buf(ptr2));
> > +	ASSERT_TRUE(try_read_write_buf(&ptr2[4 * page_size]));
> > +
> > +	ASSERT_TRUE(try_read_write_buf(ptr3));
> > +	ASSERT_TRUE(try_read_write_buf(&ptr3[19 * page_size]));
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr1, 10 * page_size), 0);
> > +	ASSERT_EQ(munmap(ptr2, 5 * page_size), 0);
> > +	ASSERT_EQ(munmap(ptr3, 20 * page_size), 0);
> > +	close(pidfd);
> > +}
> > +
> > +/* Assert that unmapping ranges does not leave poison behind. */
> > +TEST_F(guard_pages, munmap)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr, *ptr_new1, *ptr_new2;
> > +
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Poison first and last pages. */
> > +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> > +	ASSERT_EQ(madvise(&ptr[9 * page_size], page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Assert that they are poisoned. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[9 * page_size]));
> > +
> > +	/* Unmap them. */
> > +	ASSERT_EQ(munmap(ptr, page_size), 0);
> > +	ASSERT_EQ(munmap(&ptr[9 * page_size], page_size), 0);
> > +
> > +	/* Map over them.*/
> > +	ptr_new1 = mmap(ptr, page_size, PROT_READ | PROT_WRITE,
> > +			MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr_new1, MAP_FAILED);
> > +	ptr_new2 = mmap(&ptr[9 * page_size], page_size, PROT_READ | PROT_WRITE,
> > +			MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr_new2, MAP_FAILED);
> > +
> > +	/* Assert that they are now not poisoned. */
> > +	ASSERT_TRUE(try_read_write_buf(ptr_new1));
> > +	ASSERT_TRUE(try_read_write_buf(ptr_new2));
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/* Assert that mprotect() operations have no bearing on guard poison markers. */
> > +TEST_F(guard_pages, mprotect)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	int i;
> > +
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Poison the middle of the range. */
> > +	ASSERT_EQ(madvise(&ptr[5 * page_size], 2 * page_size,
> > +			  MADV_GUARD_POISON), 0);
> > +
> > +	/* Assert that it is indeed poisoned. */
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[5 * page_size]));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[6 * page_size]));
> > +
> > +	/* Now make these pages read-only. */
> > +	ASSERT_EQ(mprotect(&ptr[5 * page_size], 2 * page_size, PROT_READ), 0);
> > +
> > +	/* Make sure the range is still poisoned. */
> > +	ASSERT_FALSE(try_read_buf(&ptr[5 * page_size]));
> > +	ASSERT_FALSE(try_read_buf(&ptr[6 * page_size]));
> > +
> > +	/* Make sure we can poison again without issue.*/
> > +	ASSERT_EQ(madvise(&ptr[5 * page_size], 2 * page_size,
> > +			  MADV_GUARD_POISON), 0);
> > +
> > +	/* Make sure the range is, yet again, still poisoned. */
> > +	ASSERT_FALSE(try_read_buf(&ptr[5 * page_size]));
> > +	ASSERT_FALSE(try_read_buf(&ptr[6 * page_size]));
> > +
> > +	/* Now unpoison the whole range. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
> > +
> > +	/* Make sure the whole range is readable. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_TRUE(try_read_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/* Split and merge VMAs and make sure guard pages still behave. */
> > +TEST_F(guard_pages, split_merge)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr, *ptr_new;
> > +	int i;
> > +
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Poison the whole range. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Make sure the whole range is poisoned. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Now unmap some pages in the range so we split. */
> > +	ASSERT_EQ(munmap(&ptr[2 * page_size], page_size), 0);
> > +	ASSERT_EQ(munmap(&ptr[5 * page_size], page_size), 0);
> > +	ASSERT_EQ(munmap(&ptr[8 * page_size], page_size), 0);
> > +
> > +	/* Make sure the remaining ranges are poisoned post-split. */
> > +	for (i = 0; i < 2; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +	for (i = 2; i < 5; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +	for (i = 6; i < 8; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +	for (i = 9; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Now map them again - the unmap will have cleared the poison. */
> > +	ptr_new = mmap(&ptr[2 * page_size], page_size, PROT_READ | PROT_WRITE,
> > +		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr_new, MAP_FAILED);
> > +	ptr_new = mmap(&ptr[5 * page_size], page_size, PROT_READ | PROT_WRITE,
> > +		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr_new, MAP_FAILED);
> > +	ptr_new = mmap(&ptr[8 * page_size], page_size, PROT_READ | PROT_WRITE,
> > +		       MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr_new, MAP_FAILED);
> > +
> > +	/* Now make sure poisoning is as expected. */
> > +	for (i = 0; i < 10; i++) {
> > +		bool result = try_read_write_buf(&ptr[i * page_size]);
> > +
> > +		if (i == 2 || i == 5 || i == 8) {
> > +			ASSERT_TRUE(result);
> > +		} else {
> > +			ASSERT_FALSE(result);
> > +		}
> > +	}
> > +
> > +	/* Now poison everything again. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Make sure the whole range is poisoned. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Now split the range into three. */
> > +	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ), 0);
> > +	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size, PROT_READ), 0);
> > +
> > +	/* Make sure the whole range is poisoned for read. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Now reset protection bits so we merge the whole thing. */
> > +	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ | PROT_WRITE), 0);
> > +	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size,
> > +			   PROT_READ | PROT_WRITE), 0);
> > +
> > +	/* Make sure the whole range is still poisoned. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Split range into 3 again... */
> > +	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ), 0);
> > +	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size, PROT_READ), 0);
> > +
> > +	/* ...and unpoison the whole range. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
> > +
> > +	/* Make sure the whole range is remedied for read. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_TRUE(try_read_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Merge them again. */
> > +	ASSERT_EQ(mprotect(ptr, 3 * page_size, PROT_READ | PROT_WRITE), 0);
> > +	ASSERT_EQ(mprotect(&ptr[7 * page_size], 3 * page_size,
> > +			   PROT_READ | PROT_WRITE), 0);
> > +
> > +	/* Now ensure the merged range is remedied for read/write. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/* Assert that MADV_DONTNEED does not remove guard poison markers. */
> > +TEST_F(guard_pages, dontneed)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	int i;
> > +
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Back the whole range. */
> > +	for (i = 0; i < 10; i++) {
> > +		ptr[i * page_size] = 'y';
> > +	}
> > +
> > +	/* Poison every other page. */
> > +	for (i = 0; i < 10; i += 2) {
> > +		ASSERT_EQ(madvise(&ptr[i * page_size],
> > +				  page_size, MADV_GUARD_POISON), 0);
> > +	}
> > +
> > +	/* Indicate that we don't need any of the range. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_DONTNEED), 0);
> > +
> > +	/* Check to ensure poison markers are still in place. */
> > +	for (i = 0; i < 10; i++) {
> > +		bool result = try_read_buf(&ptr[i * page_size]);
> > +
> > +		if (i % 2 == 0) {
> > +			ASSERT_FALSE(result);
> > +		} else {
> > +			ASSERT_TRUE(result);
> > +			/* Make sure we really did get reset to zero page. */
> > +			ASSERT_EQ(ptr[i * page_size], '\0');
> > +		}
> > +
> > +		/* Now write... */
> > +		result = try_write_buf(&ptr[i * page_size]);
> > +
> > +		/* ...and make sure same result. */
> > +		if (i % 2 == 0) {
>
> You don't need  { here
> > +			ASSERT_FALSE(result);
> > +		} else {
> > +			ASSERT_TRUE(result);
> > +		}
>
> Same here.

Removing these results in compilation failure so we can't :) this is
probably/possibly a bug in how the assert macros work but fixing that is
out of scope for this series.

> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/* Assert that mlock()'ed pages work correctly with poison markers. */
> > +TEST_F(guard_pages, mlock)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	int i;
> > +
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Populate. */
> > +	for (i = 0; i < 10; i++) {
> > +		ptr[i * page_size] = 'y';
> > +	}
> > +
> > +	/* Lock. */
> > +	ASSERT_EQ(mlock(ptr, 10 * page_size), 0);
> > +
> > +	/* Now try to poison, should fail with EINVAL. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), -1);
> > +	ASSERT_EQ(errno, EINVAL);
> > +
> > +	/* OK unlock. */
> > +	ASSERT_EQ(munlock(ptr, 10 * page_size), 0);
> > +
> > +	/* Poison first half of range, should now succeed. */
> > +	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Make sure poison works. */
> > +	for (i = 0; i < 10; i++) {
> > +		bool result = try_read_write_buf(&ptr[i * page_size]);
> > +
> > +		if (i < 5) {
> > +			ASSERT_FALSE(result);
> > +		} else {
> > +			ASSERT_TRUE(result);
> > +			ASSERT_EQ(ptr[i * page_size], 'x');
> > +		}
> > +	}
> > +
> > +	/*
> > +	 * Now lock the latter part of the range. We can't lock the poisoned
> > +	 * pages, as this would result in the pages being populated and the
> > +	 * poisoning would cause this to error out.
> > +	 */
> > +	ASSERT_EQ(mlock(&ptr[5 * page_size], 5 * page_size), 0);
> > +
> > +	/*
> > +	 * Now unpoison, we do not permit mlock()'d ranges to be remedied as it is
> > +	 * a non-destructive operation.
> > +	 */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
> > +
> > +	/* Now check that everything is remedied. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/*
> > + * Assert that moving, extending and shrinking memory via mremap() retains
> > + * poison markers where possible.
> > + *
> > + * - Moving a mapping alone should retain markers as they are.
> > + */
> > +TEST_F(guard_pages, mremap_move)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr, *ptr_new;
> > +
> > +	/* Map 5 pages. */
> > +	ptr = mmap(NULL, 5 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Place poison markers at both ends of the 5 page span. */
> > +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> > +	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Make sure the poison is in effect. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> > +
> > +	/* Map a new region we will move this range into. Doing this ensures
> > +	 * that we have reserved a range to map into.
> > +	 */
> > +	ptr_new = mmap(NULL, 5 * page_size, PROT_NONE, MAP_ANON | MAP_PRIVATE,
> > +		       -1, 0);
> > +	ASSERT_NE(ptr_new, MAP_FAILED);
> > +
> > +	ASSERT_EQ(mremap(ptr, 5 * page_size, 5 * page_size,
> > +			 MREMAP_MAYMOVE | MREMAP_FIXED, ptr_new), ptr_new);
> > +
> > +	/* Make sure the poison is retained. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr_new));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr_new[4 * page_size]));
> > +
> > +	/*
> > +	 * Clean up - we only need reference the new pointer as we overwrote the
> > +	 * PROT_NONE range and moved the existing one.
> > +	 */
> > +	munmap(ptr_new, 5 * page_size);
> > +}
> > +
> > +/*
> > + * Assert that moving, extending and shrinking memory via mremap() retains
> > + * poison markers where possible.
> > + *
> > + * - Expanding should retain, only now in different position. The user will have
> > + *   to unpoison manually to fix up (they'd have to do the same if it were a
> > + *   PROT_NONE mapping)
> > + */
> > +TEST_F(guard_pages, mremap_expand)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr, *ptr_new;
> > +
> > +	/* Map 10 pages... */
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +	/* ...But unmap the last 5 so we can ensure we can expand into them. */
> > +	ASSERT_EQ(munmap(&ptr[5 * page_size], 5 * page_size), 0);
> > +
> > +	/* Place poison markers at both ends of the 5 page span. */
> > +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> > +	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Make sure the poison is in effect. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> > +
> > +	/* Now expand to 10 pages. */
> > +	ptr = mremap(ptr, 5 * page_size, 10 * page_size, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Make sure the poison is retained in its original positions. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> > +
> > +	/* Reserve a region which we can move to and expand into. */
> > +	ptr_new = mmap(NULL, 20 * page_size, PROT_NONE,
> > +		       MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr_new, MAP_FAILED);
> > +
> > +	/* Now move and expand into it. */
> > +	ptr = mremap(ptr, 10 * page_size, 20 * page_size,
> > +		     MREMAP_MAYMOVE | MREMAP_FIXED, ptr_new);
> > +	ASSERT_EQ(ptr, ptr_new);
> > +
> > +	/* Again, make sure the poison is retained in its original
> > +	 * positions. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> > +
> > +	/*
> > +	 * A real user would have to unpoison, but would reasonably expect all
> > +	 * characteristics of the mapping to be retained, including poison
> > +	 * markers.
> > +	 */
> > +
> > +	/* Cleanup. */
> > +	munmap(ptr, 20 * page_size);
> > +}
> > +/*
> > + * Assert that moving, extending and shrinking memory via mremap() retains
> > + * poison markers where possible.
> > + *
> > + * - Shrinking will result in markers that are shrunk over being removed. Again,
> > + *   if the user were using a PROT_NONE mapping they'd have to manually fix this
> > + *   up also so this is OK.
> > + */
> > +TEST_F(guard_pages, mremap_shrink)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	int i;
> > +
> > +	/* Map 5 pages. */
> > +	ptr = mmap(NULL, 5 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Place poison markers at both ends of the 5 page span. */
> > +	ASSERT_EQ(madvise(ptr, page_size, MADV_GUARD_POISON), 0);
> > +	ASSERT_EQ(madvise(&ptr[4 * page_size], page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Make sure the poison is in effect. */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +	ASSERT_FALSE(try_read_write_buf(&ptr[4 * page_size]));
> > +
> > +	/* Now shrink to 3 pages. */
> > +	ptr = mremap(ptr, 5 * page_size, 3 * page_size, MREMAP_MAYMOVE);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* We expect the poison marker at the start to be retained... */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +
> > +	/* ...But remaining pages will not have poison markers. */
> > +	for (i = 1; i < 3; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr[i + page_size]));
> > +	}
> > +
> > +	/*
> > +	 * As with expansion, a real user would have to unpoison and fixup. But
> > +	 * you'd have to do similar manual things with PROT_NONE mappings too.
> > +	 */
> > +
> > +	/*
> > +	 * If we expand back to the original size, the end marker will, of
> > +	 * course, no longer be present.
> > +	 */
> > +	ptr = mremap(ptr, 3 * page_size, 5 * page_size, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Again, we expect the poison marker at the start to be retained... */
> > +	ASSERT_FALSE(try_read_write_buf(ptr));
> > +
> > +	/* ...But remaining pages will not have poison markers. */
> > +	for (i = 1; i < 5; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr[i + page_size]));
> > +	}
> > +
> > +	/* Cleanup. */
> > +	munmap(ptr, 5 * page_size);
> > +}
> > +
> > +/*
> > + * Assert that forking a process with VMAs that do not have VM_WIPEONFORK set
> > + * retain guard pages.
> > + */
> > +TEST_F(guard_pages, fork)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	pid_t pid;
> > +	int i;
> > +
> > +	/* Map 10 pages. */
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Poison the first 5 pages. */
> > +	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	pid = fork();
> > +	ASSERT_NE(pid, -1);
> > +	if (!pid) {
> > +		/* This is the child process now. */
> > +
> > +		/* Assert that the poisoning is in effect. */
> > +		for (i = 0; i < 10; i++) {
> > +			bool result = try_read_write_buf(&ptr[i * page_size]);
> > +
> > +			if (i < 5) {
> > +				ASSERT_FALSE(result);
> > +			} else {
> > +				ASSERT_TRUE(result);
> > +			}
> > +		}
> > +
> > +		/* Now unpoison the range.*/
> > +		ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_UNPOISON), 0);
> > +
> > +		exit(0);
> > +	}
> > +
> > +	/* Parent process. */
> > +
> > +	/* Parent simply waits on child. */
> > +	waitpid(pid, NULL, 0);
> > +
> > +	/* Child unpoison does not impact parent page table state. */
> > +	for (i = 0; i < 10; i++) {
> > +		bool result = try_read_write_buf(&ptr[i * page_size]);
> > +
> > +		if (i < 5) {
> > +			ASSERT_FALSE(result);
> > +		} else {
> > +			ASSERT_TRUE(result);
> > +		}
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/*
> > + * Assert that forking a process with VMAs that do have VM_WIPEONFORK set
> > + * behave as expected.
> > + */
> > +TEST_F(guard_pages, fork_wipeonfork)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	pid_t pid;
> > +	int i;
> > +
> > +	/* Map 10 pages. */
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Mark wipe on fork. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_WIPEONFORK), 0);
> > +
> > +	/* Poison the first 5 pages. */
> > +	ASSERT_EQ(madvise(ptr, 5 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	pid = fork();
> > +	ASSERT_NE(pid, -1);
> > +	if (!pid) {
> > +		/* This is the child process now. */
> > +
> > +		/* Poison will have been wiped. */
> > +		for (i = 0; i < 10; i++) {
> > +			ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> > +		}
> > +
> > +		exit(0);
> > +	}
> > +
> > +	/* Parent process. */
> > +
> > +	waitpid(pid, NULL, 0);
> > +
> > +	/* Poison should be in effect.*/
> > +	for (i = 0; i < 10; i++) {
> > +		bool result = try_read_write_buf(&ptr[i * page_size]);
> > +
> > +		if (i < 5) {
> > +			ASSERT_FALSE(result);
> > +		} else {
> > +			ASSERT_TRUE(result);
> > +		}
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/* Ensure that MADV_FREE frees poison entries as expected. */
> > +TEST_F(guard_pages, lazyfree)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	int i;
> > +
> > +	/* Map 10 pages. */
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Poison range. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Ensure poisoned. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Lazyfree range. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_FREE), 0);
> > +
> > +	/* This should simply clear the poison markers. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_TRUE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/* Ensure that MADV_POPULATE_READ, MADV_POPULATE_WRITE behave as expected. */
> > +TEST_F(guard_pages, populate)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +
> > +	/* Map 10 pages. */
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Poison range. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Populate read should error out... */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_POPULATE_READ), -1);
> > +	ASSERT_EQ(errno, EFAULT);
> > +
> > +	/* ...as should populate write. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_POPULATE_WRITE), -1);
> > +	ASSERT_EQ(errno, EFAULT);
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/* Ensure that MADV_COLD, MADV_PAGEOUT do not remove poison markers. */
> > +TEST_F(guard_pages, cold_pageout)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	char *ptr;
> > +	int i;
> > +
> > +	/* Map 10 pages. */
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Poison range. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* Ensured poisoned. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Now mark cold. This should have no impact on poison markers. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_COLD), 0);
> > +
> > +	/* Should remain poisoned. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* OK, now page out. This should equally, have no effect on markers. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_PAGEOUT), 0);
> > +
> > +	/* Should remain poisoned. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +/* Ensure that guard pages do not break userfaultd. */
> > +TEST_F(guard_pages, uffd)
> > +{
> > +	const unsigned long page_size = self->page_size;
> > +	int uffd;
> > +	char *ptr;
> > +	int i;
> > +	struct uffdio_api api = {
> > +		.api = UFFD_API,
> > +		.features = 0,
> > +	};
> > +	struct uffdio_register reg;
> > +	struct uffdio_range range;
> > +
> > +	/* Set up uffd. */
> > +	uffd = userfaultfd(0);
> > +	if (uffd == -1 && errno == EPERM)
> > +		ksft_exit_skip("No uffd permissions\n");
>
> Same comment here about a user friendly message that say what
> user shoul do

Ack will update on respin.

>
> > +	ASSERT_NE(uffd, -1);
> > +
> > +	ASSERT_EQ(ioctl(uffd, UFFDIO_API, &api), 0);
> > +
> > +	/* Map 10 pages. */
> > +	ptr = mmap(NULL, 10 * page_size, PROT_READ | PROT_WRITE,
> > +		   MAP_ANON | MAP_PRIVATE, -1, 0);
> > +	ASSERT_NE(ptr, MAP_FAILED);
> > +
> > +	/* Register the range with uffd. */
> > +	range.start = (unsigned long)ptr;
> > +	range.len = 10 * page_size;
> > +	reg.range = range;
> > +	reg.mode = UFFDIO_REGISTER_MODE_MISSING;
> > +	ASSERT_EQ(ioctl(uffd, UFFDIO_REGISTER, &reg), 0);
> > +
> > +	/* Poison the range. This should not trigger the uffd. */
> > +	ASSERT_EQ(madvise(ptr, 10 * page_size, MADV_GUARD_POISON), 0);
> > +
> > +	/* The poisoning should behave as usual with no uffd intervention. */
> > +	for (i = 0; i < 10; i++) {
> > +		ASSERT_FALSE(try_read_write_buf(&ptr[i * page_size]));
> > +	}
> > +
> > +	/* Cleanup. */
> > +	ASSERT_EQ(ioctl(uffd, UFFDIO_UNREGISTER, &range), 0);
> > +	close(uffd);
> > +	ASSERT_EQ(munmap(ptr, 10 * page_size), 0);
> > +}
> > +
> > +TEST_HARNESS_MAIN
>
> thanks,
> -- Shuah
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mail-oa1-f52.google.com (mail-oa1-f52.google.com [209.85.160.52])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id D7F5F2022D1
	for <linux-kernel@vger.kernel.org>; Fri, 18 Oct 2024 15:32:20 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=209.85.160.52
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729265543; cv=none; b=dLm5S69M5QtsjkMbc/lVvuJ0R5gDwkNM8bSjlPloaQV6hGAVkhuyno7x8Mll/xvqRR/EAU8p9Q3l902WIUDNWSXBTC4JNPnIULiYL+f0UmJIDBnlUHc5bP8Tu4OgP6+c7+jlPuTGiUTUKQlyY+VQpssryxm2P+ofAUPkOtOIFeY=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729265543; c=relaxed/simple;
	bh=BmVpdD0jRxsiIbfsqjgxnbZ7lslKne0rx0q7CxIOU5Q=;
	h=Message-ID:Date:MIME-Version:Subject:To:Cc:References:From:
	 In-Reply-To:Content-Type; b=go+jygNmJImrpryDxBZX1nmtCJ5KuSVje2n5Oj7R9yPgVDagJuwWe0xxUHhX8ssXc8z9RPG/G0YYyxLGfu05YNIK9pkQikN8R1a7IUeZSFqkgjBchvV7dQPH4Lt96G7X+nlH98Wp70vhcz35S8l3VDF6AUQ+SeEWh62OdZuiPGI=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=linuxfoundation.org; spf=pass smtp.mailfrom=linuxfoundation.org; dkim=pass (1024-bit key) header.d=linuxfoundation.org header.i=@linuxfoundation.org header.b=SpDs95IU; arc=none smtp.client-ip=209.85.160.52
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=linuxfoundation.org
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=linuxfoundation.org
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=linuxfoundation.org header.i=@linuxfoundation.org header.b="SpDs95IU"
Received: by mail-oa1-f52.google.com with SMTP id 586e51a60fabf-2888165800fso1284028fac.3
        for <linux-kernel@vger.kernel.org>; Fri, 18 Oct 2024 08:32:20 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=linuxfoundation.org; s=google; t=1729265540; x=1729870340; darn=vger.kernel.org;
        h=content-transfer-encoding:in-reply-to:from:content-language
         :references:cc:to:subject:user-agent:mime-version:date:message-id
         :from:to:cc:subject:date:message-id:reply-to;
        bh=ZC7IXrCg0YuAvn8GUXeJqu+LI8owpl5cfwS2jfkhEf0=;
        b=SpDs95IU6ADOtqD4JdP5p1dTyQTopYQLVNRnWlt2kjYro2JEnufBTR7CTwP0ifGDJ9
         YkYRuuqaZ2ZPbpIxOq96OM36svuSmbQCnAxqMXqd/jgR5Lg12HZlouRwOeFLz5/P+h2r
         6ElHdsE/A28f7aB0ika9tOiqmUlbafPLz3AxY=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1729265540; x=1729870340;
        h=content-transfer-encoding:in-reply-to:from:content-language
         :references:cc:to:subject:user-agent:mime-version:date:message-id
         :x-gm-message-state:from:to:cc:subject:date:message-id:reply-to;
        bh=ZC7IXrCg0YuAvn8GUXeJqu+LI8owpl5cfwS2jfkhEf0=;
        b=cIct/FF+hC96T1T4KVDeVSoCNhjHIfQAn95fXNlB5b3asVwwTAxAMRkb/InHj9xEzx
         aZG3PRqJmuj9TZ+MYa5Xws7FqqEFFy8VNqBOo7ktj7zYiyGEf2WXfHpcC67SK+Mx3SV6
         cJ3Q8Uu54+S0roCFh0W7U0KrcJVEV8plNODA9o8WM2EZ6NB5AzmxXh2lrPqyS210Bljz
         cJLMJWmqDCYBpeRdgzlzJLcEdcWldP6X4VsAGXrmV0e+zLOp3J8/YXHINIB9gP6N4JhG
         J7Kkzox71YRRmTr9SpN/vLJ0LNZEm7W2WCrKwvS9tCTcYeOmiimOLEVns1gdMt12T/bq
         atZA==
X-Forwarded-Encrypted: i=1; AJvYcCX7oCO/fXRiSdCmZ15WgtUXWeZ2/JZYM83ZTeNDTPHXNw3jdi6KwMEUaF9475Skcb15N3KiDe15oZo2UiA=@vger.kernel.org
X-Gm-Message-State: AOJu0YzYrpyIAc1aYWYNoSiyIO+Cwtsg/sgSEwbNgYuYJ1luoOwcrF/1
	BMtIkfRxi9Wc2fGIBrCeZyQDXwL7Sc94qHpaT+MbGnF1KiRozEn/WQ92Zkg9H/E=
X-Google-Smtp-Source: AGHT+IFVILzQC3xLfv6R4AbCBfFL0IO4Vwr3Q+ju2/Ycfjj5wO6b5XNWyVkiIkvrRdK6DAeUYrsI+g==
X-Received: by 2002:a05:6870:89a9:b0:277:f5d8:b77b with SMTP id 586e51a60fabf-2892c4a62edmr2658526fac.32.1729265539765;
        Fri, 18 Oct 2024 08:32:19 -0700 (PDT)
Received: from [192.168.1.128] ([38.175.170.29])
        by smtp.gmail.com with ESMTPSA id 586e51a60fabf-2892ad9f036sm493443fac.34.2024.10.18.08.32.17
        (version=TLS1_3 cipher=TLS_AES_128_GCM_SHA256 bits=128/128);
        Fri, 18 Oct 2024 08:32:19 -0700 (PDT)
Message-ID: <22d386cd-e62f-43f9-905e-2d0881781abe@linuxfoundation.org>
Date: Fri, 18 Oct 2024 09:32:17 -0600
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
User-Agent: Mozilla Thunderbird
Subject: Re: [PATCH 4/4] selftests/mm: add self tests for guard page feature
To: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
Cc: Andrew Morton <akpm@linux-foundation.org>,
 Suren Baghdasaryan <surenb@google.com>,
 "Liam R . Howlett" <Liam.Howlett@oracle.com>,
 Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
 "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
 David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
 linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
 Richard Henderson <richard.henderson@linaro.org>,
 Ivan Kokshaysky <ink@jurassic.park.msu.ru>, Matt Turner
 <mattst88@gmail.com>, Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
 "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
 Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
 Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
 linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
 linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
 Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
 linux-kselftest@vger.kernel.org, Sidhartha Kumar
 <sidhartha.kumar@oracle.com>, Jeff Xu <jeffxu@chromium.org>,
 Christoph Hellwig <hch@infradead.org>, Shuah Khan <skhan@linuxfoundation.org>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
 <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
 <dfbf9ccb-6834-4181-a382-35c9c9af8064@lucifer.local>
Content-Language: en-US
From: Shuah Khan <skhan@linuxfoundation.org>
In-Reply-To: <dfbf9ccb-6834-4181-a382-35c9c9af8064@lucifer.local>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit

On 10/18/24 01:12, Lorenzo Stoakes wrote:
> On Thu, Oct 17, 2024 at 03:24:49PM -0600, Shuah Khan wrote:
>> On 10/17/24 14:42, Lorenzo Stoakes wrote:
>>> Utilise the kselftest harmness to implement tests for the guard page
>>
>> Splleing NIT - harmness -> harness
>>
>>> implementation.
>>>
>>> We start by implement basic tests asserting that guard pages can be
>>
>> implmenting? By the way checkpatch will catch spelling stuuf.
>> Please see comments about warnings below.
> 
> Thanks. The majority of the checkpatch warnings are invalid so I missed
> this. Will fix on respin.
> 
>>
>>> established (poisoned), cleared (remedied) and that touching poisoned pages
>>> result in SIGSEGV. We also assert that, in remedying a range, non-poison
>>> pages remain intact.
>>>
>>> We then examine different operations on regions containing poison markers
>>> behave to ensure correct behaviour:
>>>
>>> * Operations over multiple VMAs operate as expected.
>>> * Invoking MADV_GUARD_POISION / MADV_GUARD_REMEDY via process_madvise() in
>>>     batches works correctly.
>>> * Ensuring that munmap() correctly tears down poison markers.
>>> * Using mprotect() to adjust protection bits does not in any way override
>>>     or cause issues with poison markers.
>>> * Ensuring that splitting and merging VMAs around poison markers causes no
>>>     issue - i.e. that a marker which 'belongs' to one VMA can function just
>>>     as well 'belonging' to another.
>>> * Ensuring that madvise(..., MADV_DONTNEED) does not remove poison markers.
>>> * Ensuring that mlock()'ing a range containing poison markers does not
>>>     cause issues.
>>> * Ensuring that mremap() can move a poisoned range and retain poison
>>>     markers.
>>> * Ensuring that mremap() can expand a poisoned range and retain poison
>>>     markers (perhaps moving the range).
>>> * Ensuring that mremap() can shrink a poisoned range and retain poison
>>>     markers.
>>> * Ensuring that forking a process correctly retains poison markers.
>>> * Ensuring that forking a VMA with VM_WIPEONFORK set behaves sanely.
>>> * Ensuring that lazyfree simply clears poison markers.
>>> * Ensuring that userfaultfd can co-exist with guard pages.
>>> * Ensuring that madvise(..., MADV_POPULATE_READ) and
>>>     madvise(..., MADV_POPULATE_WRITE) error out when encountering
>>>     poison markers.
>>> * Ensuring that madvise(..., MADV_COLD) and madvise(..., MADV_PAGEOUT) do
>>>     not remove poison markers.
>>
>> Good summary of test. Does the test require root access?
>> If so does it check and skip appropriately?
> 
> Thanks and some do, in those cases we skip.
> 
>>
>>>
>>> Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
>>> ---
>>>    tools/testing/selftests/mm/.gitignore    |    1 +
>>>    tools/testing/selftests/mm/Makefile      |    1 +
>>>    tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
>>>    3 files changed, 1170 insertions(+)
>>>    create mode 100644 tools/testing/selftests/mm/guard-pages.c
>>>
>>> diff --git a/tools/testing/selftests/mm/.gitignore b/tools/testing/selftests/mm/.gitignore
>>> index 689bbd520296..8f01f4da1c0d 100644
>>> --- a/tools/testing/selftests/mm/.gitignore
>>> +++ b/tools/testing/selftests/mm/.gitignore
>>> @@ -54,3 +54,4 @@ droppable
>>>    hugetlb_dio
>>>    pkey_sighandler_tests_32
>>>    pkey_sighandler_tests_64
>>> +guard-pages
>>> diff --git a/tools/testing/selftests/mm/Makefile b/tools/testing/selftests/mm/Makefile
>>> index 02e1204971b0..15c734d6cfec 100644
>>> --- a/tools/testing/selftests/mm/Makefile
>>> +++ b/tools/testing/selftests/mm/Makefile
>>> @@ -79,6 +79,7 @@ TEST_GEN_FILES += hugetlb_fault_after_madv
>>>    TEST_GEN_FILES += hugetlb_madv_vs_map
>>>    TEST_GEN_FILES += hugetlb_dio
>>>    TEST_GEN_FILES += droppable
>>> +TEST_GEN_FILES += guard-pages
>>>    ifneq ($(ARCH),arm64)
>>>    TEST_GEN_FILES += soft-dirty
>>> diff --git a/tools/testing/selftests/mm/guard-pages.c b/tools/testing/selftests/mm/guard-pages.c
>>> new file mode 100644
>>> index 000000000000..2ab0ff3ba5a0
>>> --- /dev/null
>>> +++ b/tools/testing/selftests/mm/guard-pages.c
>>> @@ -0,0 +1,1168 @@
>>> +// SPDX-License-Identifier: GPL-2.0-or-later
>>> +
>>> +#define _GNU_SOURCE
>>> +#include "../kselftest_harness.h"
>>> +#include <assert.h>
>>> +#include <fcntl.h>
>>> +#include <setjmp.h>
>>> +#include <errno.h>
>>> +#include <linux/userfaultfd.h>
>>> +#include <signal.h>
>>> +#include <stdbool.h>
>>> +#include <stdio.h>
>>> +#include <stdlib.h>
>>> +#include <string.h>
>>> +#include <sys/ioctl.h>
>>> +#include <sys/mman.h>
>>> +#include <sys/syscall.h>
>>> +#include <sys/uio.h>
>>> +#include <unistd.h>
>>> +
>>> +/* These may not yet be available in the uAPI so define if not. */
>>> +
>>> +#ifndef MADV_GUARD_POISON
>>> +#define MADV_GUARD_POISON	102
>>> +#endif
>>> +
>>> +#ifndef MADV_GUARD_UNPOISON
>>> +#define MADV_GUARD_UNPOISON	103
>>> +#endif
>>> +
>>> +volatile bool signal_jump_set;
>>
>> Can you add a comment about why volatile is needed.
> 
> I'm not sure it's really necessary, it's completely standard to do this
> with signal handling and is one of the exceptions to the 'volatile
> considered harmful' rule.
> 
>> By the way did you happen to run checkpatck on this. There are
>> several instances where single statement blocks with braces {}
>>
>> I noticed a few and ran checkpatch on your patch. There are
>> 45 warnings regarding codeing style.
>>
>> Please run checkpatch and clean them up so we can avoid followup
>> checkpatch cleanup patches.
> 
> No sorry I won't, checkpatch isn't infallible and series trying to 'clean
> up' things that aren't issues will be a waste of everybody's time.
> 

Sorry - this violates the coding styles and makes it hard to read.

See process/coding-style.rst:

Do not unnecessarily use braces where a single statement will do.

.. code-block:: c

         if (condition)
                 action();

and

.. code-block:: c

         if (condition)
                 do_this();
         else
                 do_that();

This does not apply if only one branch of a conditional statement is a single
statement; in the latter case use braces in both branches:

.. code-block:: c

         if (condition) {
                 do_this();
                 do_that();
         } else {
                 otherwise();
         }

Also, use braces when a loop contains more than a single simple statement:

.. code-block:: c

         while (condition) {
                 if (test)
                         do_something();
         }

thanks,
-- Shuah

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0a-00069f02.pphosted.com (mx0a-00069f02.pphosted.com [205.220.165.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id B448E4207A;
	Fri, 18 Oct 2024 16:08:12 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.165.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729267695; cv=fail; b=BtSTIMLaiC6y2W7u6oavkmy4gshqQUTjEmCf9LUUDgSwqUJq7YU+AGc/rD9Jw5WwJRunT9ccdOJVeWGvnmEw9dkeJNfKjYs75Sw/qPp9GSASgUK3URg+7BcB9hnelt3JrmRTbELCDN4bEaMCe6oZcercQToX8lXxnz3DuTCTij4=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729267695; c=relaxed/simple;
	bh=xOdsj49tnW5r96rkFgqy6fAJBTDMnGO1x5zjqT7PyCk=;
	h=Date:From:To:Cc:Subject:Message-ID:References:Content-Type:
	 Content-Disposition:In-Reply-To:MIME-Version; b=vA9/tZq0fVh3EexSOi5kd9dwmKTnxFy1FxZv7QxYxTGoBgBMxY4Yt73peDDyFqGUhLoeC34AHON9vycXcf5Ed/hNGAINYO/c76YWo/fOkIZXCEgIXilkX5qiAcTvifXk7X4qcoFQZS+v4rPy/zGjx7Vu379k5LGxyiysn4JI8Vo=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=hqNHMX/e; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=npgRGePt; arc=fail smtp.client-ip=205.220.165.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="hqNHMX/e";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="npgRGePt"
Received: from pps.filterd (m0246627.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49IEBe7N005751;
	Fri, 18 Oct 2024 16:07:28 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-transfer-encoding:content-type:date:from:in-reply-to
	:message-id:mime-version:references:subject:to; s=
	corp-2023-11-20; bh=AKfP1QkHHmFqoghsvk6cgU/uCMrAs9e1OyQutoadcmY=; b=
	hqNHMX/eGYtAnW1qjCye8/tbX9x0f/IKXoG6ufSXPRfXqNkgEeL47yB9m01r0TQ2
	HDAui7j2rMN4UjcpxXdfk2uM0n8bcc6FXo85a5ZC/tyXPlV5dWUIJZKu+E3X/GIZ
	UMhvL3T61yd2iHt/ryFjnORWrBhzEbEd/Nefv/1rLzSkRlvYCqvnx/tDPELJaJsq
	bPrLY7wnf+p9/Y/Ki2M7JFspvoIrXeNTJ228RUq8T8vD+oooqhOJxHn5yYX1kfJE
	Q1AbsAI7UNk/onOYEbL1AC6TPODkMo/rBJFa2JE5/Uhh5TDR8jY/ZAgzyYmmMESX
	yCCW6eEFRNMLoSXQnzyfYA==
Received: from phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (phxpaimrmta03.appoci.oracle.com [138.1.37.129])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427gq7s70m-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 16:07:27 +0000 (GMT)
Received: from pps.filterd (phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com [127.0.0.1])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49IEkPnn013985;
	Fri, 18 Oct 2024 16:07:27 GMT
Received: from nam12-bn8-obe.outbound.protection.outlook.com (mail-bn8nam12lp2174.outbound.protection.outlook.com [104.47.55.174])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (PPS) with ESMTPS id 427fjbrjhp-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 16:07:27 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=EilinLGLV32GbUuMH2pPzzRnkICyPLKnHxksCE/QgWUtR8XyBmy5AsDOZkKVsam6UI7BpL1UBl4d8xAOakZuL50XzXvZxp5XQyQHv0qbPEaDxNYa2YkWn0LlHOrOEwNW7NGqDvkMy99dbfBeDBdDnOehhaTyy/Gkw9LiNQk5TUCvqkUatdqtqbrZPCyrqQWnMXhqpkrOxKj0Re5NK0HMr4JBy+2JFKrfuWy+lTXvj8mHYbc59h9o/iTqFiBvU7PQC1PWOSCg+sxn6d7e3lk1keqMXgV/34LHF0jAfhJItS5vNUNlk8UuQTbeVr7SW/Y3E7Bpf50uCANteKYKex3VCA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=AKfP1QkHHmFqoghsvk6cgU/uCMrAs9e1OyQutoadcmY=;
 b=UuLDyev/TgFPDh/wN1yB0Y7uDdDh5m1FnRRsjPNb+EuRSNFAzGh75sodJ8jSVNYsslQh7oolMxmpHlfXiCOas8/4mkfjw11ropPwe8Tk0XvyS89WrC/jUsByN4TWzh9sloHfNDGxyu08rEh0mCXwCCzo6vCwv7/Pph+ETKt6n7yUmhxUrrKwUxAm0ce7HYPSuuzBPowFbpPq6f3wL40R7SQS+aismjcZl5GlnMZJki98MphgerK9gjMR6DhgRfAuHFvE8iOdpvOoqr+M3G411BBUDYKtuqLzzxp4weIR3NqPVR1UGAIq0tM6JVK8QQ/Je/mbC7YiDLCtDRjN9f2M2A==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=AKfP1QkHHmFqoghsvk6cgU/uCMrAs9e1OyQutoadcmY=;
 b=npgRGePtjXhGCTTYmOQm4XLsZT8sg5TnveTRsaPoAVsBJ5ANvrDrV4MdJx32HS+p3Ff73Rb2cc7yk6CKaVm07BepwC3TZwslAEepGVCSbWwzVliaHq3e9cGChlZLhaEorpx7BZv+mAYQKDPg+EnITYd6BxEFoKUBt4AaJlRQfIU=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by BN0PR10MB5015.namprd10.prod.outlook.com (2603:10b6:408:126::11) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.24; Fri, 18 Oct
 2024 16:07:23 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Fri, 18 Oct 2024
 16:07:23 +0000
Date: Fri, 18 Oct 2024 17:07:20 +0100
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Shuah Khan <skhan@linuxfoundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>,
        Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: Re: [PATCH 4/4] selftests/mm: add self tests for guard page feature
Message-ID: <7bbfc635-8d42-4c3d-8808-cb060cd9f658@lucifer.local>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
 <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
 <dfbf9ccb-6834-4181-a382-35c9c9af8064@lucifer.local>
 <22d386cd-e62f-43f9-905e-2d0881781abe@linuxfoundation.org>
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <22d386cd-e62f-43f9-905e-2d0881781abe@linuxfoundation.org>
X-ClientProxiedBy: LO2P123CA0039.GBRP123.PROD.OUTLOOK.COM (2603:10a6:600::27)
 To SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|BN0PR10MB5015:EE_
X-MS-Office365-Filtering-Correlation-Id: 5d6204d2-b997-4916-f5f2-08dcef8ef39d
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam:
	BCL:0;ARA:13230040|1800799024|10070799003|366016|7416014|376014;
X-Microsoft-Antispam-Message-Info:
	=?utf-8?B?Tm1xNldLOW1MbmprK3BpNXZqMG9VUEthSDMzMU4zcE8vb1hHOFYyK1FEbUNY?=
 =?utf-8?B?d1pVUjFZMFZkNGM2eXUyUjZ4QmdVVTR5dEZwTEZZaERBZ1ZkSHZ5SlFHdGpF?=
 =?utf-8?B?NzlpWEZUL01TQ05VaWRYaEs2QXZSZzRIRVFBZEduaU91NEFVdkI1WkpjMHJp?=
 =?utf-8?B?YXhVOEtWODdRZVpMZllpeW9WV3RoR0RKaExMMWJ6eW5xeUlPMDMzMjlxWFpr?=
 =?utf-8?B?ZUtPU1JzRDdIRFVORzY0VWtndzc4TCtRd2hEZCtzTEZHVVFzMkVHSEJlcmM5?=
 =?utf-8?B?UHlUZnk4OXprVVBjbDZRck1wNjlINUUzR2poR1lEUUZOeHh1M21KSkk2Y0Nz?=
 =?utf-8?B?STVJVW9HQXVhWXpHT1RKOTE1Uk9UTHVBRzhyc3pISVNhWERGbUg4WGRsN1N2?=
 =?utf-8?B?NnBzNEpCZExXUXdlbGNrQVhPb0N5bDhabUNVbGxVRHFUR0d0WUZjeUhYZjZj?=
 =?utf-8?B?dm1PMGpNWk9ucTR3WVp3cVdiTjFHSWl6OUs2OGh2RGRpVTVUb3Q2b3U0M1hL?=
 =?utf-8?B?NWFqamxyUElzT20vZ3paOXRoeE1BWmpoVS8wdlIwaUZGcW95S2RwZHhSYkN3?=
 =?utf-8?B?SkFpR0NFU0E1TkJyMFBqYTlSeUhWK2hDNGg0akpEVnkxQXpXZjNqTlRKVkxu?=
 =?utf-8?B?ZEVyVDBLMXlIM1BBM3VVTWYzeENRbkxiVkNBZkNGMDVoT09qU3hQNmFlZ2lt?=
 =?utf-8?B?RUMwOHlWQ2haT2dxKzZPNUFlOGY3Zlo1TFhoemxwQ2NUaUxyUERKN3Ywd3Rj?=
 =?utf-8?B?WklBTUlNU1RPZ3IvU2Z5akttdUJPcVQ0NmFYWHcxWkNJSkZvbEw5b1V1bmVw?=
 =?utf-8?B?U3JnbUtvSFdIWXdqVUptK3h2YUh4MVpCQTNpWmlXUUpaZWFoOXhtc0dweHR2?=
 =?utf-8?B?TkZJWFhsUXJ3c2s1N0gvMzl5ZnJOVzdGRWtnb2lYa0tFU2xIT3I5SWg5bXVz?=
 =?utf-8?B?WW9tcVZ6bkM0V1NOeTA4MVhEUTFzbTdEWDUrQXhkdDViVm5ueDlOdTRFR0RT?=
 =?utf-8?B?VTBRUUw0cmlFNmw5SXBUQW80dlN6dS8yMG1lUENrOUNXZko3QTI0cC9PZDJI?=
 =?utf-8?B?L25WNEZHTlpEL2tvbVByRFlTNVdHSnBMUUE4WUc4TXJUSldvajNJcSsvQ2Ju?=
 =?utf-8?B?cXcxK2w3QXRTN09oTjJXV2NtZEc2bGxtVGR5K29SMHpHdmgzTHpMS3dPbVh2?=
 =?utf-8?B?OTJDc1llQ01HZjQzbU0zMllsRE9nSkVQSVhITGNqdTJ5cEVlQVM1bnMvb0lU?=
 =?utf-8?B?SHowcHVOWThISVRwUXVEZjk3VURjMS9JYmU2cXd3L3ZRQnFKRUtJUEJsVmRy?=
 =?utf-8?B?d3BaaExmbXp1MWprNHkzeFJ4Y1BRMlc0N0JPZXNXSk1DSC9YMGNkRUVxeFZB?=
 =?utf-8?B?UFZ0bkcrTmUxQ2FJNTEyMmYyS2ZhMFgzMmFiaEdRaUh0em9aVE1zQlBRRjhE?=
 =?utf-8?B?K1FEcTNhNXFTaCs1MjNsRmg0N0FWVFNpRmMyMFMrM041VEFQWkR0ODkvdFBz?=
 =?utf-8?B?dUN3RE1ZSE9Ka2hXTHpzTTV6QWlKZTFCQ0tEVXRzWGozNjM0TkIyQ2gwb2k2?=
 =?utf-8?B?VmJXQTlML3JmQ2RaQnJyVDBsNWVGbVllTHluWDByRGpKbGlxV0l2YVJZV2tl?=
 =?utf-8?B?WmRHOXZXWkYxQ2dlajhZeVRPejAxK1lKeE5qVXlaejg3NElNcngxNW1Hbk1Z?=
 =?utf-8?B?a0cwbnJGWFNZYWZZaWYxMFZBb21qbXdiZlFPdkFieTAyUjBmK1Nqd1VsU0tk?=
 =?utf-8?Q?AZ9ylXWj8TUe9f6D1TWOZxVR6AC2Cc2rTILnZUf?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(1800799024)(10070799003)(366016)(7416014)(376014);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?utf-8?B?SFZyYlo5V3JGNnRicDd2NHNlL1E4WUxKU2QvTXZqZEd1cDRPSWkwNThpNTdF?=
 =?utf-8?B?bnAwRGJ3ck05UU5HWm12VTZYMFVkdTl4eHJRWmJUSzBaZmpGQXdRVWc0U3Jl?=
 =?utf-8?B?RGVMSlFUSWlxd0ZaSG1zQjJ2bUZFY1hxZklNeGk5ZW5TS2lsY1VDemJjSHNR?=
 =?utf-8?B?QmR6TU9LMXdKSnZQNnBYQ3FoeUNVVmNUMFVBYzV1cTd5MWRDYmFIcDQyZ0ZD?=
 =?utf-8?B?SnJJaDI1QzZGRVRSVUptWWJlakdJWWY1bjZQZ1FDZzhRSVVvNThXN0RYcEhv?=
 =?utf-8?B?aE8xRzBBN0RjRHp5ajdxbVZMRjJ1K2ZUa3lPM2s3SGRhY1RGOUpENUxLNkhE?=
 =?utf-8?B?aE5xUnRZMFlaUUtvcGRQUE4ybURWUHNiemZDalN0TjFvQlZOT2JpTlgwSEV6?=
 =?utf-8?B?d2lDLzAxSTd0bWpCMTdJQ05TWXczZ0drRXIwZi9iQ3FmVDh2UCtkVEZLMVoy?=
 =?utf-8?B?TFhPWFY5SEx6STNtbU1YTXJWSFRqVytzRUdwSXVlOUhTc3VrN1dwRlNPVW52?=
 =?utf-8?B?RmZvMWZsZFlIQ3pVbEl2Vk5wNFVuNFpJRFRGaUw5YTd2bDFrb2JDamRFN0dL?=
 =?utf-8?B?OFNxT09hVnNnbEZabkxEQ2M0SEphSVlXLzVBTUsrQnJUSU9CTHZsUnhjOVJP?=
 =?utf-8?B?ODh0aUFuZ0orem5sb3lZM0ZTTUdFTEhFQmE0bXoybWREUFdmdm4rSVhMQmZF?=
 =?utf-8?B?MlB3bUhFT3UycEtSUDdTZXhLL0FwOXV2ZmVIM0hzdXJ1VHk2OUc2T3JkT0pZ?=
 =?utf-8?B?Q0d6bUN6VTl3Q1VwQmVHOEExRTA1bFhnRjRlTVY5ZGRuSEdvb2NtN1gwdG80?=
 =?utf-8?B?ZG8yTGRKUEhXdklCOUJDS3VRNC9xQmM1aGg3VFIrNGRnNlp1NTAxMWJoaDc0?=
 =?utf-8?B?N0hnbzdSNmlFN2FXNkM2Snd2SlFpQ0NzMTBvQ0xJMGNnODNVUHloSFJHTFlh?=
 =?utf-8?B?QlFVbW1zUmtrZXBYcVVybmRRcnIyOW91QXZQSzBDNFhrWUllb3g2dUJESnAr?=
 =?utf-8?B?dWpRaEpIME9sWk9aeHI4S0daNEljRlJvUGFIZmVsUmNqM0I0amxWM2JZQldP?=
 =?utf-8?B?eXpqMFVNSHJXTmxaaU9DSmhQZnpLN1d0VlFUMzV1SitqT0dJRVN6YS9pMnY4?=
 =?utf-8?B?ZGZwWFBTZVNBa2VhYWFGcEhReTZuRmtoYVlGNm1IdGxCOFV5VzY4d3lNREpr?=
 =?utf-8?B?WEZoT0s5RmZnVGZVckdmdjVjb0l5aTdaNTBTUlluV0l3SmFjMWhaMk1xUUNy?=
 =?utf-8?B?NGJkbG9jR0M0a1F0YlBiaTNBQkF2TU5qUmlMTFRQTmNEU28rTHVjUHZJTVNG?=
 =?utf-8?B?cjZObTNBTlpLdno4RHFjWk8rbDI0aGNrend4N081dVVsbGduNytLY1dLVUty?=
 =?utf-8?B?QkQ5dGxpTUE0WDd1a2FmS2tYWUlScDdtS1YxWWFqamFCUys4VzVzUGlvQU9t?=
 =?utf-8?B?TUFmMHlLbi9ISmpXUitwSC90azBBM2JYMjgzYWRWcmozbG15ZVpDVmNBbXlm?=
 =?utf-8?B?RGRLMUFaTlRYOVVpZ25RN2J3bEcrTXQzNVJlZTg0MHQ0SUhtRktDNU1KMWxI?=
 =?utf-8?B?UWJhY3J5WWZ5TnZSVkUzV2laTkJheGFLZ1R5NlpSdzVqWW93bmsyREJMQW9K?=
 =?utf-8?B?OUpMdU9NYnYvcmFiMEdDaTZVZHk3TG9UUEM4R1dkUnVUcTNJNHk2b1lBQnMz?=
 =?utf-8?B?RDZwaUY0d3RKSERpZStxOGNIRDJ6S3ladm5MbndYNzFVWUdTWGcxZmJzdWY0?=
 =?utf-8?B?YWFkWVZnZjZjeDd3cmdrbFBPck8xYnhlZzNWdldyUWY2SnJKenBoTVNBRE9U?=
 =?utf-8?B?TE9zMjJhQlJzeDJIelhWVysycndEYjROeUZBRkxlaWRNZnB2TXY1TTR1OStn?=
 =?utf-8?B?SnN6cnRnL2ZxbHNjR29iSGF4OXRhQjdDZWlYR2R2NFVQNUk0WU10c09pa0dt?=
 =?utf-8?B?TmxubExnZ2tMS3g5MDVNblVtQWw5QVBFQVphYTRkZ0lHZ3RMNVdmNUZabXVU?=
 =?utf-8?B?U3QvZllyU0p6QTFzTHpSTzFFQ3lRU3p2eDRoUWFnZlBtUXJzVG9ZcnpyRmM0?=
 =?utf-8?B?cEpmMW9QN0ErV1QwUjZKOUpjSUlZY09VOFlQaFBZTUYrditmZy9Vc2M1Mzkw?=
 =?utf-8?B?RXhobVl6Mi9haDBwTVF2NGs5MS9JbVhQa1V0aHlMUWhSMURmbWJUR09wQkxo?=
 =?utf-8?B?VFlYemNUSTVZN1Nvam5qYTRDbzhKMHdHd1pNS2V5cGVkaEMwTm9yVTkrMzFk?=
 =?utf-8?B?bTF3aDBpMndWNlVFQitDeEgrSlp3PT0=?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	AcGVj4MZoAiAMK0c+pHbVOmeFaApIOnGElDwieRGfN3FpyspdZ0IFfD38hSeudQfXtHps41a7dsu+TVSFlXGUjVdJSXrkbSbuS7ZkRzQuZrHh/Gfg6c7fHeTBiesTtxA5pTt+N0ikXM1s8ypxLdud8uO/gm/XmzCxx9e6nUG2bt+evYdFx2nyR4XvlSuSIPr5zSseQ5r+rUBg+MgWKbtEU82FFMObvKNEoY+50oExTQ7rwyXm2MdbHIoWFzTbc9SehCCU9305Xk3M4sMaCk+APi+6R00aKwH5rkJmhBrYlC2JoeBOyU0/HfeLLNV43RpmvywzSM3/iUeKi2dAsNLHXqk+Q7J0Uy3iOhML7+XnwIcnE9jfKTbN9WyMcDMuf+uLOCzjo0Q0NVHmE8UyVwEyfsVCgIj2eiHCiokiyAQoQdye1jBNsFo94bxxXirJWqX3U9PDCzm8uVdHgtEZQWOgAXyd2IGU2f6QZjUZqZPTCUSs/fFyhttj+M6NzfjjlgcjxpDQFuQjhD6jmo7ViXIhllrUCAaLj6aAS29JiQ7viYYRt1OgvvTfne75Bh0LX7SdgnVQJReY7w3ldjHCfEAt2Q5w8AlR5Dt15xhpfxuDj4=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 5d6204d2-b997-4916-f5f2-08dcef8ef39d
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Oct 2024 16:07:23.3853
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 1jtPHRvm/Jhy7072BSuLnesX0TLgQo3qwebvf7qo8AgEaoz78NufuAtVmxJCRw8aT+4fjpLZt/lmWjwO26sSVOKUrr5CewhW8qRCeC7tG5w=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: BN0PR10MB5015
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-18_11,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 malwarescore=0 phishscore=0 mlxscore=0
 mlxlogscore=999 bulkscore=0 spamscore=0 suspectscore=0 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2409260000
 definitions=main-2410180103
X-Proofpoint-ORIG-GUID: edHW5Wqmq40zSq42uwHrYtc8wUSeknSB
X-Proofpoint-GUID: edHW5Wqmq40zSq42uwHrYtc8wUSeknSB

On Fri, Oct 18, 2024 at 09:32:17AM -0600, Shuah Khan wrote:
> On 10/18/24 01:12, Lorenzo Stoakes wrote:
> > On Thu, Oct 17, 2024 at 03:24:49PM -0600, Shuah Khan wrote:
> > > On 10/17/24 14:42, Lorenzo Stoakes wrote:
> > > > Utilise the kselftest harmness to implement tests for the guard page
> > >
> > > Splleing NIT - harmness -> harness
> > >
> > > > implementation.
> > > >
> > > > We start by implement basic tests asserting that guard pages can be
> > >
> > > implmenting? By the way checkpatch will catch spelling stuuf.
> > > Please see comments about warnings below.
> >
> > Thanks. The majority of the checkpatch warnings are invalid so I missed
> > this. Will fix on respin.
> >
> > >
> > > > established (poisoned), cleared (remedied) and that touching poisoned pages
> > > > result in SIGSEGV. We also assert that, in remedying a range, non-poison
> > > > pages remain intact.
> > > >
> > > > We then examine different operations on regions containing poison markers
> > > > behave to ensure correct behaviour:
> > > >
> > > > * Operations over multiple VMAs operate as expected.
> > > > * Invoking MADV_GUARD_POISION / MADV_GUARD_REMEDY via process_madvise() in
> > > >     batches works correctly.
> > > > * Ensuring that munmap() correctly tears down poison markers.
> > > > * Using mprotect() to adjust protection bits does not in any way override
> > > >     or cause issues with poison markers.
> > > > * Ensuring that splitting and merging VMAs around poison markers causes no
> > > >     issue - i.e. that a marker which 'belongs' to one VMA can function just
> > > >     as well 'belonging' to another.
> > > > * Ensuring that madvise(..., MADV_DONTNEED) does not remove poison markers.
> > > > * Ensuring that mlock()'ing a range containing poison markers does not
> > > >     cause issues.
> > > > * Ensuring that mremap() can move a poisoned range and retain poison
> > > >     markers.
> > > > * Ensuring that mremap() can expand a poisoned range and retain poison
> > > >     markers (perhaps moving the range).
> > > > * Ensuring that mremap() can shrink a poisoned range and retain poison
> > > >     markers.
> > > > * Ensuring that forking a process correctly retains poison markers.
> > > > * Ensuring that forking a VMA with VM_WIPEONFORK set behaves sanely.
> > > > * Ensuring that lazyfree simply clears poison markers.
> > > > * Ensuring that userfaultfd can co-exist with guard pages.
> > > > * Ensuring that madvise(..., MADV_POPULATE_READ) and
> > > >     madvise(..., MADV_POPULATE_WRITE) error out when encountering
> > > >     poison markers.
> > > > * Ensuring that madvise(..., MADV_COLD) and madvise(..., MADV_PAGEOUT) do
> > > >     not remove poison markers.
> > >
> > > Good summary of test. Does the test require root access?
> > > If so does it check and skip appropriately?
> >
> > Thanks and some do, in those cases we skip.
> >
> > >
> > > >
> > > > Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
> > > > ---
> > > >    tools/testing/selftests/mm/.gitignore    |    1 +
> > > >    tools/testing/selftests/mm/Makefile      |    1 +
> > > >    tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
> > > >    3 files changed, 1170 insertions(+)
> > > >    create mode 100644 tools/testing/selftests/mm/guard-pages.c
> > > >
> > > > diff --git a/tools/testing/selftests/mm/.gitignore b/tools/testing/selftests/mm/.gitignore
> > > > index 689bbd520296..8f01f4da1c0d 100644
> > > > --- a/tools/testing/selftests/mm/.gitignore
> > > > +++ b/tools/testing/selftests/mm/.gitignore
> > > > @@ -54,3 +54,4 @@ droppable
> > > >    hugetlb_dio
> > > >    pkey_sighandler_tests_32
> > > >    pkey_sighandler_tests_64
> > > > +guard-pages
> > > > diff --git a/tools/testing/selftests/mm/Makefile b/tools/testing/selftests/mm/Makefile
> > > > index 02e1204971b0..15c734d6cfec 100644
> > > > --- a/tools/testing/selftests/mm/Makefile
> > > > +++ b/tools/testing/selftests/mm/Makefile
> > > > @@ -79,6 +79,7 @@ TEST_GEN_FILES += hugetlb_fault_after_madv
> > > >    TEST_GEN_FILES += hugetlb_madv_vs_map
> > > >    TEST_GEN_FILES += hugetlb_dio
> > > >    TEST_GEN_FILES += droppable
> > > > +TEST_GEN_FILES += guard-pages
> > > >    ifneq ($(ARCH),arm64)
> > > >    TEST_GEN_FILES += soft-dirty
> > > > diff --git a/tools/testing/selftests/mm/guard-pages.c b/tools/testing/selftests/mm/guard-pages.c
> > > > new file mode 100644
> > > > index 000000000000..2ab0ff3ba5a0
> > > > --- /dev/null
> > > > +++ b/tools/testing/selftests/mm/guard-pages.c
> > > > @@ -0,0 +1,1168 @@
> > > > +// SPDX-License-Identifier: GPL-2.0-or-later
> > > > +
> > > > +#define _GNU_SOURCE
> > > > +#include "../kselftest_harness.h"
> > > > +#include <assert.h>
> > > > +#include <fcntl.h>
> > > > +#include <setjmp.h>
> > > > +#include <errno.h>
> > > > +#include <linux/userfaultfd.h>
> > > > +#include <signal.h>
> > > > +#include <stdbool.h>
> > > > +#include <stdio.h>
> > > > +#include <stdlib.h>
> > > > +#include <string.h>
> > > > +#include <sys/ioctl.h>
> > > > +#include <sys/mman.h>
> > > > +#include <sys/syscall.h>
> > > > +#include <sys/uio.h>
> > > > +#include <unistd.h>
> > > > +
> > > > +/* These may not yet be available in the uAPI so define if not. */
> > > > +
> > > > +#ifndef MADV_GUARD_POISON
> > > > +#define MADV_GUARD_POISON	102
> > > > +#endif
> > > > +
> > > > +#ifndef MADV_GUARD_UNPOISON
> > > > +#define MADV_GUARD_UNPOISON	103
> > > > +#endif
> > > > +
> > > > +volatile bool signal_jump_set;
> > >
> > > Can you add a comment about why volatile is needed.
> >
> > I'm not sure it's really necessary, it's completely standard to do this
> > with signal handling and is one of the exceptions to the 'volatile
> > considered harmful' rule.
> >
> > > By the way did you happen to run checkpatck on this. There are
> > > several instances where single statement blocks with braces {}
> > >
> > > I noticed a few and ran checkpatch on your patch. There are
> > > 45 warnings regarding codeing style.
> > >
> > > Please run checkpatch and clean them up so we can avoid followup
> > > checkpatch cleanup patches.
> >
> > No sorry I won't, checkpatch isn't infallible and series trying to 'clean
> > up' things that aren't issues will be a waste of everybody's time.
> >
>
> Sorry - this violates the coding styles and makes it hard to read.
>
> See process/coding-style.rst:
>
> Do not unnecessarily use braces where a single statement will do.
>
> .. code-block:: c
>
>         if (condition)
>                 action();
>
> and
>
> .. code-block:: c
>
>         if (condition)
>                 do_this();
>         else
>                 do_that();
>
> This does not apply if only one branch of a conditional statement is a single
> statement; in the latter case use braces in both branches:
>
> .. code-block:: c
>
>         if (condition) {
>                 do_this();
>                 do_that();
>         } else {
>                 otherwise();
>         }
>
> Also, use braces when a loop contains more than a single simple statement:
>
> .. code-block:: c
>
>         while (condition) {
>                 if (test)
>                         do_something();
>         }
>
> thanks,
> -- Shuah

Shuah, quoting coding standards to an experienced kernel developer
(maintainer now) is maybe not the best way to engage here + it may have
been more productive for you to first engage on why it is I'm deviating
here.

Firstly, as I said, the code _does not compile_ if I do not use braces in
many cases. This is probably an issue with the macros, but it is out of
scope for this series for me to fix that.

'Fixing' these cases results in:

  CC       guard-pages
guard-pages.c: In function guard_pages_split_merge:
guard-pages.c:566:17: error: else without a previous if
  566 |                 else
      |                 ^~~~
guard-pages.c: In function guard_pages_dontneed:
guard-pages.c:666:17: error: else without a previous if
  666 |                 else
      |                 ^~~~
guard-pages.c: In function guard_pages_fork:
guard-pages.c:957:17: error: else without a previous if
  957 |                 else
      |                 ^~~~
guard-pages.c: In function guard_pages_fork_wipeonfork:
guard-pages.c:1010:17: error: else without a previous if
 1010 |                 else
      |                 ^~~~

In other cases I am simply not a fan of single line loops where there is a
lot of compound stuff going on:

	for (i = 0; i < 10; i++) {
		ASSERT_FALSE(try_read_write_buf(&ptr1[i * page_size]));
	}

vs.

	for (i = 0; i < 10; i++)
		ASSERT_FALSE(try_read_write_buf(&ptr1[i * page_size]));

When there are very many loops like this. This is kind of a test-specific
thing, you'd maybe put more effort into splitting this up + have less
repetition in non-test code.

I'm not going to die on the hill of single-line-for-loops though, so if you
insist I'll change those.

However I simply _cannot_ change the if/else blocks that cause compilation
errors.

This is what I mean about checkpatch being fallible. It's also fallible in
other cases, like variable declarations via macro (understandably).

Expecting checkpatch to give zero warnings is simply unattainable,
unfortunately.

As you seem adamant about strict adherence to checkpatch, and I always try
to be accommodating where I can be, I suggest I fix everything _except
where it breaks the compilation_ does that work for you?

Thanks.

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from smtp-out1.suse.de (smtp-out1.suse.de [195.135.223.130])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 8BD0A133987;
	Fri, 18 Oct 2024 16:10:40 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=195.135.223.130
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729267843; cv=none; b=hgo30RTNl9+TM2YvQURXYvtxIyFe0/Z6m4D8Ujx07kSvHswQP6pLRjbR/7ybV3zVCOBw9JpdDJCglKj7Sp+MNLqo6yRZHEDJ3+0HkcRxihcGcdYb1FuVH/CbzpXyKpBFJHKk0C5g45lALRZhVnNd6dmQrsIpQvkQyn1Lwa0aahI=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729267843; c=relaxed/simple;
	bh=kTERkXy4JzRjieDtPT96BhnO/Z9tGFzxm2mTx8PdmjI=;
	h=Message-ID:Date:MIME-Version:Subject:To:Cc:References:From:
	 In-Reply-To:Content-Type; b=JbxqXSKyGXOU2XYduzOAsfQaFvjHXzol2Qn04XRnMBbU6Iz1cMnsB0P5l42Jbnc3hVe+sbdBSTIogkWXnsnwIvdFeCmwUTWXmIzQZkKRwUmoiRKe59SjkD7d0TDvzRtlJMIsqmw5pMA9T24IPRk/MxHX9Tfp077OR9kEJLB6HhA=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=none (p=none dis=none) header.from=suse.cz; spf=pass smtp.mailfrom=suse.cz; dkim=pass (1024-bit key) header.d=suse.cz header.i=@suse.cz header.b=OLnBD6FI; dkim=permerror (0-bit key) header.d=suse.cz header.i=@suse.cz header.b=0EyTKeHr; dkim=pass (1024-bit key) header.d=suse.cz header.i=@suse.cz header.b=OLnBD6FI; dkim=permerror (0-bit key) header.d=suse.cz header.i=@suse.cz header.b=0EyTKeHr; arc=none smtp.client-ip=195.135.223.130
Authentication-Results: smtp.subspace.kernel.org; dmarc=none (p=none dis=none) header.from=suse.cz
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=suse.cz
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=suse.cz header.i=@suse.cz header.b="OLnBD6FI";
	dkim=permerror (0-bit key) header.d=suse.cz header.i=@suse.cz header.b="0EyTKeHr";
	dkim=pass (1024-bit key) header.d=suse.cz header.i=@suse.cz header.b="OLnBD6FI";
	dkim=permerror (0-bit key) header.d=suse.cz header.i=@suse.cz header.b="0EyTKeHr"
Received: from imap1.dmz-prg2.suse.org (imap1.dmz-prg2.suse.org [IPv6:2a07:de40:b281:104:10:150:64:97])
	(using TLSv1.3 with cipher TLS_AES_256_GCM_SHA384 (256/256 bits)
	 key-exchange X25519 server-signature RSA-PSS (4096 bits) server-digest SHA256)
	(No client certificate requested)
	by smtp-out1.suse.de (Postfix) with ESMTPS id AE73B21B95;
	Fri, 18 Oct 2024 16:10:37 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=suse.cz; s=susede2_rsa;
	t=1729267837; h=from:from:reply-to:date:date:message-id:message-id:to:to:cc:cc:
	 mime-version:mime-version:content-type:content-type:
	 content-transfer-encoding:content-transfer-encoding:
	 in-reply-to:in-reply-to:references:references:autocrypt:autocrypt;
	bh=pZwgNyh5Sz+THCkuj2b3YclZKDHUE50f0u3axSvQI4g=;
	b=OLnBD6FIsyC3KZd83MQhFV2sbSe+RngPX1PSiTD6KNwc4PqXK0tHcxlzXaLclTKPip1/Rh
	u7Da6M4vKEvWgm0seUjKEh+PDARnXl+ZlWj5U8QND6LldFtmB8GsKXgGSTKrCMGjmsQfpo
	/CNS0TXKcpgqEl0xJ9Ef35UEIp4WL7U=
DKIM-Signature: v=1; a=ed25519-sha256; c=relaxed/relaxed; d=suse.cz;
	s=susede2_ed25519; t=1729267837;
	h=from:from:reply-to:date:date:message-id:message-id:to:to:cc:cc:
	 mime-version:mime-version:content-type:content-type:
	 content-transfer-encoding:content-transfer-encoding:
	 in-reply-to:in-reply-to:references:references:autocrypt:autocrypt;
	bh=pZwgNyh5Sz+THCkuj2b3YclZKDHUE50f0u3axSvQI4g=;
	b=0EyTKeHrQ0HxGRnpn92jVrGeHrrdvHSra9SIM144D3mzfXARV6+eCsrX5hEQChScwWvkyR
	dbRLQgXPuVkU1rDg==
Authentication-Results: smtp-out1.suse.de;
	dkim=pass header.d=suse.cz header.s=susede2_rsa header.b=OLnBD6FI;
	dkim=pass header.d=suse.cz header.s=susede2_ed25519 header.b=0EyTKeHr
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=suse.cz; s=susede2_rsa;
	t=1729267837; h=from:from:reply-to:date:date:message-id:message-id:to:to:cc:cc:
	 mime-version:mime-version:content-type:content-type:
	 content-transfer-encoding:content-transfer-encoding:
	 in-reply-to:in-reply-to:references:references:autocrypt:autocrypt;
	bh=pZwgNyh5Sz+THCkuj2b3YclZKDHUE50f0u3axSvQI4g=;
	b=OLnBD6FIsyC3KZd83MQhFV2sbSe+RngPX1PSiTD6KNwc4PqXK0tHcxlzXaLclTKPip1/Rh
	u7Da6M4vKEvWgm0seUjKEh+PDARnXl+ZlWj5U8QND6LldFtmB8GsKXgGSTKrCMGjmsQfpo
	/CNS0TXKcpgqEl0xJ9Ef35UEIp4WL7U=
DKIM-Signature: v=1; a=ed25519-sha256; c=relaxed/relaxed; d=suse.cz;
	s=susede2_ed25519; t=1729267837;
	h=from:from:reply-to:date:date:message-id:message-id:to:to:cc:cc:
	 mime-version:mime-version:content-type:content-type:
	 content-transfer-encoding:content-transfer-encoding:
	 in-reply-to:in-reply-to:references:references:autocrypt:autocrypt;
	bh=pZwgNyh5Sz+THCkuj2b3YclZKDHUE50f0u3axSvQI4g=;
	b=0EyTKeHrQ0HxGRnpn92jVrGeHrrdvHSra9SIM144D3mzfXARV6+eCsrX5hEQChScwWvkyR
	dbRLQgXPuVkU1rDg==
Received: from imap1.dmz-prg2.suse.org (localhost [127.0.0.1])
	(using TLSv1.3 with cipher TLS_AES_256_GCM_SHA384 (256/256 bits)
	 key-exchange X25519 server-signature RSA-PSS (4096 bits) server-digest SHA256)
	(No client certificate requested)
	by imap1.dmz-prg2.suse.org (Postfix) with ESMTPS id 6FB6513680;
	Fri, 18 Oct 2024 16:10:37 +0000 (UTC)
Received: from dovecot-director2.suse.de ([2a07:de40:b281:106:10:150:64:167])
	by imap1.dmz-prg2.suse.org with ESMTPSA
	id 9dDNGn2IEmd/VAAAD6G6ig
	(envelope-from <vbabka@suse.cz>); Fri, 18 Oct 2024 16:10:37 +0000
Message-ID: <e4985328-dbfa-4c47-9cf9-12aa89ba9798@suse.cz>
Date: Fri, 18 Oct 2024 18:10:37 +0200
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
User-Agent: Mozilla Thunderbird
Subject: Re: [PATCH 0/4] implement lightweight guard pages
Content-Language: en-US
To: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>,
 Andrew Morton <akpm@linux-foundation.org>
Cc: Suren Baghdasaryan <surenb@google.com>,
 "Liam R . Howlett" <Liam.Howlett@oracle.com>,
 Matthew Wilcox <willy@infradead.org>, "Paul E . McKenney"
 <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
 David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
 linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
 Richard Henderson <richard.henderson@linaro.org>,
 Ivan Kokshaysky <ink@jurassic.park.msu.ru>, Matt Turner
 <mattst88@gmail.com>, Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
 "James E . J . Bottomley" <James.Bottomley@HansenPartnership.com>,
 Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
 Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
 linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
 linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
 Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
 linux-kselftest@vger.kernel.org, Sidhartha Kumar
 <sidhartha.kumar@oracle.com>, Jeff Xu <jeffxu@chromium.org>,
 Christoph Hellwig <hch@infradead.org>, Linux API <linux-api@vger.kernel.org>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
From: Vlastimil Babka <vbabka@suse.cz>
Autocrypt: addr=vbabka@suse.cz; keydata=
 xsFNBFZdmxYBEADsw/SiUSjB0dM+vSh95UkgcHjzEVBlby/Fg+g42O7LAEkCYXi/vvq31JTB
 KxRWDHX0R2tgpFDXHnzZcQywawu8eSq0LxzxFNYMvtB7sV1pxYwej2qx9B75qW2plBs+7+YB
 87tMFA+u+L4Z5xAzIimfLD5EKC56kJ1CsXlM8S/LHcmdD9Ctkn3trYDNnat0eoAcfPIP2OZ+
 9oe9IF/R28zmh0ifLXyJQQz5ofdj4bPf8ecEW0rhcqHfTD8k4yK0xxt3xW+6Exqp9n9bydiy
 tcSAw/TahjW6yrA+6JhSBv1v2tIm+itQc073zjSX8OFL51qQVzRFr7H2UQG33lw2QrvHRXqD
 Ot7ViKam7v0Ho9wEWiQOOZlHItOOXFphWb2yq3nzrKe45oWoSgkxKb97MVsQ+q2SYjJRBBH4
 8qKhphADYxkIP6yut/eaj9ImvRUZZRi0DTc8xfnvHGTjKbJzC2xpFcY0DQbZzuwsIZ8OPJCc
 LM4S7mT25NE5kUTG/TKQCk922vRdGVMoLA7dIQrgXnRXtyT61sg8PG4wcfOnuWf8577aXP1x
 6mzw3/jh3F+oSBHb/GcLC7mvWreJifUL2gEdssGfXhGWBo6zLS3qhgtwjay0Jl+kza1lo+Cv
 BB2T79D4WGdDuVa4eOrQ02TxqGN7G0Biz5ZLRSFzQSQwLn8fbwARAQABzSBWbGFzdGltaWwg
 QmFia2EgPHZiYWJrYUBzdXNlLmN6PsLBlAQTAQoAPgIbAwULCQgHAwUVCgkICwUWAgMBAAIe
 AQIXgBYhBKlA1DSZLC6OmRA9UCJPp+fMgqZkBQJkBREIBQkRadznAAoJECJPp+fMgqZkNxIQ
 ALZRqwdUGzqL2aeSavbum/VF/+td+nZfuH0xeWiO2w8mG0+nPd5j9ujYeHcUP1edE7uQrjOC
 Gs9sm8+W1xYnbClMJTsXiAV88D2btFUdU1mCXURAL9wWZ8Jsmz5ZH2V6AUszvNezsS/VIT87
 AmTtj31TLDGwdxaZTSYLwAOOOtyqafOEq+gJB30RxTRE3h3G1zpO7OM9K6ysLdAlwAGYWgJJ
 V4JqGsQ/lyEtxxFpUCjb5Pztp7cQxhlkil0oBYHkudiG8j1U3DG8iC6rnB4yJaLphKx57NuQ
 PIY0Bccg+r9gIQ4XeSK2PQhdXdy3UWBr913ZQ9AI2usid3s5vabo4iBvpJNFLgUmxFnr73SJ
 KsRh/2OBsg1XXF/wRQGBO9vRuJUAbnaIVcmGOUogdBVS9Sun/Sy4GNA++KtFZK95U7J417/J
 Hub2xV6Ehc7UGW6fIvIQmzJ3zaTEfuriU1P8ayfddrAgZb25JnOW7L1zdYL8rXiezOyYZ8Fm
 ZyXjzWdO0RpxcUEp6GsJr11Bc4F3aae9OZtwtLL/jxc7y6pUugB00PodgnQ6CMcfR/HjXlae
 h2VS3zl9+tQWHu6s1R58t5BuMS2FNA58wU/IazImc/ZQA+slDBfhRDGYlExjg19UXWe/gMcl
 De3P1kxYPgZdGE2eZpRLIbt+rYnqQKy8UxlszsBNBFsZNTUBCACfQfpSsWJZyi+SHoRdVyX5
 J6rI7okc4+b571a7RXD5UhS9dlVRVVAtrU9ANSLqPTQKGVxHrqD39XSw8hxK61pw8p90pg4G
 /N3iuWEvyt+t0SxDDkClnGsDyRhlUyEWYFEoBrrCizbmahOUwqkJbNMfzj5Y7n7OIJOxNRkB
 IBOjPdF26dMP69BwePQao1M8Acrrex9sAHYjQGyVmReRjVEtv9iG4DoTsnIR3amKVk6si4Ea
 X/mrapJqSCcBUVYUFH8M7bsm4CSxier5ofy8jTEa/CfvkqpKThTMCQPNZKY7hke5qEq1CBk2
 wxhX48ZrJEFf1v3NuV3OimgsF2odzieNABEBAAHCwXwEGAEKACYCGwwWIQSpQNQ0mSwujpkQ
 PVAiT6fnzIKmZAUCZAUSmwUJDK5EZgAKCRAiT6fnzIKmZOJGEACOKABgo9wJXsbWhGWYO7mD
 8R8mUyJHqbvaz+yTLnvRwfe/VwafFfDMx5GYVYzMY9TWpA8psFTKTUIIQmx2scYsRBUwm5VI
 EurRWKqENcDRjyo+ol59j0FViYysjQQeobXBDDE31t5SBg++veI6tXfpco/UiKEsDswL1WAr
 tEAZaruo7254TyH+gydURl2wJuzo/aZ7Y7PpqaODbYv727Dvm5eX64HCyyAH0s6sOCyGF5/p
 eIhrOn24oBf67KtdAN3H9JoFNUVTYJc1VJU3R1JtVdgwEdr+NEciEfYl0O19VpLE/PZxP4wX
 PWnhf5WjdoNI1Xec+RcJ5p/pSel0jnvBX8L2cmniYnmI883NhtGZsEWj++wyKiS4NranDFlA
 HdDM3b4lUth1pTtABKQ1YuTvehj7EfoWD3bv9kuGZGPrAeFNiHPdOT7DaXKeHpW9homgtBxj
 8aX/UkSvEGJKUEbFL9cVa5tzyialGkSiZJNkWgeHe+jEcfRT6pJZOJidSCdzvJpbdJmm+eED
 w9XOLH1IIWh7RURU7G1iOfEfmImFeC3cbbS73LQEFGe1urxvIH5K/7vX+FkNcr9ujwWuPE9b
 1C2o4i/yZPLXIVy387EjA6GZMqvQUFuSTs/GeBcv0NjIQi8867H3uLjz+mQy63fAitsDwLmR
 EP+ylKVEKb0Q2A==
In-Reply-To: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 7bit
X-Rspamd-Queue-Id: AE73B21B95
X-Spam-Level: 
X-Spamd-Result: default: False [-4.51 / 50.00];
	BAYES_HAM(-3.00)[100.00%];
	NEURAL_HAM_LONG(-1.00)[-1.000];
	R_DKIM_ALLOW(-0.20)[suse.cz:s=susede2_rsa,suse.cz:s=susede2_ed25519];
	NEURAL_HAM_SHORT(-0.20)[-1.000];
	MIME_GOOD(-0.10)[text/plain];
	MX_GOOD(-0.01)[];
	DKIM_SIGNED(0.00)[suse.cz:s=susede2_rsa,suse.cz:s=susede2_ed25519];
	FUZZY_BLOCKED(0.00)[rspamd.com];
	RBL_SPAMHAUS_BLOCKED_OPENRESOLVER(0.00)[2a07:de40:b281:104:10:150:64:97:from];
	ARC_NA(0.00)[];
	TO_MATCH_ENVRCPT_ALL(0.00)[];
	MIME_TRACE(0.00)[0:+];
	SPAMHAUS_XBL(0.00)[2a07:de40:b281:104:10:150:64:97:from];
	FREEMAIL_ENVRCPT(0.00)[gmail.com,gmx.de];
	RCVD_TLS_ALL(0.00)[];
	RCPT_COUNT_TWELVE(0.00)[31];
	RCVD_COUNT_TWO(0.00)[2];
	FROM_EQ_ENVFROM(0.00)[];
	FROM_HAS_DN(0.00)[];
	FREEMAIL_CC(0.00)[google.com,oracle.com,infradead.org,kernel.org,redhat.com,kvack.org,vger.kernel.org,linux.dev,linaro.org,jurassic.park.msu.ru,gmail.com,alpha.franken.de,HansenPartnership.com,gmx.de,zankel.net,arndb.de,chromium.org];
	MID_RHS_MATCH_FROM(0.00)[];
	RCVD_VIA_SMTP_AUTH(0.00)[];
	RECEIVED_SPAMHAUS_BLOCKED_OPENRESOLVER(0.00)[2a07:de40:b281:106:10:150:64:167:received];
	DKIM_TRACE(0.00)[suse.cz:+];
	R_RATELIMIT(0.00)[to_ip_from(RLz1534diqmneu69wx1fp4cing)];
	TO_DN_SOME(0.00)[]
X-Rspamd-Server: rspamd2.dmz-prg2.suse.org
X-Rspamd-Action: no action
X-Spam-Score: -4.51
X-Spam-Flag: NO

+CC linux-api (also should on future revisions)

On 10/17/24 22:42, Lorenzo Stoakes wrote:
> Userland library functions such as allocators and threading implementations
> often require regions of memory to act as 'guard pages' - mappings which,
> when accessed, result in a fatal signal being sent to the accessing
> process.
> 
> The current means by which these are implemented is via a PROT_NONE mmap()
> mapping, which provides the required semantics however incur an overhead of
> a VMA for each such region.
> 
> With a great many processes and threads, this can rapidly add up and incur
> a significant memory penalty. It also has the added problem of preventing
> merges that might otherwise be permitted.
> 
> This series takes a different approach - an idea suggested by Vlasimil
> Babka (and before him David Hildenbrand and Jann Horn - perhaps more - the
> provenance becomes a little tricky to ascertain after this - please forgive
> any omissions!)  - rather than locating the guard pages at the VMA layer,
> instead placing them in page tables mapping the required ranges.
> 
> Early testing of the prototype version of this code suggests a 5 times
> speed up in memory mapping invocations (in conjunction with use of
> process_madvise()) and a 13% reduction in VMAs on an entirely idle android
> system and unoptimised code.
> 
> We expect with optimisation and a loaded system with a larger number of
> guard pages this could significantly increase, but in any case these
> numbers are encouraging.
> 
> This way, rather than having separate VMAs specifying which parts of a
> range are guard pages, instead we have a VMA spanning the entire range of
> memory a user is permitted to access and including ranges which are to be
> 'guarded'.
> 
> After mapping this, a user can specify which parts of the range should
> result in a fatal signal when accessed.
> 
> By restricting the ability to specify guard pages to memory mapped by
> existing VMAs, we can rely on the mappings being torn down when the
> mappings are ultimately unmapped and everything works simply as if the
> memory were not faulted in, from the point of view of the containing VMAs.
> 
> This mechanism in effect poisons memory ranges similar to hardware memory
> poisoning, only it is an entirely software-controlled form of poisoning.
> 
> Any poisoned region of memory is also able to 'unpoisoned', that is, to
> have its poison markers removed.
> 
> The mechanism is implemented via madvise() behaviour - MADV_GUARD_POISON
> which simply poisons ranges - and MADV_GUARD_UNPOISON - which clears this
> poisoning.
> 
> Poisoning can be performed across multiple VMAs and any existing mappings
> will be cleared, that is zapped, before installing the poisoned page table
> mappings.
> 
> There is no concept of 'nested' poisoning, multiple attempts to poison a
> range will, after the first poisoning, have no effect.
> 
> Importantly, unpoisoning of poisoned ranges has no effect on non-poisoned
> memory, so a user can safely unpoison a range of memory and clear only
> poison page table mappings leaving the rest intact.
> 
> The actual mechanism by which the page table entries are specified makes
> use of existing logic - PTE markers, which are used for the userfaultfd
> UFFDIO_POISON mechanism.
> 
> Unfortunately PTE_MARKER_POISONED is not suited for the guard page
> mechanism as it results in VM_FAULT_HWPOISON semantics in the fault
> handler, so we add our own specific PTE_MARKER_GUARD and adapt existing
> logic to handle it.
> 
> We also extend the generic page walk mechanism to allow for installation of
> PTEs (carefully restricted to memory management logic only to prevent
> unwanted abuse).
> 
> We ensure that zapping performed by, for instance, MADV_DONTNEED, does not
> remove guard poison markers, nor does forking (except when VM_WIPEONFORK is
> specified for a VMA which implies a total removal of memory
> characteristics).
> 
> It's important to note that the guard page implementation is emphatically
> NOT a security feature, so a user can remove the poisoning if they wish. We
> simply implement it in such a way as to provide the least surprising
> behaviour.
> 
> An extensive set of self-tests are provided which ensure behaviour is as
> expected and additionally self-documents expected behaviour of poisoned
> ranges.
> 
> Suggested-by: Vlastimil Babka <vbabka@suze.cz>

Please fix the domain typo (also in patch 3 :)

Thanks for implementing this,
Vlastimil

> Suggested-by: Jann Horn <jannh@google.com>
> Suggested-by: David Hildenbrand <david@redhat.com>
> 
> v1
> * Un-RFC'd as appears no major objections to approach but rather debate on
>   implementation.
> * Fixed issue with arches which need mmu_context.h and
>   tlbfush.h. header imports in pagewalker logic to be able to use
>   update_mmu_cache() as reported by the kernel test bot.
> * Added comments in page walker logic to clarify who can use
>   ops->install_pte and why as well as adding a check_ops_valid() helper
>   function, as suggested by Christoph.
> * Pass false in full parameter in pte_clear_not_present_full() as suggested
>   by Jann.
> * Stopped erroneously requiring a write lock for the poison operation as
>   suggested by Jann and Suren.
> * Moved anon_vma_prepare() to the start of madvise_guard_poison() to be
>   consistent with how this is used elsewhere in the kernel as suggested by
>   Jann.
> * Avoid returning -EAGAIN if we are raced on page faults, just keep looping
>   and duck out if a fatal signal is pending or a conditional reschedule is
>   needed, as suggested by Jann.
> * Avoid needlessly splitting huge PUDs and PMDs by specifying
>   ACTION_CONTINUE, as suggested by Jann.
> 
> RFC
> https://lore.kernel.org/all/cover.1727440966.git.lorenzo.stoakes@oracle.com/
> 
> Lorenzo Stoakes (4):
>   mm: pagewalk: add the ability to install PTEs
>   mm: add PTE_MARKER_GUARD PTE marker
>   mm: madvise: implement lightweight guard page mechanism
>   selftests/mm: add self tests for guard page feature
> 
>  arch/alpha/include/uapi/asm/mman.h       |    3 +
>  arch/mips/include/uapi/asm/mman.h        |    3 +
>  arch/parisc/include/uapi/asm/mman.h      |    3 +
>  arch/xtensa/include/uapi/asm/mman.h      |    3 +
>  include/linux/mm_inline.h                |    2 +-
>  include/linux/pagewalk.h                 |   18 +-
>  include/linux/swapops.h                  |   26 +-
>  include/uapi/asm-generic/mman-common.h   |    3 +
>  mm/hugetlb.c                             |    3 +
>  mm/internal.h                            |    6 +
>  mm/madvise.c                             |  168 ++++
>  mm/memory.c                              |   18 +-
>  mm/mprotect.c                            |    3 +-
>  mm/mseal.c                               |    1 +
>  mm/pagewalk.c                            |  200 ++--
>  tools/testing/selftests/mm/.gitignore    |    1 +
>  tools/testing/selftests/mm/Makefile      |    1 +
>  tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
>  18 files changed, 1564 insertions(+), 66 deletions(-)
>  create mode 100644 tools/testing/selftests/mm/guard-pages.c
> 
> --
> 2.46.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0b-00069f02.pphosted.com (mx0b-00069f02.pphosted.com [205.220.177.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 37DC6202F6B;
	Fri, 18 Oct 2024 16:18:37 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.177.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729268320; cv=fail; b=bUFkNsSVxpanlFOGgiIahcjhc5wtDor9G3TD+Qw7uBDhN3MoxJVvZAjW+/BMs7jji/NJba2CGYKDo5BbEiKxco4sg1DeWQ4k6gWKcjVeMwG1Zp7NCLmAP/ODkq/TL3it2BW/R7PTXZ2POdCw3Ai8fbJQ2UnA1sl3CfD5LuWOnq4=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729268320; c=relaxed/simple;
	bh=pQyuVBqnw5UKUXwzNpMb4+60eWGZ6/i0U7ef7tZDZmA=;
	h=Date:From:To:Cc:Subject:Message-ID:References:Content-Type:
	 Content-Disposition:In-Reply-To:MIME-Version; b=rNXpYhNTwqTLYiv7N/SiGlAS8TQ97c7FY1QEWKfKMQhIySA/MXTrZAqzTA/xpzYW3rNxcI7bPpKnPJYTw+6J1iyyYSgl0vk37miBRh4cwSaeZUXhBjv/fPAPoAP3xEiDbUjMtYSBmGT9mLlyela2HGpuABdRTy+vf6PIE8/JTZI=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=MI8kY/VU; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=CLIYt5fm; arc=fail smtp.client-ip=205.220.177.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="MI8kY/VU";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="CLIYt5fm"
Received: from pps.filterd (m0246630.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49IEBggq019370;
	Fri, 18 Oct 2024 16:18:05 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-type:date:from:in-reply-to:message-id:mime-version
	:references:subject:to; s=corp-2023-11-20; bh=RcEz8PXC4wRAg4GbNH
	NdkMfIhFeBaYGb4VDKEdC1/0c=; b=MI8kY/VUWvtEOpPOESvrW4foG3XNQNABMi
	uvXWoS0sR3L6izyDrIWJcmOYMhlazMbQbsza6rQrHV4hDau2e+NjVeB/of4mE6ct
	BjoMEMePHB824TmZ6/12LOOifomKGHBfHjOsRHG8YcB3lP6Dw2tB+avW0s4LqCvK
	q6bCaV8hWhKa05zEbAL+Ygu70/G+GB3+r6X3Iq5MMg9giQzwGT6CockWvUjbESt6
	kfDe4/iANj3WFza9h/6bW7roBeycaWnVqgubzltKizbbL3nNXpctS8WMmcQTTr55
	ur2YHp+R5E7hknmIcHstfnyRCUVq2ZZPr0VsVWBAAtoJMrGY6PhA==
Received: from phxpaimrmta01.imrmtpd1.prodappphxaev1.oraclevcn.com (phxpaimrmta01.appoci.oracle.com [138.1.114.2])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427fhcrtw4-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 16:18:04 +0000 (GMT)
Received: from pps.filterd (phxpaimrmta01.imrmtpd1.prodappphxaev1.oraclevcn.com [127.0.0.1])
	by phxpaimrmta01.imrmtpd1.prodappphxaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49IFn2wm026287;
	Fri, 18 Oct 2024 16:18:03 GMT
Received: from nam12-bn8-obe.outbound.protection.outlook.com (mail-bn8nam12lp2169.outbound.protection.outlook.com [104.47.55.169])
	by phxpaimrmta01.imrmtpd1.prodappphxaev1.oraclevcn.com (PPS) with ESMTPS id 427fjbsqb1-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 16:18:03 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=fWtexNB7S1hjW7WTUxJ3wk7KP9CPjLml/dkA+UjL3Z8NRjrKI4z8v6v+Cpuk3CrWX9qQNa6L3vEQV6R8jGPFAvCjKcH2x6P1XuMpEQItg1B2o5NCImkPfR5yF1So7oQQDOLLmRnp1268fnC/9QR6RvVs2vqntc4ykGM9LiGzmjd6C8YT/u+vntk4TIuKrJEuEVkhsxux7tQEeoaw7xHWRpPZRB5gm4Qpklj0eOnArDDNzVMn8jda5xnIvpaK24TxHGFiW57fBJrNQzKHigkUVNmVpc9XES2CsQxyfKV9QmaXQpTRsvHZawymAtGCdWl7/ZZxPNouZwJLcIqZc4AbRQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=RcEz8PXC4wRAg4GbNHNdkMfIhFeBaYGb4VDKEdC1/0c=;
 b=M1RPyKX9y6tx9P4/FhhwjypGRavaQhyIdmMxvr58xQdr7QOQfSkebNasROL+eAgbsOS+Yn0MuEuABmAL7A1qiH+q2r8cMUlt47eHZBBmMZvA6z2wx6rrmypWCPV/eUfKfGCPmWaSRz8MyBh0d6lu+V/bzgCD9KnLRFmR4aernMpDCpxalkXwv1JzBySa2xDsmtYlf/9tmvHcng6RUIWQJsCzBUkQA1aBFH8o5czGyF1P0/HW6ICDhYmr5zMs8jr0sz7egacIdgMzUjTd51Z006jDRSuhN7rLCl11NsyRKCCrjZlUN0kaXhFNy3iIfuAHgILDEG0HhEMo9FxldIHwTQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=RcEz8PXC4wRAg4GbNHNdkMfIhFeBaYGb4VDKEdC1/0c=;
 b=CLIYt5fmomsjJENmIO5GsfilsNOyzV/fmotKGBOQx6xIKO8tFG8Y1ztzGN945rQ38V8z0AgGYNto3u1NxxdXvfx6pdiw4VeukeJo0Qy5cnGhvr7R+l/XOVs1Yd5BAaFyXWdnmPLoMvMVD/H8w+h+wBuhQ6vVSu/7r7QP6j3jYSo=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by PH0PR10MB5895.namprd10.prod.outlook.com (2603:10b6:510:14c::22) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.23; Fri, 18 Oct
 2024 16:18:00 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Fri, 18 Oct 2024
 16:18:00 +0000
Date: Fri, 18 Oct 2024 17:17:56 +0100
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Vlastimil Babka <vbabka@suse.cz>
Cc: Andrew Morton <akpm@linux-foundation.org>,
        Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>,
        Linux API <linux-api@vger.kernel.org>
Subject: Re: [PATCH 0/4] implement lightweight guard pages
Message-ID: <4b5382fd-e553-4fef-a7c7-a2d3130b948d@lucifer.local>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <e4985328-dbfa-4c47-9cf9-12aa89ba9798@suse.cz>
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <e4985328-dbfa-4c47-9cf9-12aa89ba9798@suse.cz>
X-ClientProxiedBy: LO2P265CA0303.GBRP265.PROD.OUTLOOK.COM
 (2603:10a6:600:a5::27) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|PH0PR10MB5895:EE_
X-MS-Office365-Filtering-Correlation-Id: 64f0ae9a-7d9f-4662-59e6-08dcef906f1b
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam:
	BCL:0;ARA:13230040|376014|7416014|10070799003|366016|1800799024;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?NI+o16iFJvdlcdujYcMC3pAo+/pYfdBGab8u67C097Q01hXwuR2Ac68pdSt3?=
 =?us-ascii?Q?n/LlPte30u3PqztHYSK+lfPjzEykzGCkdQhJKN6FOLCD8xA4lgt3+cRfwrZl?=
 =?us-ascii?Q?1mBLqMMu1epKwGEmNkQ2Ye3de3QGt6Zcnq2wBmntbm8gQ/KJ95HYCu+8Wxi2?=
 =?us-ascii?Q?QgYpYvrZ6EtVheZjMRRbPIxKJwTKu/LJZ6WObDcjT3dfK2iNzSA/LDJmUM2i?=
 =?us-ascii?Q?Q+n1v+BlfhICvAlYzcIOvSolSMFVL15AKL9IJCziJ+UfU83w55fzWZfh1TaQ?=
 =?us-ascii?Q?CNAhMQqiPzDo2g+e1Hd9c08LEp22jyrwpUjRB8RLzFJcIXwl6gxZdwr36cdu?=
 =?us-ascii?Q?xhpxmV33Z7ErhOZPZeHekgKTAe0miBc21rYlLxAkeIzrgtNcc759AgH8eyfD?=
 =?us-ascii?Q?AuB48yWmbixfrNdepnJ7aKZLXI4UpXu5HAI1w85uR5kViquqVO/WRbeQmMHW?=
 =?us-ascii?Q?KNcGrhqxn8VpiXc5S0KlIgTfgpNFPWbfbLdbJf0taIZI3A0d1YokhXaqv88z?=
 =?us-ascii?Q?rRIDQLLfTCbuRa/2s/rtVz7CU1KRNcoaQGCs9BnOdTWIJmQvVKHtRK5UNmvW?=
 =?us-ascii?Q?x0jTQMd9MNHyl+s4keMu3QY7dTIh35jp2R745OkODVYbnXsM/zfExCVOemeG?=
 =?us-ascii?Q?ChrTmc0ZeyzC3GmQGTN2QMUPFGBr4KODb1X2gndvH6QXvuKbgxZK+9KWQp0H?=
 =?us-ascii?Q?bPu9Ri0DemMm8+VromzYpYG++15UShVy9Q0d99lv6PnnLeExnfYbBYbuHorq?=
 =?us-ascii?Q?nimayNFOS97Cu4AxM/YiFeIAHrxszwodW0Efcws8ETuNVCN8zkd41yY2hujR?=
 =?us-ascii?Q?6gdBmgZ3hRiE5GNabtDourFNNE7aTvRzjKetLfyBruUN8hNOr3qtgIwu/1n1?=
 =?us-ascii?Q?kLEG6F8HHd97AKcCC5vVcH+6gQJQu5S7JGtyxXr0OAoHQHHYZ2NPJb/4lLBs?=
 =?us-ascii?Q?gdG6HDx5GkT0w2WGUdSZfnDPDRZFoFKbCtgrXoqhKLgtyxs4sPz7MVJmdUn3?=
 =?us-ascii?Q?N1bKi9NjEMcNL/4g2WFbkKQ+j4ClzUQwr6cEvd6JtyRUwPZj5/3z6NSJ3v6q?=
 =?us-ascii?Q?yBXhome2N5GRR/8vlUDy/Qp/yAq5UJb5wRnqN+5WuTJ4P8RHzjzKoFOXT4hn?=
 =?us-ascii?Q?6meaJAYauOpTpzC8255VRWMtN5OBUQ0mlNa+tJ5GriUe0iIoxsoBvJN4O69M?=
 =?us-ascii?Q?VzyQBYqZ24x2Zqa79L9e4nbhkv7S6t42PoT60jruKMtvtPqIQlVTcaIVVvwk?=
 =?us-ascii?Q?V6sKnpP6CYT4GUxw/FQHVLHssm5qDuLvYqFjwOLQJ4gN9oBNuwNi5/6jA/sm?=
 =?us-ascii?Q?H98dpORyQk3RbYp+qZWUKRa4?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(7416014)(10070799003)(366016)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?tsKWWQD3RNfJ0JMbxTsL3/kEmTgGbRPZTRRvn0n8D1f3ixjP1k2iOlVw/+IG?=
 =?us-ascii?Q?FXw9eYAWA0+EiPyfD73MwmUy6itvt6X/u2G2jpkQbQ7z8uIcxMbBiFoqYiLw?=
 =?us-ascii?Q?XmvYQU/4/GfIEiYKwQ/gQFB0mnBlHESGtRSgUsaia8XUjOtWflpYOS80VUlZ?=
 =?us-ascii?Q?ASqIJSE1pf9rKzQkDFEbQLiBqP6WqBJUyQmUC+NEHJnR3+SoGjTaYc5w++2x?=
 =?us-ascii?Q?3F8MEDJRjs+M+VB7Z74flcxyl0+TAsIrEAu6EjXN9l4x8fzqIQbIJhueymzD?=
 =?us-ascii?Q?+BRxxYgsJFB0c5vN3V440zp1ZipFlDMo0Ds7kqn/UZeOq+Fu1D6gHD5ZQzeL?=
 =?us-ascii?Q?4YymbXaZcHSRRvn1kcwwu/VkcvNbZ7z3tQ8wXmqBU2EaaHfpRMSa9ADDX31R?=
 =?us-ascii?Q?QlZGIwzbMf753aGJqiTelnSz3Ktu+p+6K11SErIJgZJfLaLpAuJw6/SJit+Q?=
 =?us-ascii?Q?2xS6NSh2o21hyR53JCcXi2zcUemd0LogC2SI0WU+JvNCaTDnabESSBJX50ZN?=
 =?us-ascii?Q?QLxkFxBPvbWTr2wK3Kmzw5fZ4vjK4nZzyHL2+6unDnN5ANCU27tSO1A47Iey?=
 =?us-ascii?Q?METM/FxtflhOU3UbnPdJtW6OojLszde6oecTWzVjJSCyXhtR9sFnmkL7B9d8?=
 =?us-ascii?Q?MgrHQrtmFV/aIgWFr26obzZ/i9jd+dklMwOC36VrnNVkzRzP8aag4+pCzqMa?=
 =?us-ascii?Q?OcZ2Z2zf+MmOTe49Otk7Ke5PT+R1eirnympTOtCDtuBm7EPffVzIlJlU2fkq?=
 =?us-ascii?Q?nCXbeAXHOVtJesjmV2EYftbf1bhws6c8ytPVw9Wt8SIDezLMA7nBzq1jhaWF?=
 =?us-ascii?Q?AWT8nQW0Kmo4fzeFRWCIhDDIm1RmVPg1O3dZScTBGeszqH4V8LHZqIO4Puz0?=
 =?us-ascii?Q?VhZdAhRYZh/RLh6qvp7SCb52N8g0n8FaHU78EjYFYWPRoAVTmUk0LHk+zgxU?=
 =?us-ascii?Q?6n6nHHvq5mTyqCP9QRrD0mzCfZ9HirdVOc1FtPFrLnay4ELdJlmn4h2Ef0rp?=
 =?us-ascii?Q?DfJHjx2jNy4e+gb1Tr83rkuid6l+igWMUXBSMOhytqUJk5XJXMTCd5NBRn4K?=
 =?us-ascii?Q?flvX1JHMzag7ahrR2RDxUEYr1ljMqhPyw7OnE5vDLpQZfL3+4bZQEydiHPZ9?=
 =?us-ascii?Q?qQ084t369Uk8qFkmClw1HmYTcLbsCA8UI4vGi9N1diABo4r1sk9COJwB2e7j?=
 =?us-ascii?Q?mXlAnBuROGnH7AZuMC0tWteZ7xP1ugx6J2JQiqCpcvm4VAROo4H3K5p0xw6H?=
 =?us-ascii?Q?4yLAXGtzijI+6pUvp9BSWZwpKYwA50i0y6uBbh7X1y/9M029WxmF2KQTmUFA?=
 =?us-ascii?Q?eUEB7Gdm2b4drjEagZW4X1PadlAAbmj1hcR/JvW5dpvQlTZfD0lroXsecvB2?=
 =?us-ascii?Q?Mka5fc6cZn1mDPBz/KeTwLWmBPfQkdLDZYf2PoUbi2LYzgAUXkguKQUnhGZE?=
 =?us-ascii?Q?OfLpKEPfXsRn0+LAO9uwhalwwGvLPyXJKMSg7/sD5WdOwoCwZ6BGZ5IJU3oy?=
 =?us-ascii?Q?0FlsksYwS5GPIIQfwcOjzCxAC/mLq0D/93F6GGu26WJ43N1KFl/wNR82/U5p?=
 =?us-ascii?Q?5YjDFvHw/ATG70INhpPSWLLqc/uUqR13QGFAila1l2YCYW1Biq4v8AWiNvHN?=
 =?us-ascii?Q?+1RO5kQp+jmc+9OnlU78Q1W/s47UBYcDy38p8hvJhMOUrcPBtQacSyC/49Ld?=
 =?us-ascii?Q?73UdMw=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	ciHQi2Jl41bwu9Ott5qsw1iadcjLtKvJJQ2hsaodB1NFJSb6vABJzSJkEgo14YeulrzAeeyOERmSDtp7eUzGGpsYBAdMkNxSBSKs0NF0G44MGf2AtJYkuQOg+/Elw9HjaSbV95KlRKtUNDBgYpUb7vIBkhKpaHxxwU3AL6q8AsKoQL89jW9U5CZB0oIqXxbT7O6Eq0C5WIc3AhraS0WAO82eyOK+pecgf179vqAUQIf9JFejLmxh2IxVqRZXinirC9CUwvBwp5Ik4fLRNF/HIPfnkUEtCfrPEu5FDW5p22AtRHoBPPHDVJc0z7hurxSAryBnXig99El8t3bxnnbWQ/cv7SpOJ53tN5X3rChfFXeChHDwU/MUBkLryXleuWtWUVYCzbTqviUfeozn1cNTZ/XNbdvmAufgLrVhiKDtAl9QiHNrShEVxkueKT/Tp44J5hCS+qa8YkrVu9MfMEP51GfH9HrochZdmqlfJBgv5LhU1j5lULuWuib2H/v31IbWqWjEDFcD0h3fgCzYFsQiWGi2ShPFHgjtnvjkolbvz2ITJ8cmPxHhPVGZa10pb8FGyFSScyd0U6nYjBQGH5qI/46PNEI86GmLCPodfqoPLU4=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 64f0ae9a-7d9f-4662-59e6-08dcef906f1b
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Oct 2024 16:18:00.1302
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: Z/Nid4AoRKjx094r/7sM/GSxu3uX13GrohRi7Eqq1HHl0bTT1IJGSUsfeQhxui7qLKHxoPOM0BlR34fOKJoz5S4QDdXuQsqSfAdUZw0c0Yk=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH0PR10MB5895
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-18_11,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 mlxscore=0 malwarescore=0 adultscore=0
 bulkscore=0 spamscore=0 mlxlogscore=868 phishscore=0 suspectscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2409260000
 definitions=main-2410180104
X-Proofpoint-GUID: oPw0X9r32Qb23mJZ2Psg130M6B9khBKy
X-Proofpoint-ORIG-GUID: oPw0X9r32Qb23mJZ2Psg130M6B9khBKy

On Fri, Oct 18, 2024 at 06:10:37PM +0200, Vlastimil Babka wrote:
> +CC linux-api (also should on future revisions)
>

They're cc'd :) assuming Linux API <linux-api@vger.kernel.org> is correct
right?

> On 10/17/24 22:42, Lorenzo Stoakes wrote:
> > Userland library functions such as allocators and threading implementations
> > often require regions of memory to act as 'guard pages' - mappings which,
> > when accessed, result in a fatal signal being sent to the accessing
> > process.
> >
> > The current means by which these are implemented is via a PROT_NONE mmap()
> > mapping, which provides the required semantics however incur an overhead of
> > a VMA for each such region.
> >
> > With a great many processes and threads, this can rapidly add up and incur
> > a significant memory penalty. It also has the added problem of preventing
> > merges that might otherwise be permitted.
> >
> > This series takes a different approach - an idea suggested by Vlasimil
> > Babka (and before him David Hildenbrand and Jann Horn - perhaps more - the
> > provenance becomes a little tricky to ascertain after this - please forgive
> > any omissions!)  - rather than locating the guard pages at the VMA layer,
> > instead placing them in page tables mapping the required ranges.
> >
> > Early testing of the prototype version of this code suggests a 5 times
> > speed up in memory mapping invocations (in conjunction with use of
> > process_madvise()) and a 13% reduction in VMAs on an entirely idle android
> > system and unoptimised code.
> >
> > We expect with optimisation and a loaded system with a larger number of
> > guard pages this could significantly increase, but in any case these
> > numbers are encouraging.
> >
> > This way, rather than having separate VMAs specifying which parts of a
> > range are guard pages, instead we have a VMA spanning the entire range of
> > memory a user is permitted to access and including ranges which are to be
> > 'guarded'.
> >
> > After mapping this, a user can specify which parts of the range should
> > result in a fatal signal when accessed.
> >
> > By restricting the ability to specify guard pages to memory mapped by
> > existing VMAs, we can rely on the mappings being torn down when the
> > mappings are ultimately unmapped and everything works simply as if the
> > memory were not faulted in, from the point of view of the containing VMAs.
> >
> > This mechanism in effect poisons memory ranges similar to hardware memory
> > poisoning, only it is an entirely software-controlled form of poisoning.
> >
> > Any poisoned region of memory is also able to 'unpoisoned', that is, to
> > have its poison markers removed.
> >
> > The mechanism is implemented via madvise() behaviour - MADV_GUARD_POISON
> > which simply poisons ranges - and MADV_GUARD_UNPOISON - which clears this
> > poisoning.
> >
> > Poisoning can be performed across multiple VMAs and any existing mappings
> > will be cleared, that is zapped, before installing the poisoned page table
> > mappings.
> >
> > There is no concept of 'nested' poisoning, multiple attempts to poison a
> > range will, after the first poisoning, have no effect.
> >
> > Importantly, unpoisoning of poisoned ranges has no effect on non-poisoned
> > memory, so a user can safely unpoison a range of memory and clear only
> > poison page table mappings leaving the rest intact.
> >
> > The actual mechanism by which the page table entries are specified makes
> > use of existing logic - PTE markers, which are used for the userfaultfd
> > UFFDIO_POISON mechanism.
> >
> > Unfortunately PTE_MARKER_POISONED is not suited for the guard page
> > mechanism as it results in VM_FAULT_HWPOISON semantics in the fault
> > handler, so we add our own specific PTE_MARKER_GUARD and adapt existing
> > logic to handle it.
> >
> > We also extend the generic page walk mechanism to allow for installation of
> > PTEs (carefully restricted to memory management logic only to prevent
> > unwanted abuse).
> >
> > We ensure that zapping performed by, for instance, MADV_DONTNEED, does not
> > remove guard poison markers, nor does forking (except when VM_WIPEONFORK is
> > specified for a VMA which implies a total removal of memory
> > characteristics).
> >
> > It's important to note that the guard page implementation is emphatically
> > NOT a security feature, so a user can remove the poisoning if they wish. We
> > simply implement it in such a way as to provide the least surprising
> > behaviour.
> >
> > An extensive set of self-tests are provided which ensure behaviour is as
> > expected and additionally self-documents expected behaviour of poisoned
> > ranges.
> >
> > Suggested-by: Vlastimil Babka <vbabka@suze.cz>
>
> Please fix the domain typo (also in patch 3 :)
>

Damnnn it! I can't believe I left that in. Sorry about that! Will fix on
respin.

Hopefully not to suse.cs ;)

> Thanks for implementing this,
> Vlastimil

Thanks!

>
> > Suggested-by: Jann Horn <jannh@google.com>
> > Suggested-by: David Hildenbrand <david@redhat.com>
> >
> > v1
> > * Un-RFC'd as appears no major objections to approach but rather debate on
> >   implementation.
> > * Fixed issue with arches which need mmu_context.h and
> >   tlbfush.h. header imports in pagewalker logic to be able to use
> >   update_mmu_cache() as reported by the kernel test bot.
> > * Added comments in page walker logic to clarify who can use
> >   ops->install_pte and why as well as adding a check_ops_valid() helper
> >   function, as suggested by Christoph.
> > * Pass false in full parameter in pte_clear_not_present_full() as suggested
> >   by Jann.
> > * Stopped erroneously requiring a write lock for the poison operation as
> >   suggested by Jann and Suren.
> > * Moved anon_vma_prepare() to the start of madvise_guard_poison() to be
> >   consistent with how this is used elsewhere in the kernel as suggested by
> >   Jann.
> > * Avoid returning -EAGAIN if we are raced on page faults, just keep looping
> >   and duck out if a fatal signal is pending or a conditional reschedule is
> >   needed, as suggested by Jann.
> > * Avoid needlessly splitting huge PUDs and PMDs by specifying
> >   ACTION_CONTINUE, as suggested by Jann.
> >
> > RFC
> > https://lore.kernel.org/all/cover.1727440966.git.lorenzo.stoakes@oracle.com/
> >
> > Lorenzo Stoakes (4):
> >   mm: pagewalk: add the ability to install PTEs
> >   mm: add PTE_MARKER_GUARD PTE marker
> >   mm: madvise: implement lightweight guard page mechanism
> >   selftests/mm: add self tests for guard page feature
> >
> >  arch/alpha/include/uapi/asm/mman.h       |    3 +
> >  arch/mips/include/uapi/asm/mman.h        |    3 +
> >  arch/parisc/include/uapi/asm/mman.h      |    3 +
> >  arch/xtensa/include/uapi/asm/mman.h      |    3 +
> >  include/linux/mm_inline.h                |    2 +-
> >  include/linux/pagewalk.h                 |   18 +-
> >  include/linux/swapops.h                  |   26 +-
> >  include/uapi/asm-generic/mman-common.h   |    3 +
> >  mm/hugetlb.c                             |    3 +
> >  mm/internal.h                            |    6 +
> >  mm/madvise.c                             |  168 ++++
> >  mm/memory.c                              |   18 +-
> >  mm/mprotect.c                            |    3 +-
> >  mm/mseal.c                               |    1 +
> >  mm/pagewalk.c                            |  200 ++--
> >  tools/testing/selftests/mm/.gitignore    |    1 +
> >  tools/testing/selftests/mm/Makefile      |    1 +
> >  tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
> >  18 files changed, 1564 insertions(+), 66 deletions(-)
> >  create mode 100644 tools/testing/selftests/mm/guard-pages.c
> >
> > --
> > 2.46.2
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0a-00069f02.pphosted.com (mx0a-00069f02.pphosted.com [205.220.165.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 9FC851D2B0E;
	Fri, 18 Oct 2024 16:23:45 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.165.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729268627; cv=fail; b=U/TLPe21kAE0216dMZ5XA1Bzpug9r5WvIV5I88p6+AMq6UjSQjyx+K0tT0+/IW/pfOfGdSUktrWWj2terPp27vwNhQFN13e0GYU+rDAigmIRJNU7jVJh5ENge0JfahGUH7nscWd6MMy3i+YgHfy/zKedy0vD0EzDi63cLHf1Mxs=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729268627; c=relaxed/simple;
	bh=k5YHULhSLFKQAD4P54ao/6kJCEIHdmY3C4QSP1Wefds=;
	h=Date:From:To:Cc:Subject:Message-ID:References:Content-Type:
	 Content-Disposition:In-Reply-To:MIME-Version; b=bqTYDSTMBfn8yeh+phcwAAdMMNbmiK23UJlGWY4kOQAut4cZ4UnrAUYI7Qs9H1lQ0UklVsf9ZuIsq0EmotbGaKpYpBfCu6QPNoBy/Oz9yx9q2FAJCgJU7tyq/LK1bP7ooPx2I/U8ly0PfRX5LW4Er1oGY8Eg2GlYuPx+pT2bqTY=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=H+hVYuUi; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=aevYmz1p; arc=fail smtp.client-ip=205.220.165.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="H+hVYuUi";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="aevYmz1p"
Received: from pps.filterd (m0246617.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49IEBc5V017019;
	Fri, 18 Oct 2024 16:23:02 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-transfer-encoding:content-type:date:from:in-reply-to
	:message-id:mime-version:references:subject:to; s=
	corp-2023-11-20; bh=yW9pexR5uleCXDs098JRKXkO+Z28DmM3Y3TzeDrtRlc=; b=
	H+hVYuUi0zZrfc3ROG13k+SwdsXD2wMUjydiIc/cHrWYVvV5KikUUbT6HpunUMi1
	A6IOshVnMua+fYGsqxSkFhJJLSiSQkNkKoL2DaFRdjTPy3HnnmC+dZFmRA4c3tq7
	eo+7O2QPvs1dQ/1WxBxvU8EHZABXnQ88QB9VhFgewRXvnLJRqpEAMEXKOoi0c25P
	V36E2zzG9c5xZ/lit81VnyxA/yrce4USmu0JUethFkJIYTLYixvH2MtleERgNRdS
	ybCk/QYoW1tS2i8xRaTGo5y9UumSSsLlX4BALS9doPcUxHIg3xBaDjmyBgatQqp/
	Cl1L2oFQ4ZhvDyCoLHJmSw==
Received: from iadpaimrmta02.imrmtpd1.prodappiadaev1.oraclevcn.com (iadpaimrmta02.appoci.oracle.com [147.154.18.20])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427hnth72y-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 16:23:02 +0000 (GMT)
Received: from pps.filterd (iadpaimrmta02.imrmtpd1.prodappiadaev1.oraclevcn.com [127.0.0.1])
	by iadpaimrmta02.imrmtpd1.prodappiadaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49IG34HT027269;
	Fri, 18 Oct 2024 16:23:01 GMT
Received: from nam10-bn7-obe.outbound.protection.outlook.com (mail-bn7nam10lp2041.outbound.protection.outlook.com [104.47.70.41])
	by iadpaimrmta02.imrmtpd1.prodappiadaev1.oraclevcn.com (PPS) with ESMTPS id 427fjjdhxw-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 16:23:01 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=Htp/jnZ8IUwUsdMoWeIiJKJohyxESGB+4yWhhXhOxAwZhU0lxaKK74Pewxca+ehayVVbUFlHtdt0DsvxEF+4i35BYqGMPTTzurOU8MBJLy/xwqcuDFJjMOLZ6xwG/w+w880G8kaz+NWSPHCl8PiJATnaP1ECBaCPcHf2o7UUdCrfE3gDsiDkHXqGbAeI2Q72O5i4aNza//7RsNtBj75eMbykaxkoDsSDgNdGTmkQeMiw8m4jZOHQS0iHtT2lUoq4m+wRWGhPio1OL/7eHj0U6C1dV5fjwRb/sErMgFToalakmpopjz0c1UhdJdbSrSh4Hl9oIsRhogmg+niuuQLdnA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=yW9pexR5uleCXDs098JRKXkO+Z28DmM3Y3TzeDrtRlc=;
 b=hVcG6viX6zGrrAiUwKN5lOnmRxCT4BoCEhfkIdatnzLeur02h469ieEe4VCkgIgJ+9wN1C5dbAF7n0OfkRFShDKQgMXP9BTV/pwApX98bgAyHOWPnOFk4GmOzHVYdpkAZjlfTzVqD4FES5Bu5Hv51of4LHrB2sI2U+7Uin6bbBmczPEKOc8Ar8mWR2QmLQ3r6+8FFb4ApnjNCnID422AM7Sc4Fb4HusHLHYONiCnucUwgtGvMrwmzsUTHYVFGKqwR5C5+GPYIH0PGz3PIKzUK81fr14OIx/LZJepXGQulAFGCqM09HhoPGxDr4pKLRtmTl7bcfA+7dMZaZrNf+TM/w==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=yW9pexR5uleCXDs098JRKXkO+Z28DmM3Y3TzeDrtRlc=;
 b=aevYmz1pq+SZS+duy6+f7Dk42wfUHGi/hkhQr6Vge/lrLLy+8URjhKwudC7v/8G2h3XSw9vtk3FbRzpm9ZAfZQqIV67kz7VZ+Esufa+yhdPaxjrzGbn1woeHwCA7R0gLUhO/ftwbXRdkYE6xvdnDicLazHittJcjBri+rnXPjqw=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by CH0PR10MB5129.namprd10.prod.outlook.com (2603:10b6:610:d8::12) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.21; Fri, 18 Oct
 2024 16:22:58 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Fri, 18 Oct 2024
 16:22:56 +0000
Date: Fri, 18 Oct 2024 17:22:52 +0100
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Shuah Khan <skhan@linuxfoundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>,
        Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: Re: [PATCH 4/4] selftests/mm: add self tests for guard page feature
Message-ID: <23a4f83b-2b1a-458f-8027-3ff83b9ac29f@lucifer.local>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
 <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
 <dfbf9ccb-6834-4181-a382-35c9c9af8064@lucifer.local>
 <22d386cd-e62f-43f9-905e-2d0881781abe@linuxfoundation.org>
 <7bbfc635-8d42-4c3d-8808-cb060cd9f658@lucifer.local>
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <7bbfc635-8d42-4c3d-8808-cb060cd9f658@lucifer.local>
X-ClientProxiedBy: LO6P123CA0014.GBRP123.PROD.OUTLOOK.COM
 (2603:10a6:600:338::17) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|CH0PR10MB5129:EE_
X-MS-Office365-Filtering-Correlation-Id: 2c38502f-5282-489c-8473-08dcef911fee
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam:
	BCL:0;ARA:13230040|1800799024|10070799003|366016|376014|7416014;
X-Microsoft-Antispam-Message-Info:
	=?utf-8?B?OGxxK080ODBTUWlxTXNpT08vYTBMS3N1K3VYK1cvQkJ1WnBlSlJNYjZJejdF?=
 =?utf-8?B?R3VJYmM5RW1rU3NYcVV4NTZRdUVRNzBWQTByYm5CMDIrSzdNb09Eb1pBWnov?=
 =?utf-8?B?Rjh2a3ptckFtN3k2U2lQQzhSaEtKaG5odU5rRUFySmk0ZG41ZCtzYnhEaUs1?=
 =?utf-8?B?ZTF0Wjg5d2FtN0xWMkZNZ0xTK0p4UHV1MG9IY3MxWkptSnY5NkcwdXZjdlFQ?=
 =?utf-8?B?VGJPaXhGbzl1QTlFMlEwM21SRStYeU9LMUoybUJwNGNEZ2o5cWg3V2xyQXVr?=
 =?utf-8?B?alVUMk5hQUo2WmMyeFFCSTByQkdMU1MwOEtOSVBNYk1jU3JFQzMybXhmYkQ0?=
 =?utf-8?B?NWM5dGdZY2NBc20xSEp0RzY4Q3Y4TDBLM245ZUFTMDBrZ3JBRnd6RlQ5Ni9l?=
 =?utf-8?B?dkZheS9TSDY5cmlqYTBqYzlYREVQMmZZdzBkRWQwL1lNOHB6ay9RMlA1NjVF?=
 =?utf-8?B?NTBTL2xtMnVuZDc0VHpRN1dSeU1hdWRHRFpmWno3eHQxeXRlK2hzQzlaT0tS?=
 =?utf-8?B?OXhwWUxFckNKeml4U3VIUFZ3bytTZmF0aTBUNk9JekJWcTVKQ0FQLzdqYlpp?=
 =?utf-8?B?WnNkYVJhVUZXTnlGdUNiWmpIM1BWSHpGZzQxQTdYNnFBZ1RMaGFQdjJ4WnJE?=
 =?utf-8?B?Y3R5V0RSUkg1cmoyOWE4QkhlbldON3RUbnZVTkR1aXo3V3RqakFqaEtmZ2ZV?=
 =?utf-8?B?OTJGTzNZS0w5TFpicGt0bzFRNUVrQktBVnhWZ1JYMFozVzFwVThHNkpWeUxw?=
 =?utf-8?B?VFFiNnlDY0FLMW9hUmRqbjZxUi9ZRnBkZ2JwRTJqN1VIK0IwTmJQQ09JemFv?=
 =?utf-8?B?WWt0eDBYbUtoV1hMYTdlbWVWQ1RjdjJQNnN6RkFQUzlWOXVkTEVqNXB0clZP?=
 =?utf-8?B?SVZQZEVRSGN3NU45TnEwbURDczVDcW11YS9wcmw2VkhDWmc1VFJHN2k1d3VQ?=
 =?utf-8?B?WThmWHJWb3hvY25XT1FIcnk1aHAxdkk5S1AvNTZQMXYrWGEzWitmUkNaaGhM?=
 =?utf-8?B?MVVJOVp5RmFSUzhIREg0TTk5SGdjV2JNc2lWdVNMQzdoRzBEVlBjbkNtRGE0?=
 =?utf-8?B?T283Z1ZPa3NsUnF4V1hRTkNKTjRKejVwR3ZNa1NHWkdQSlJWZFZuK3BlSXlY?=
 =?utf-8?B?SHRuZk1CODNkYkxPZGlEWkRaVTluNmxLYmFEeU0zSzNDZzJpR1p5N0Qzbndn?=
 =?utf-8?B?bnBTbUNNb3F5S2xkb1E3YXJESE8rVCtxb3FTQnFnRkhUZUhSYm5sSjA4c0RZ?=
 =?utf-8?B?TnMvSGdkRnVJNkxmMWxQM1RvcHBjWVNEUjR2b0pZT2VXckF6MFh4MzFWL2JH?=
 =?utf-8?B?ZCsrbHd5VmJPeDhIeEdZS0t2ZE9BQjRQNUF2Yk9VbnpTSUJnUUFTZW5JNkFn?=
 =?utf-8?B?Yk5PWkxRd0o5c3ZtN3FEQkdadEt4V1RWRkZjS3F4Z2hBUThmZHlkY0lEdXpL?=
 =?utf-8?B?cjhGTWxNZHZIRzZ4L3hLT1A1dkhreVJib0pZV2k1L2JoWXJEQWhkVFhhQlBC?=
 =?utf-8?B?Ukwxc3drR1VjNUNwYkROYXp2SHRmcGJvMCs1ejJScC9VSUptbSszdW4wMGVB?=
 =?utf-8?B?NGpTWFYxd2JTREtKT2dnU2h4NC9FMHlBSlZabzczMEFhZ3JhbEVaOUk3a2Jz?=
 =?utf-8?B?ZU5ONmcyTFUwU3RtVnFvY1c4cDJFdllXUytJdFg0T3pkcVphcHRDZ0J2UGln?=
 =?utf-8?B?d3pjbjVSQmRwOCszYnlyanRpa0d3OEtZUnYwSkx4aHNNbkg2M2ltSTNvSU1E?=
 =?utf-8?Q?57tzZrC1YiZOqEPVKEoSHuYU3gR7KSNkAD6u8hY?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(1800799024)(10070799003)(366016)(376014)(7416014);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?utf-8?B?cmVUODBMUENZemh2Rm9wYXJ0YVQxKzFCQURaMmJNbUIwUFp2Q1hjUVB3T2cw?=
 =?utf-8?B?MXpuUEtxU3gzRlkxS25FaFpLTW1FaS9ua0VadXc1WC95ODdVdXBiUEE3L0tl?=
 =?utf-8?B?SStUYWtINEQ0L0ptWXIwN0UyK3B5Ykp3VDBtUmlCbk50NFhoaTZPS29LTXVB?=
 =?utf-8?B?Rld0cEdRQWJndk1LQzM1cnRycGNHbEhQbmZZQ2lmM2Y5M0I0dE4wcUVUUFAz?=
 =?utf-8?B?emFlR0w2VzRybzZmT2tyN0pZaWJjM1pHUGZkbU1WaWpjK1RrT0drdTdOQUtE?=
 =?utf-8?B?dVordXlOZHh5Q2tIbjdCeVE0cnBybFNhM0pYMExBTmpMNTgrRFFPeFpHR1JM?=
 =?utf-8?B?azdwUEQwMEZ3TC9qeU5KRVRQbVdEdGpQZ3NwRndiaStNQlh5aW5hOEVUKzBD?=
 =?utf-8?B?eEcxUWxNVnY4MVo2dXhKQnJKZFozU2NXMmxLZVFWSWN6WU5yMWZRM2ljUU5v?=
 =?utf-8?B?QmdJMnh2S0FwcGErSXM3cEV2WUZUVGdLR3k0VGQva2tFUWFuNjlQZWpMNStx?=
 =?utf-8?B?aEI3RS96UGtYem1VUWxlME9pdDhyV1l3ZG9wSE9DWko3YmdJY3R5L3lPdTBa?=
 =?utf-8?B?bUpTTVYvVGZpSjg5VXdzMUExV1FVSkx4QWJHL243OExkbkNUOGJlYks1b3RW?=
 =?utf-8?B?d2ZYVUNMWjA0UkRVb3RYUitjVU51dmtnakFGKzE0N0R3VENPeHlkTDBEMnhl?=
 =?utf-8?B?MDlqSTBnZzdEMVpMUFY4QXkxWGoyNUV6MXVJbkhDNUpSbWpKeUZUNjZoc2cz?=
 =?utf-8?B?UDlNSnhISzFyVjlwQ00wWGh4MzdkU1FlWUlOaDhtbmxYQWtmeC81STBseTZG?=
 =?utf-8?B?cnFJSS82ZExpYXRNYlZJc1ZhU2lranBmbFRiQUZ4K1FOUzgvTlNmaFFBSVFU?=
 =?utf-8?B?dnc5M2dubnYvWGFERG94WlM0d2JubzlDeEhCRGE3aFdXWFBKOHlQbFVieHMz?=
 =?utf-8?B?dWs0WmxmTllZd1ppNExwZVY5azQ5dWF5cllyL2VkT3VabVhDN2JFSXdoYXha?=
 =?utf-8?B?Ty9sbHBxbVRZby9Belp5L3g4d25ZWUh1LytteGpoZ2toS1BIcUdoNmZlY2RR?=
 =?utf-8?B?bEp3Rzk3NXBza2RjTXIybzlycFIrdU5MVFNBMnJ4VzFVRVI5MUtXNlNPM1FK?=
 =?utf-8?B?b3FFOWdCaVozMVFxRWo5cTkxV3NFQnlSc3JCZjVVa3BoL2dqMThhN3g3Zm5j?=
 =?utf-8?B?a0VRcmxFdjlhdEkwQW5HT3NJUStabjhRZFA0MWt5YnZHRjhRSGxSVHlVYWti?=
 =?utf-8?B?enRIUnpKeSszWExjRVRvaElnaGRIRGt6UW1KejVjdVJKNEs5VmdhNXY2TThx?=
 =?utf-8?B?MFV2bGtaY2dacU9Id3k0YjhyZ1QrMHdIR3pUSHl2UkRHblRTM0hqek1HL1ZZ?=
 =?utf-8?B?eFlRYzVtUHl1YW8veDgvU3BHMXF5QjNMWTdmSDhBd2dNWDZxMEpFRFZRTlRL?=
 =?utf-8?B?b21hb0VmcFdrZENIcWlKNmw2NXphMDkrNERPQkVSazlnSmRzRWR2Y2JyZjRI?=
 =?utf-8?B?dVBZSGt1RHBlMmNuNjNFcEtTSm05YVVxV1RUOTkvWU5wTDBWVTMvNkZ3Kyt1?=
 =?utf-8?B?RVJzNDVJZXdHK1M5b3BJNmdBUWJOMjRyZ1BTRVF3bVpydzc4OGtjRzFqZXNz?=
 =?utf-8?B?cExQVTdVbmlJeFFuOWhQOTNLV2RQZmUwUnlqNW1qWXhXNTZwRUNKYXNQd3hx?=
 =?utf-8?B?aVJoaWNwRkhNdXF0YWc2M21kOVh4OEtyR2E4OWRUTmlWNEVDbjdQWjZSRUt6?=
 =?utf-8?B?OTU5V203TnI0ZFIzeEM3ZlVuS0JnRDkyYk4wQUJBOGRjZzAzcHFibEIzMTY4?=
 =?utf-8?B?QVFOQ1FOcnlTUlhGUDRCR2FaM0RlSjM3Z0hLWUR1RHFIVG5ZaUJ3S25WYUhC?=
 =?utf-8?B?TzROYXRXdS83OVdiaDJUc0Z5ZzhaQUlCcHFBSklxUGx2cVNrd0tISVBtNVB6?=
 =?utf-8?B?emRYOWxWMThBUHVrWHVrSHJUSWgzaUdrUFo1Y1pyMk9OSXEzdmRINlR4M0Zm?=
 =?utf-8?B?OXplTG1zNFpPQW1yZmVjR2ZyQ0ZaaVJTMlVoUEEzb2VxdEpzWlV0cFlOc0ZM?=
 =?utf-8?B?NU53a3BUek5RejV5T0ZhU1Arb3EzVzV4SU5rbUZzck80SlVuZGtTckVBMnk5?=
 =?utf-8?B?ZmZCWUxqekZ2dkRobmxaU1l0elRkZ0ZhYlE1SkZxa0s5Y2xvd1pFWHVhMWZC?=
 =?utf-8?B?cjZIbXNEWXBNZ2sxQTltSkErQjZzcWVwbTlhcWgraVJzV0xuNmVqcFNELzg0?=
 =?utf-8?B?K0dZMlgrbVpXRmY2MEhXOEM5OS9RPT0=?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	eXj3o7TL1WxG9etyUaLlLse63Jgb0VUjjr48jJaWkF8+hIaICgDW2J0f5Rpa4QDRvxDj46rpLi1KLKrX7Bol0FLFF2IAFg8g32wjkeesXRa2brxFc0qeVEesjRM9uPGLZIW7XEmZnVvCDpwBsW9I0wXjXXIM9SPIOLPaQlRqx4pnech6eScbjIlTJubw4XfzzZKvl/yi7Md3NtIBE8bwxTB6xYVP/gFGxUCdkrZ/pQAXzg7gJOKxHlNA5UytmfJZUDEAMta7agNVo5TnEFHkfdcPafmAcB2lqUPcbPg4ApzCil2mrgwz0NnRZUIJ6GDOWtJCbp+93jobBGKASWSwrVm/yHH2VYQwLzhoidapbNLv3P01qrBQLEbXiqQagpSeYIdWGhwCU+u8H2hAts7GyhtiFZiClQ6MLVQFZ9vhVbOmiTU1InihpDkRPHxYsIbSWoBZ7/GK5pIYSChUfu+Rlj47xTqsPDufG+wQCo5XiPeOQEvBxLf4jQF+qEQrpWHrs+C4LO/mCL4nQM5kwro9Uzh5eFKktz9w1vZpqwK/ppQR9E26gy2x217tXhkq6nC/DqRKyR3Qlw/wOu9i6pFfJZ8oF3S7cILaEVf8Tw3nMCA=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 2c38502f-5282-489c-8473-08dcef911fee
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Oct 2024 16:22:56.6012
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: wENMr6IltZpbMyTbIjomTkHVfARPnR3MrHCQSPPAalXBGoxGWeIRSngZFSCp6hcZzN+jLsNJ+sIIrRQFSQCNOqVTK2t6x4JaiP8O85Mffvo=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CH0PR10MB5129
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-18_11,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 mlxlogscore=459 adultscore=0
 spamscore=0 malwarescore=0 bulkscore=0 suspectscore=0 mlxscore=0
 phishscore=0 classifier=spam adjust=0 reason=mlx scancount=1
 engine=8.12.0-2409260000 definitions=main-2410180104
X-Proofpoint-ORIG-GUID: lpYCrIYWcJx7g5O905ZCu3uyQvnjUmum
X-Proofpoint-GUID: lpYCrIYWcJx7g5O905ZCu3uyQvnjUmum

On Fri, Oct 18, 2024 at 05:07:20PM +0100, Lorenzo Stoakes wrote:
[snip]
> Firstly, as I said, the code _does not compile_ if I do not use braces in
> many cases. This is probably an issue with the macros, but it is out of
> scope for this series for me to fix that.
>
> 'Fixing' these cases results in:
>
>   CC       guard-pages
> guard-pages.c: In function guard_pages_split_merge:
> guard-pages.c:566:17: error: else without a previous if
>   566 |                 else
>       |                 ^~~~
> guard-pages.c: In function guard_pages_dontneed:
> guard-pages.c:666:17: error: else without a previous if
>   666 |                 else
>       |                 ^~~~
> guard-pages.c: In function guard_pages_fork:
> guard-pages.c:957:17: error: else without a previous if
>   957 |                 else
>       |                 ^~~~
> guard-pages.c: In function guard_pages_fork_wipeonfork:
> guard-pages.c:1010:17: error: else without a previous if
>  1010 |                 else
>       |                 ^~~~

[snip]

An added note - the fact this happens makes the macros suspect everywhere,
and I am concerned single-lining them might break or cause failures not to
propagate perhaps, which led to me _never_ single-lining them I believe and
accounts for a bunch of the warnings.

I can go through and manually test each one to make sure before I
single-line them if necessary.

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mail-ot1-f54.google.com (mail-ot1-f54.google.com [209.85.210.54])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 2B7B61F4266
	for <linux-kernel@vger.kernel.org>; Fri, 18 Oct 2024 16:24:29 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=209.85.210.54
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729268671; cv=none; b=tlyKpDB8JpN7espYi/AhCaFKaxmP8dh6HGyA/6dwqsOcJCd6/t0bKLJ8XI+SizQCim4ETwqBs9Rowzj3OrFW5/MHMJgIXC8ypldOw5BoLGGJvvAnS332RMyoNDFkGgLd9/jrPx3WlXOhvO5KEM7tHnT2/a40Si7TiC1dFteExpU=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729268671; c=relaxed/simple;
	bh=iWxiwdG2p0Ia/g/Q7KCJatv1Xb46S2nFuXqxm0WqkKI=;
	h=Message-ID:Date:MIME-Version:Subject:To:Cc:References:From:
	 In-Reply-To:Content-Type; b=JohGuB8xGIuu4Rpge8hJ8iL8ISmBhNQ4TR5PTxrVfQmNy8LX7qulM5L6cRJjU+JuKCUZ1VJqx+KwewRNX2eT3KTEEwIJy5cCSiGxWzVGFq/LuR454SO7e36LgY0+K9pksJdU0AoeaabRFm14GOJ+pAESH1eQLNgcDxQJZghWbuQ=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=linuxfoundation.org; spf=pass smtp.mailfrom=linuxfoundation.org; dkim=pass (1024-bit key) header.d=linuxfoundation.org header.i=@linuxfoundation.org header.b=NEHd19DV; arc=none smtp.client-ip=209.85.210.54
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=linuxfoundation.org
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=linuxfoundation.org
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=linuxfoundation.org header.i=@linuxfoundation.org header.b="NEHd19DV"
Received: by mail-ot1-f54.google.com with SMTP id 46e09a7af769-7181b86a749so406015a34.3
        for <linux-kernel@vger.kernel.org>; Fri, 18 Oct 2024 09:24:28 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=linuxfoundation.org; s=google; t=1729268668; x=1729873468; darn=vger.kernel.org;
        h=content-transfer-encoding:in-reply-to:from:content-language
         :references:cc:to:subject:user-agent:mime-version:date:message-id
         :from:to:cc:subject:date:message-id:reply-to;
        bh=F3v+T7PjpPKYcorK84vLoRIziLno8dgMRinbwlPayfE=;
        b=NEHd19DVCC+91om/KDc6/DtsOHXxxhSn2fZUUeH4mtp4BCX4WlrGa0fdoKvmR0gUW7
         aSLR0TIFOqdRGcylJv0/qr3YYxWNil/j8sG1rVxH+H9vynocQoQDJxeF+gK1hrxCmFzC
         S9t3h3q0Z9gdBcYw4A2xEzyQdVgMx9ea8+WBk=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1729268668; x=1729873468;
        h=content-transfer-encoding:in-reply-to:from:content-language
         :references:cc:to:subject:user-agent:mime-version:date:message-id
         :x-gm-message-state:from:to:cc:subject:date:message-id:reply-to;
        bh=F3v+T7PjpPKYcorK84vLoRIziLno8dgMRinbwlPayfE=;
        b=gUuKqVYZp11Nk9BxiXgJi9EKVnNaK4+H+4QPQmNTn/o8YfTl3/3g3RbgwbjkFDnDe2
         OAZDGO3tWPVz+wVyjXAkflsuNaDCueLn+AivEuzMwprds1f6PniCJd0bg7t/GtuC6D1y
         PMacHIK8Rvyw7xBhon30hunBz9cvnewtf31flVqIePIg7uPPMZHntc9EjS9efW8MSpPx
         flZLPCDXixpEG3yK5dnDRhaaoH3CO8hFNSbL0r9UeZamkQnBPwTyCM3Ni/7mUwQE5VRU
         HG+217V8sSE15J6uOnkX0s6+G6XcGqKSALD6aKjkotTe1n6TOEx6ZlroWM0sVxvBigFk
         H0oA==
X-Forwarded-Encrypted: i=1; AJvYcCXbyp3DdRoyLbOHtHDeiIgldkbQvq419o4r3/u6Gdg7PVqG5ic3ZiGAfRqbdOvJpixRvjok1FldXHEk7WI=@vger.kernel.org
X-Gm-Message-State: AOJu0Yyj50vctmNfGB8n45VIbaG8Aj4gwtpjTt3yytEpjDNjBVpMvgW8
	GJCrZbO6CArS68CRO9SyIlJBul7AZBmHYy6VQozBvBIYekEaOIgIeaofb1Ajmx0=
X-Google-Smtp-Source: AGHT+IFIMl2GQFcOD4CAePzrCdIz3Ij+s6w3yxltIlvjQyisZktPRrklsesyLhvGbRcpIU0+2bu3ig==
X-Received: by 2002:a05:6830:348a:b0:717:fb12:2c2 with SMTP id 46e09a7af769-7181a5c6046mr2826059a34.3.1729268667921;
        Fri, 18 Oct 2024 09:24:27 -0700 (PDT)
Received: from [192.168.1.128] ([38.175.170.29])
        by smtp.gmail.com with ESMTPSA id 46e09a7af769-718195da4d0sm376406a34.56.2024.10.18.09.24.26
        (version=TLS1_3 cipher=TLS_AES_128_GCM_SHA256 bits=128/128);
        Fri, 18 Oct 2024 09:24:27 -0700 (PDT)
Message-ID: <40ca64d7-c8c9-47b1-ac17-95524bd76aa6@linuxfoundation.org>
Date: Fri, 18 Oct 2024 10:24:25 -0600
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
User-Agent: Mozilla Thunderbird
Subject: Re: [PATCH 4/4] selftests/mm: add self tests for guard page feature
To: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
Cc: Andrew Morton <akpm@linux-foundation.org>,
 Suren Baghdasaryan <surenb@google.com>,
 "Liam R . Howlett" <Liam.Howlett@oracle.com>,
 Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
 "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
 David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
 linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
 Richard Henderson <richard.henderson@linaro.org>,
 Ivan Kokshaysky <ink@jurassic.park.msu.ru>, Matt Turner
 <mattst88@gmail.com>, Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
 "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
 Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
 Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
 linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
 linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
 Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
 linux-kselftest@vger.kernel.org, Sidhartha Kumar
 <sidhartha.kumar@oracle.com>, Jeff Xu <jeffxu@chromium.org>,
 Christoph Hellwig <hch@infradead.org>, Shuah Khan <skhan@linuxfoundation.org>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
 <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
 <dfbf9ccb-6834-4181-a382-35c9c9af8064@lucifer.local>
 <22d386cd-e62f-43f9-905e-2d0881781abe@linuxfoundation.org>
 <7bbfc635-8d42-4c3d-8808-cb060cd9f658@lucifer.local>
Content-Language: en-US
From: Shuah Khan <skhan@linuxfoundation.org>
In-Reply-To: <7bbfc635-8d42-4c3d-8808-cb060cd9f658@lucifer.local>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 8bit

On 10/18/24 10:07, Lorenzo Stoakes wrote:
> On Fri, Oct 18, 2024 at 09:32:17AM -0600, Shuah Khan wrote:
>> On 10/18/24 01:12, Lorenzo Stoakes wrote:
>>> On Thu, Oct 17, 2024 at 03:24:49PM -0600, Shuah Khan wrote:
>>>> On 10/17/24 14:42, Lorenzo Stoakes wrote:
>>>>> Utilise the kselftest harmness to implement tests for the guard page
>>>>
>>>> Splleing NIT - harmness -> harness
>>>>
>>>>> implementation.
>>>>>
>>>>> We start by implement basic tests asserting that guard pages can be
>>>>
>>>> implmenting? By the way checkpatch will catch spelling stuuf.
>>>> Please see comments about warnings below.
>>>
>>> Thanks. The majority of the checkpatch warnings are invalid so I missed
>>> this. Will fix on respin.
>>>
>>>>
>>>>> established (poisoned), cleared (remedied) and that touching poisoned pages
>>>>> result in SIGSEGV. We also assert that, in remedying a range, non-poison
>>>>> pages remain intact.
>>>>>
>>>>> We then examine different operations on regions containing poison markers
>>>>> behave to ensure correct behaviour:
>>>>>
>>>>> * Operations over multiple VMAs operate as expected.
>>>>> * Invoking MADV_GUARD_POISION / MADV_GUARD_REMEDY via process_madvise() in
>>>>>      batches works correctly.
>>>>> * Ensuring that munmap() correctly tears down poison markers.
>>>>> * Using mprotect() to adjust protection bits does not in any way override
>>>>>      or cause issues with poison markers.
>>>>> * Ensuring that splitting and merging VMAs around poison markers causes no
>>>>>      issue - i.e. that a marker which 'belongs' to one VMA can function just
>>>>>      as well 'belonging' to another.
>>>>> * Ensuring that madvise(..., MADV_DONTNEED) does not remove poison markers.
>>>>> * Ensuring that mlock()'ing a range containing poison markers does not
>>>>>      cause issues.
>>>>> * Ensuring that mremap() can move a poisoned range and retain poison
>>>>>      markers.
>>>>> * Ensuring that mremap() can expand a poisoned range and retain poison
>>>>>      markers (perhaps moving the range).
>>>>> * Ensuring that mremap() can shrink a poisoned range and retain poison
>>>>>      markers.
>>>>> * Ensuring that forking a process correctly retains poison markers.
>>>>> * Ensuring that forking a VMA with VM_WIPEONFORK set behaves sanely.
>>>>> * Ensuring that lazyfree simply clears poison markers.
>>>>> * Ensuring that userfaultfd can co-exist with guard pages.
>>>>> * Ensuring that madvise(..., MADV_POPULATE_READ) and
>>>>>      madvise(..., MADV_POPULATE_WRITE) error out when encountering
>>>>>      poison markers.
>>>>> * Ensuring that madvise(..., MADV_COLD) and madvise(..., MADV_PAGEOUT) do
>>>>>      not remove poison markers.
>>>>
>>>> Good summary of test. Does the test require root access?
>>>> If so does it check and skip appropriately?
>>>
>>> Thanks and some do, in those cases we skip.
>>>
>>>>
>>>>>
>>>>> Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
>>>>> ---
>>>>>     tools/testing/selftests/mm/.gitignore    |    1 +
>>>>>     tools/testing/selftests/mm/Makefile      |    1 +
>>>>>     tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
>>>>>     3 files changed, 1170 insertions(+)
>>>>>     create mode 100644 tools/testing/selftests/mm/guard-pages.c
>>>>>
>>>>> diff --git a/tools/testing/selftests/mm/.gitignore b/tools/testing/selftests/mm/.gitignore
>>>>> index 689bbd520296..8f01f4da1c0d 100644
>>>>> --- a/tools/testing/selftests/mm/.gitignore
>>>>> +++ b/tools/testing/selftests/mm/.gitignore
>>>>> @@ -54,3 +54,4 @@ droppable
>>>>>     hugetlb_dio
>>>>>     pkey_sighandler_tests_32
>>>>>     pkey_sighandler_tests_64
>>>>> +guard-pages
>>>>> diff --git a/tools/testing/selftests/mm/Makefile b/tools/testing/selftests/mm/Makefile
>>>>> index 02e1204971b0..15c734d6cfec 100644
>>>>> --- a/tools/testing/selftests/mm/Makefile
>>>>> +++ b/tools/testing/selftests/mm/Makefile
>>>>> @@ -79,6 +79,7 @@ TEST_GEN_FILES += hugetlb_fault_after_madv
>>>>>     TEST_GEN_FILES += hugetlb_madv_vs_map
>>>>>     TEST_GEN_FILES += hugetlb_dio
>>>>>     TEST_GEN_FILES += droppable
>>>>> +TEST_GEN_FILES += guard-pages
>>>>>     ifneq ($(ARCH),arm64)
>>>>>     TEST_GEN_FILES += soft-dirty
>>>>> diff --git a/tools/testing/selftests/mm/guard-pages.c b/tools/testing/selftests/mm/guard-pages.c
>>>>> new file mode 100644
>>>>> index 000000000000..2ab0ff3ba5a0
>>>>> --- /dev/null
>>>>> +++ b/tools/testing/selftests/mm/guard-pages.c
>>>>> @@ -0,0 +1,1168 @@
>>>>> +// SPDX-License-Identifier: GPL-2.0-or-later
>>>>> +
>>>>> +#define _GNU_SOURCE
>>>>> +#include "../kselftest_harness.h"
>>>>> +#include <assert.h>
>>>>> +#include <fcntl.h>
>>>>> +#include <setjmp.h>
>>>>> +#include <errno.h>
>>>>> +#include <linux/userfaultfd.h>
>>>>> +#include <signal.h>
>>>>> +#include <stdbool.h>
>>>>> +#include <stdio.h>
>>>>> +#include <stdlib.h>
>>>>> +#include <string.h>
>>>>> +#include <sys/ioctl.h>
>>>>> +#include <sys/mman.h>
>>>>> +#include <sys/syscall.h>
>>>>> +#include <sys/uio.h>
>>>>> +#include <unistd.h>
>>>>> +
>>>>> +/* These may not yet be available in the uAPI so define if not. */
>>>>> +
>>>>> +#ifndef MADV_GUARD_POISON
>>>>> +#define MADV_GUARD_POISON	102
>>>>> +#endif
>>>>> +
>>>>> +#ifndef MADV_GUARD_UNPOISON
>>>>> +#define MADV_GUARD_UNPOISON	103
>>>>> +#endif
>>>>> +
>>>>> +volatile bool signal_jump_set;
>>>>
>>>> Can you add a comment about why volatile is needed.
>>>
>>> I'm not sure it's really necessary, it's completely standard to do this
>>> with signal handling and is one of the exceptions to the 'volatile
>>> considered harmful' rule.
>>>
>>>> By the way did you happen to run checkpatck on this. There are
>>>> several instances where single statement blocks with braces {}
>>>>
>>>> I noticed a few and ran checkpatch on your patch. There are
>>>> 45 warnings regarding codeing style.
>>>>
>>>> Please run checkpatch and clean them up so we can avoid followup
>>>> checkpatch cleanup patches.
>>>
>>> No sorry I won't, checkpatch isn't infallible and series trying to 'clean
>>> up' things that aren't issues will be a waste of everybody's time.
>>>
>>
>> Sorry - this violates the coding styles and makes it hard to read.
>>
>> See process/coding-style.rst:
>>
>> Do not unnecessarily use braces where a single statement will do.
>>
>> .. code-block:: c
>>
>>          if (condition)
>>                  action();
>>
>> and
>>
>> .. code-block:: c
>>
>>          if (condition)
>>                  do_this();
>>          else
>>                  do_that();
>>
>> This does not apply if only one branch of a conditional statement is a single
>> statement; in the latter case use braces in both branches:
>>
>> .. code-block:: c
>>
>>          if (condition) {
>>                  do_this();
>>                  do_that();
>>          } else {
>>                  otherwise();
>>          }
>>
>> Also, use braces when a loop contains more than a single simple statement:
>>
>> .. code-block:: c
>>
>>          while (condition) {
>>                  if (test)
>>                          do_something();
>>          }
>>
>> thanks,
>> -- Shuah
> 
> Shuah, quoting coding standards to an experienced kernel developer
> (maintainer now) is maybe not the best way to engage here + it may have
> been more productive for you to first engage on why it is I'm deviating
> here.
> 
> Firstly, as I said, the code _does not compile_ if I do not use braces in
> many cases. This is probably an issue with the macros, but it is out of
> scope for this series for me to fix that.

I am not trying to throw the book at you. When I see 45 of
them I have to ask the reasons why.

> 
> 'Fixing' these cases results in:
> 
>    CC       guard-pages
> guard-pages.c: In function guard_pages_split_merge:
> guard-pages.c:566:17: error: else without a previous if
>    566 |                 else
>        |                 ^~~~
> guard-pages.c: In function guard_pages_dontneed:
> guard-pages.c:666:17: error: else without a previous if
>    666 |                 else
>        |                 ^~~~
> guard-pages.c: In function guard_pages_fork:
> guard-pages.c:957:17: error: else without a previous if
>    957 |                 else
>        |                 ^~~~
> guard-pages.c: In function guard_pages_fork_wipeonfork:
> guard-pages.c:1010:17: error: else without a previous if
>   1010 |                 else
>        |                 ^~~~
> 
> In other cases I am simply not a fan of single line loops where there is a
> lot of compound stuff going on:
> 
> 	for (i = 0; i < 10; i++) {
> 		ASSERT_FALSE(try_read_write_buf(&ptr1[i * page_size]));
> 	}
> 
> vs.
> 
> 	for (i = 0; i < 10; i++)
> 		ASSERT_FALSE(try_read_write_buf(&ptr1[i * page_size]));
> 
> When there are very many loops like this. This is kind of a test-specific
> thing, you'd maybe put more effort into splitting this up + have less
> repetition in non-test code.
> 
> I'm not going to die on the hill of single-line-for-loops though, so if you
> insist I'll change those.
> 
> However I simply _cannot_ change the if/else blocks that cause compilation
> errors.
> 
> This is what I mean about checkpatch being fallible. It's also fallible in
> other cases, like variable declarations via macro (understandably).
> 
> Expecting checkpatch to give zero warnings is simply unattainable,
> unfortunately.
> 
> As you seem adamant about strict adherence to checkpatch, and I always try
> to be accommodating where I can be, I suggest I fix everything _except
> where it breaks the compilation_ does that work for you?

Yes Please. If you leave these in here as soon as the patch hits
next, we start seeing a flood of patches. It becomes harder to fix
these later due to merge conflicts.

It becomes a patch overload issue. Yes I would like to see the ones
that don't result in compile errors fixed.

thanks,
-- Shuah

> 
> Thanks.


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mail-oa1-f45.google.com (mail-oa1-f45.google.com [209.85.160.45])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 3D44920370D
	for <linux-kernel@vger.kernel.org>; Fri, 18 Oct 2024 16:25:59 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=209.85.160.45
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729268762; cv=none; b=lHW5xDGz/mzdUxX35JbW+9kNOd7SMSF9ebs70E+dpLgHszfcchHCyx+gWLaytdKJ30rpcXeWbuy51MCphta2JAAZwk1EzWzSaOPLiXz9ycam/Xh/iqxgBwwJmaD79xZhfMo9oFgqqyaoBclJNF7T30/WdTKUrQhyRf1yAGF3+OM=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729268762; c=relaxed/simple;
	bh=5jbP6qgUgoq1McrR3RLDeRE04owyYxOG4RL62eRi/S0=;
	h=Message-ID:Date:MIME-Version:Subject:To:Cc:References:From:
	 In-Reply-To:Content-Type; b=N0qNe5sDVMMnw14gnfhpwJt81MdmSjSgLpKqLloCXrjDII64LJfNsG37HvqBbl5MMJCRKssNN/B2nxjcojkPqULM4z4wMasrf4Ugv/wJUKlSavtUV9LVTNFMTUln55UdTZPu+0AyqBtEJrcIsiQnsDLr5pHFh++Ada/RxDRtx8g=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=linuxfoundation.org; spf=pass smtp.mailfrom=linuxfoundation.org; dkim=pass (1024-bit key) header.d=linuxfoundation.org header.i=@linuxfoundation.org header.b=H+/zmRRV; arc=none smtp.client-ip=209.85.160.45
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=linuxfoundation.org
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=linuxfoundation.org
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=linuxfoundation.org header.i=@linuxfoundation.org header.b="H+/zmRRV"
Received: by mail-oa1-f45.google.com with SMTP id 586e51a60fabf-286f0dcead5so1980451fac.0
        for <linux-kernel@vger.kernel.org>; Fri, 18 Oct 2024 09:25:59 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=linuxfoundation.org; s=google; t=1729268758; x=1729873558; darn=vger.kernel.org;
        h=content-transfer-encoding:in-reply-to:from:content-language
         :references:cc:to:subject:user-agent:mime-version:date:message-id
         :from:to:cc:subject:date:message-id:reply-to;
        bh=P4qNWvLVpxYbIRtwTadaIjM03ETyiiYE+F1EJeQJjHY=;
        b=H+/zmRRV8q4r4+UlnQN+A0sP2z3gWgJIB1zMRgg6lSVwQDwtf4E85CCQQQpAg5ByQZ
         syk1Lhzseqd9xZSU4/I/HS2vk/XrXimgUu6t+n555D68Yz7svJcvHY1nTQOyg+tYj36k
         YsPJaR6eYmdifwgngf3DaWrxI6vYfn+aABy5o=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1729268758; x=1729873558;
        h=content-transfer-encoding:in-reply-to:from:content-language
         :references:cc:to:subject:user-agent:mime-version:date:message-id
         :x-gm-message-state:from:to:cc:subject:date:message-id:reply-to;
        bh=P4qNWvLVpxYbIRtwTadaIjM03ETyiiYE+F1EJeQJjHY=;
        b=j7XsOhDdeVE3S6bZ6srBBOSg7T5QP5e/hXflHQIoAsno90/sFUAsCzoyxk+GS7I+UD
         9KchA6xbtfgQ/aSh1zcn4lWWJRZnUIcJpmxLzFaOqfyYg26/LFA/7jWcJICM6nMNoMdY
         XAa1+IqMXAssuRli9rSoKY6YFuRImI8GS1daEq0JTeK120/8XPH3I3AvUnSvkQgZ6Cd1
         WgPyQhTSYpDhA7ltJwDtFf2GU7RjpA4LJJ//Xo9DljymM0U5/INoAIbj42UJw6gYEGbZ
         msLwjFjoLsu2bQvhx2GjsNMDTRmeB0udKIe20bly1oTZ5WBUZkSJU1FLZD8Y2HTGeTiw
         5u6g==
X-Forwarded-Encrypted: i=1; AJvYcCUCYrnqVmbMF0SampuzXe9nYfrjw4v/1fEaTXc4b5rX3BgR16TlVyFK/Apln9qSnyuJpM5XnmqZMxAy6OA=@vger.kernel.org
X-Gm-Message-State: AOJu0Yya4AUFsMBb4hdEm038krhzgr7ST/BLHv4FghPwXhYi+HijRXzQ
	/o1tLbBqsxQFTCPeolgA19eRVhpMK96qBRgOin5pg9LL9qivn6heLMRl7gBbEFg=
X-Google-Smtp-Source: AGHT+IGaroc9U1gTQH8oIv9XintQoQrlC7c5FvJNC3/Om1CneZ+0NGXExK3IjmCzNnhwYO6jdZ3JsA==
X-Received: by 2002:a05:6870:d60e:b0:288:aed8:c43d with SMTP id 586e51a60fabf-2890cf88610mr4183890fac.15.1729268758143;
        Fri, 18 Oct 2024 09:25:58 -0700 (PDT)
Received: from [192.168.1.128] ([38.175.170.29])
        by smtp.gmail.com with ESMTPSA id 46e09a7af769-718195da5f0sm377033a34.60.2024.10.18.09.25.56
        (version=TLS1_3 cipher=TLS_AES_128_GCM_SHA256 bits=128/128);
        Fri, 18 Oct 2024 09:25:57 -0700 (PDT)
Message-ID: <3a41a1b5-e9a7-43db-b50e-84d6cc275d10@linuxfoundation.org>
Date: Fri, 18 Oct 2024 10:25:55 -0600
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
User-Agent: Mozilla Thunderbird
Subject: Re: [PATCH 4/4] selftests/mm: add self tests for guard page feature
To: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
Cc: Andrew Morton <akpm@linux-foundation.org>,
 Suren Baghdasaryan <surenb@google.com>,
 "Liam R . Howlett" <Liam.Howlett@oracle.com>,
 Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
 "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
 David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
 linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
 Richard Henderson <richard.henderson@linaro.org>,
 Ivan Kokshaysky <ink@jurassic.park.msu.ru>, Matt Turner
 <mattst88@gmail.com>, Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
 "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
 Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
 Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
 linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
 linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
 Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
 linux-kselftest@vger.kernel.org, Sidhartha Kumar
 <sidhartha.kumar@oracle.com>, Jeff Xu <jeffxu@chromium.org>,
 Christoph Hellwig <hch@infradead.org>, Shuah Khan <skhan@linuxfoundation.org>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
 <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
 <dfbf9ccb-6834-4181-a382-35c9c9af8064@lucifer.local>
 <22d386cd-e62f-43f9-905e-2d0881781abe@linuxfoundation.org>
 <7bbfc635-8d42-4c3d-8808-cb060cd9f658@lucifer.local>
Content-Language: en-US
From: Shuah Khan <skhan@linuxfoundation.org>
In-Reply-To: <7bbfc635-8d42-4c3d-8808-cb060cd9f658@lucifer.local>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit

On 10/18/24 10:07, Lorenzo Stoakes wrote:
> On Fri, Oct 18, 2024 at 09:32:17AM -0600, Shuah Khan wrote:
>> On 10/18/24 01:12, Lorenzo Stoakes wrote:
>>> On Thu, Oct 17, 2024 at 03:24:49PM -0600, Shuah Khan wrote:
>>>> On 10/17/24 14:42, Lorenzo Stoakes wrote:
>>>>> Utilise the kselftest harmness to implement tests for the guard page
>>>>
>>>> Splleing NIT - harmness -> harness
>>>>
>>>>> implementation.
>>>>>
>>>>> We start by implement basic tests asserting that guard pages can be
>>>>
>>>> implmenting? By the way checkpatch will catch spelling stuuf.
>>>> Please see comments about warnings below.
>>>
>>> Thanks. The majority of the checkpatch warnings are invalid so I missed
>>> this. Will fix on respin.
>>>
>>>>
>>>>> established (poisoned), cleared (remedied) and that touching poisoned pages
>>>>> result in SIGSEGV. We also assert that, in remedying a range, non-poison
>>>>> pages remain intact.
>>>>>
>>>>> We then examine different operations on regions containing poison markers
>>>>> behave to ensure correct behaviour:
>>>>>
>>>>> * Operations over multiple VMAs operate as expected.
>>>>> * Invoking MADV_GUARD_POISION / MADV_GUARD_REMEDY via process_madvise() in
>>>>>      batches works correctly.
>>>>> * Ensuring that munmap() correctly tears down poison markers.
>>>>> * Using mprotect() to adjust protection bits does not in any way override
>>>>>      or cause issues with poison markers.
>>>>> * Ensuring that splitting and merging VMAs around poison markers causes no
>>>>>      issue - i.e. that a marker which 'belongs' to one VMA can function just
>>>>>      as well 'belonging' to another.
>>>>> * Ensuring that madvise(..., MADV_DONTNEED) does not remove poison markers.
>>>>> * Ensuring that mlock()'ing a range containing poison markers does not
>>>>>      cause issues.
>>>>> * Ensuring that mremap() can move a poisoned range and retain poison
>>>>>      markers.
>>>>> * Ensuring that mremap() can expand a poisoned range and retain poison
>>>>>      markers (perhaps moving the range).
>>>>> * Ensuring that mremap() can shrink a poisoned range and retain poison
>>>>>      markers.
>>>>> * Ensuring that forking a process correctly retains poison markers.
>>>>> * Ensuring that forking a VMA with VM_WIPEONFORK set behaves sanely.
>>>>> * Ensuring that lazyfree simply clears poison markers.
>>>>> * Ensuring that userfaultfd can co-exist with guard pages.
>>>>> * Ensuring that madvise(..., MADV_POPULATE_READ) and
>>>>>      madvise(..., MADV_POPULATE_WRITE) error out when encountering
>>>>>      poison markers.
>>>>> * Ensuring that madvise(..., MADV_COLD) and madvise(..., MADV_PAGEOUT) do
>>>>>      not remove poison markers.
>>>>
>>>> Good summary of test. Does the test require root access?
>>>> If so does it check and skip appropriately?
>>>
>>> Thanks and some do, in those cases we skip.
>>>
>>>>
>>>>>
>>>>> Signed-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
>>>>> ---
>>>>>     tools/testing/selftests/mm/.gitignore    |    1 +
>>>>>     tools/testing/selftests/mm/Makefile      |    1 +
>>>>>     tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
>>>>>     3 files changed, 1170 insertions(+)
>>>>>     create mode 100644 tools/testing/selftests/mm/guard-pages.c
>>>>>
>>>>> diff --git a/tools/testing/selftests/mm/.gitignore b/tools/testing/selftests/mm/.gitignore
>>>>> index 689bbd520296..8f01f4da1c0d 100644
>>>>> --- a/tools/testing/selftests/mm/.gitignore
>>>>> +++ b/tools/testing/selftests/mm/.gitignore
>>>>> @@ -54,3 +54,4 @@ droppable
>>>>>     hugetlb_dio
>>>>>     pkey_sighandler_tests_32
>>>>>     pkey_sighandler_tests_64
>>>>> +guard-pages
>>>>> diff --git a/tools/testing/selftests/mm/Makefile b/tools/testing/selftests/mm/Makefile
>>>>> index 02e1204971b0..15c734d6cfec 100644
>>>>> --- a/tools/testing/selftests/mm/Makefile
>>>>> +++ b/tools/testing/selftests/mm/Makefile
>>>>> @@ -79,6 +79,7 @@ TEST_GEN_FILES += hugetlb_fault_after_madv
>>>>>     TEST_GEN_FILES += hugetlb_madv_vs_map
>>>>>     TEST_GEN_FILES += hugetlb_dio
>>>>>     TEST_GEN_FILES += droppable
>>>>> +TEST_GEN_FILES += guard-pages
>>>>>     ifneq ($(ARCH),arm64)
>>>>>     TEST_GEN_FILES += soft-dirty
>>>>> diff --git a/tools/testing/selftests/mm/guard-pages.c b/tools/testing/selftests/mm/guard-pages.c
>>>>> new file mode 100644
>>>>> index 000000000000..2ab0ff3ba5a0
>>>>> --- /dev/null
>>>>> +++ b/tools/testing/selftests/mm/guard-pages.c
>>>>> @@ -0,0 +1,1168 @@
>>>>> +// SPDX-License-Identifier: GPL-2.0-or-later
>>>>> +
>>>>> +#define _GNU_SOURCE
>>>>> +#include "../kselftest_harness.h"
>>>>> +#include <assert.h>
>>>>> +#include <fcntl.h>
>>>>> +#include <setjmp.h>
>>>>> +#include <errno.h>
>>>>> +#include <linux/userfaultfd.h>
>>>>> +#include <signal.h>
>>>>> +#include <stdbool.h>
>>>>> +#include <stdio.h>
>>>>> +#include <stdlib.h>
>>>>> +#include <string.h>
>>>>> +#include <sys/ioctl.h>
>>>>> +#include <sys/mman.h>
>>>>> +#include <sys/syscall.h>
>>>>> +#include <sys/uio.h>
>>>>> +#include <unistd.h>
>>>>> +
>>>>> +/* These may not yet be available in the uAPI so define if not. */
>>>>> +
>>>>> +#ifndef MADV_GUARD_POISON
>>>>> +#define MADV_GUARD_POISON	102
>>>>> +#endif
>>>>> +
>>>>> +#ifndef MADV_GUARD_UNPOISON
>>>>> +#define MADV_GUARD_UNPOISON	103
>>>>> +#endif
>>>>> +
>>>>> +volatile bool signal_jump_set;
>>>>
>>>> Can you add a comment about why volatile is needed.
>>>
>>> I'm not sure it's really necessary, it's completely standard to do this
>>> with signal handling and is one of the exceptions to the 'volatile
>>> considered harmful' rule.
>>>
>>>> By the way did you happen to run checkpatck on this. There are
>>>> several instances where single statement blocks with braces {}
>>>>
>>>> I noticed a few and ran checkpatch on your patch. There are
>>>> 45 warnings regarding codeing style.
>>>>
>>>> Please run checkpatch and clean them up so we can avoid followup
>>>> checkpatch cleanup patches.
>>>
>>> No sorry I won't, checkpatch isn't infallible and series trying to 'clean
>>> up' things that aren't issues will be a waste of everybody's time.
>>>
>>
>> Sorry - this violates the coding styles and makes it hard to read.
>>
>> See process/coding-style.rst:
>>
>> Do not unnecessarily use braces where a single statement will do.
>>
>> .. code-block:: c
>>
>>          if (condition)
>>                  action();
>>
>> and
>>
>> .. code-block:: c
>>
>>          if (condition)
>>                  do_this();
>>          else
>>                  do_that();
>>
>> This does not apply if only one branch of a conditional statement is a single
>> statement; in the latter case use braces in both branches:
>>
>> .. code-block:: c
>>
>>          if (condition) {
>>                  do_this();
>>                  do_that();
>>          } else {
>>                  otherwise();
>>          }
>>
>> Also, use braces when a loop contains more than a single simple statement:
>>
>> .. code-block:: c
>>
>>          while (condition) {
>>                  if (test)
>>                          do_something();
>>          }
>>
>> thanks,
>> -- Shuah
> 
> Shuah, quoting coding standards to an experienced kernel developer
> (maintainer now) is maybe not the best way to engage here + it may have
> been more productive for you to first engage on why it is I'm deviating
> here.
> 

This is not the only comment I gave you in this patch and your
other patches.

thanks,
-- Shuah


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0b-00069f02.pphosted.com (mx0b-00069f02.pphosted.com [205.220.177.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id AA1E956B81;
	Fri, 18 Oct 2024 16:42:11 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.177.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729269733; cv=fail; b=g1vL/sjKOn+O4NjJfax+JjYzg6V61kT0RSqNXyz1DQqSQBiqd1ld1IjbiY/3SskEYoGOPYYAYDI3e/Uj4td9PYBFlVh/ymWrel2PRMkDBzcriL8d+VYod8o+rAr8hISupvVJws71f/cJl+vyUgu44tFHXhR4kkVdtV00z4haE1U=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729269733; c=relaxed/simple;
	bh=duceKGehCuf4HO5Eu/kcxbjIUJHUBa4aguX3C7WXsbY=;
	h=Date:From:To:Cc:Subject:Message-ID:References:Content-Type:
	 Content-Disposition:In-Reply-To:MIME-Version; b=jRdVApZuQg+54RO/Sj9EJXTUl/Ust1V1WtJQlsu+J8+dE73X2aGRqQudNCtQBDPzD/etb1KuQ9s1W/lJv6QZy2WgQkxrAIeFp6/Rx+DWtWzt5UbhS4bPgXd7yD1MCrf0sXU5s42OmyQxenIoHeMCyf9adTHSIbM0Fqhj0UI9kdU=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=FX7ERcfG; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=zDCLS69i; arc=fail smtp.client-ip=205.220.177.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="FX7ERcfG";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="zDCLS69i"
Received: from pps.filterd (m0246630.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49IEBgMa019358;
	Fri, 18 Oct 2024 16:41:42 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-type:date:from:in-reply-to:message-id:mime-version
	:references:subject:to; s=corp-2023-11-20; bh=4Ja7LVSr9ZxZLpIZ4H
	r1LklnUF4bv5RwIogxymt3nMI=; b=FX7ERcfGUjcmjcOyC9Cs9z3cK9hq/FQKJ/
	5xqUZ6ZHzsXqHgoC2Z1c7zuHyoUlxOw64QisP0o/DTCHfx2cUylk0eTvI70l2Y7c
	PTQ3EJRF0Hd8Mkvj0GHqTwLaSUJupbEUuCe3RYsXoNb8j5rCGrAezhf1sPyVem9A
	/ADoq5mVOE9wQn0BhAn49bSWeaHjpF/XK/aISxJOnACt/OAA6Ud4DOgKh9Gkr6Me
	NVzAslrOXetFHSKgy8hVNeIdwb7492bjTY7qRXevvfXkx0+dI8RBn1X2sou2J8yz
	cKYFXkPyyIWpsaLmDO9U0ZRsIiHzec5OcpBs6+fW2LKHYSsqUkTQ==
Received: from phxpaimrmta01.imrmtpd1.prodappphxaev1.oraclevcn.com (phxpaimrmta01.appoci.oracle.com [138.1.114.2])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427fhcrvdn-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 16:41:42 +0000 (GMT)
Received: from pps.filterd (phxpaimrmta01.imrmtpd1.prodappphxaev1.oraclevcn.com [127.0.0.1])
	by phxpaimrmta01.imrmtpd1.prodappphxaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49IG6Ilk027100;
	Fri, 18 Oct 2024 16:41:41 GMT
Received: from nam10-mw2-obe.outbound.protection.outlook.com (mail-mw2nam10lp2044.outbound.protection.outlook.com [104.47.55.44])
	by phxpaimrmta01.imrmtpd1.prodappphxaev1.oraclevcn.com (PPS) with ESMTPS id 427fjbtm2j-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 16:41:41 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=BYdj190P2TdMlFKekcnsxkHrtCcRkEC25Sz+METIw81m/a/SKg34OMpm2BV/p96gWQNhRPGaKJcoGsQcfdgwW03FZqX15du2ep/ujhJoKOcdaHOfliYoOTDGemKpTW5Depwxb+7QqfSG51qhJSKWmMDb6PrjBUrzusyTnzF3vZoqKNlBTKntp2XcYiaDssDUYX+Qn4J41pZyrxo4KciRtKVUUbn6VYGw45oM+CeEDqvWgIxaGDNatSAFq+F/ViF5eQgcm29JezZxTG8ERH/D/0eS/fH2vwdwmG4FM3wmfrSTF1ptRGHTUYObUJ7j5LiZ/H7dw5J+9ckC1mq29eStdQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=4Ja7LVSr9ZxZLpIZ4Hr1LklnUF4bv5RwIogxymt3nMI=;
 b=wx4AZeaU0icQpbAUAvRNuGz89Ox29h0tzwQJzv/LoLvk+AKgnVOVqBjHfL64WeNi9TzyBq0TnHBEX/5hrRR1TqISRV4xqPoI/LG0rHjoXYSNUDTeuFe5zNQQ2M42rw6kTiNZvfda3V8pD+XWZ4FmXUr610TVlPJt1JDYtyup3KA/pvm6Lr8Fy2bDCc1OGeNAsvX87rZhpDtCtLiYuJHcXsipqLKFYY2hurpm2YlwXY8DHyy8JGzNnRF1YTRfIaNPi1MYw4ywQ2rhO1ieRPLHjOiIE8vTwUyA/6pVviqq9cc2m/bWRcg8tEtFJf2jqRU2JfW0mgDM/YgJHeIsIPIJfg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=4Ja7LVSr9ZxZLpIZ4Hr1LklnUF4bv5RwIogxymt3nMI=;
 b=zDCLS69irvpSjPfK6d2v5NeWH9uI3sFkrG8dTCesoC2z8iH/qObuIBpyTyYuJ5ABGB3uCbM/QLKTFAJtLcvEXkmcBZc+6GhOuiumvbQpS5I924q3JwZv3jXq4KvKoj6smHpekdzNLcBsOvEf/p1oawUJlqHXMqdJ9cu6YJf1BZ4=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by SN4PR10MB5608.namprd10.prod.outlook.com (2603:10b6:806:20b::8) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.18; Fri, 18 Oct
 2024 16:41:38 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Fri, 18 Oct 2024
 16:41:38 +0000
Date: Fri, 18 Oct 2024 17:41:34 +0100
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Shuah Khan <skhan@linuxfoundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>,
        Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>, Vlastimil Babka <vbabka@suse.cz>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>
Subject: Re: [PATCH 4/4] selftests/mm: add self tests for guard page feature
Message-ID: <a64650ea-fef3-4d6c-8a36-3fab73f7a0bf@lucifer.local>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <8b1add3c511effb62d68183cae8a954d8339286c.1729196871.git.lorenzo.stoakes@oracle.com>
 <1d0bbc60-fda7-4c14-bf02-948bdbf8f029@linuxfoundation.org>
 <dfbf9ccb-6834-4181-a382-35c9c9af8064@lucifer.local>
 <22d386cd-e62f-43f9-905e-2d0881781abe@linuxfoundation.org>
 <7bbfc635-8d42-4c3d-8808-cb060cd9f658@lucifer.local>
 <3a41a1b5-e9a7-43db-b50e-84d6cc275d10@linuxfoundation.org>
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <3a41a1b5-e9a7-43db-b50e-84d6cc275d10@linuxfoundation.org>
X-ClientProxiedBy: LNXP123CA0023.GBRP123.PROD.OUTLOOK.COM
 (2603:10a6:600:d2::35) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|SN4PR10MB5608:EE_
X-MS-Office365-Filtering-Correlation-Id: fb193751-3e76-4024-d4a7-08dcef93bc53
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam:
	BCL:0;ARA:13230040|7416014|376014|1800799024|10070799003|366016;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?UTREvyVooGSf7S4/k/bmg1CpV9jn8xC0n0X7sQ3/HN+KsLCsd/GMov+16DEK?=
 =?us-ascii?Q?nAyzlET3zClibWVsct1I4A30uePZ9wctmznL+06Oe88mJ9NmC62HggltTE/t?=
 =?us-ascii?Q?PUFcTjZ89sCOVOD/kScI9tHSlKmwUrEUyeacgbcFvsGHCf6uSbufYuGalksK?=
 =?us-ascii?Q?JE762ylGJLng+sewdDYGWJqYOmhwSSyUgyKTpn4fD86uNKpYcXhDMoMPjJCq?=
 =?us-ascii?Q?iKbF0sTZcRe+ZLKGB4fJWcYEdekTXfQCDmc+FFVc2GROL88DG36AfgNoWImB?=
 =?us-ascii?Q?XgpUlbsUZsTQlo+gLTPvZptXQ9OuETIZjt+/pf/3FfjFrKrgMqcg7WFXDivL?=
 =?us-ascii?Q?7kd7zZDxrxyXz9rGWNay0PKQ6io/DMIaMnUnfugOsIeJ+QchtfbDO+uJKbRK?=
 =?us-ascii?Q?3XHCHVLjv0Q3mPYP1Fvyx+V7mZ69Qzh9e7QmEeT4c2svRUzVa+hAm0OqScBu?=
 =?us-ascii?Q?ftWHE/Frfeczx5EBR+t9pdMpuq2p8NqTvx8MB2F8+2t2i4J3A1xr2aqHV0Y8?=
 =?us-ascii?Q?6BRYU2JDbQGcPaPFi5qKvu7zkzSJ7qjFkDajDNmd6wM7jQc4gYXamZN4V+qg?=
 =?us-ascii?Q?sAROgFFTLUmHo6jUzCEma8FfbPdh6+G3aQC5KAzdW57Q727VFPkIV5sRYli9?=
 =?us-ascii?Q?syi2rOWnf9PamPtjopint3Ad0TyJ2E0UirYRdw9iYc9ji+BgN67aSfpmXfqY?=
 =?us-ascii?Q?mRw2a0wHPQ8guWKRoneAktWVWzlMZ2hXJ3wzDLt0rNA7CQIgBa7p9CU0GUqN?=
 =?us-ascii?Q?1KGJtKG0q3ROoKy49f2erH7zWKR17bo9Y9ukwtbo6mBimeqJ5hUxaKVxdjqU?=
 =?us-ascii?Q?ufF2PDdEE/Rq3G8rWyhIXxHhTTtcLIj1SKDjsDP1GaztonmxcaqsbfJjTktH?=
 =?us-ascii?Q?t1LM6U1QfInIvqMoUeGefx2vm2B5mzbMRGDM8opJf7ouYVSx6iKCNR2Ikz1D?=
 =?us-ascii?Q?ddl40BpT3ZtLGH3gnGB8YDTd0J2zerNUeQtGrDhOtXIQdLO4Gxt1FNbeK9L/?=
 =?us-ascii?Q?vc4T0HaVc6ZTWWbnkt3y2FKPEpjK8dKvADsaMNXxNg1VBPwoiqIDz7UMsvxT?=
 =?us-ascii?Q?sLqkaG1Tcban1LyoXQKGen7Rz0bby4UkZ53vg5tApoq2PXJgmwfjkbUxLIps?=
 =?us-ascii?Q?rrjy+RgEwx/fTO2ALXO43Qlaxhi2GVz3QVoBvfP1vahJRL5droK8sm9O+QYz?=
 =?us-ascii?Q?2vDq1/rJObvipNEsPpX7RLvKzlLRSjE8D7yebsnKj50WUwEiy+i8ZeZWqskU?=
 =?us-ascii?Q?0tyXSopCEhsdNHkOW7I7Fe2OdFuCXpq2sZHxDGGmuQgdWHk1ycxrfOC2jfWJ?=
 =?us-ascii?Q?Ng6vudHk0i5e5EshJmeUiREw?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(7416014)(376014)(1800799024)(10070799003)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?I+r1L4HOCPwAJNnILlm/oqxHBUxhGfrvx6/hRLw3EtWYdQwQSDNXZqPKadWc?=
 =?us-ascii?Q?8ZxZGbDCe59wMZFFRKtLaiVoGCoWWrZqrn5n9cM/498KkLaD5pywmWe5lY1k?=
 =?us-ascii?Q?BhXbfWIdQwwP6+9UiGl3hc76Q9Dm4oLMZS8BgvWUjvqvf5+GlxkbBuqjGG5X?=
 =?us-ascii?Q?BEohEwP68xhuqmQwZiJZ3CXP1aoQhXnA8DY4RC2N2KHF7jsUbWf09ShaRbWY?=
 =?us-ascii?Q?C55zOoEbmVsMgJtE6vPfbwEe/3KyosWxAli4DvO5Rp/NGq965pSI+MnGlFNM?=
 =?us-ascii?Q?FvMpvu3bKeBt2m8x+CTN0v8B1ZnnHWbfJG2AaK8tzTnrQLVgvESfWqJjcDzv?=
 =?us-ascii?Q?5iBfurrncvwLT+N4wAJLSLD5OLEp7M+5bEeguBNhSRfDeoybipJm+K+s6jpE?=
 =?us-ascii?Q?uxZyUW4xx6jxjQ5vP7JPp47R4wGFUSR8k43OAo1XGPHv+4mOmfVaE725v/Zp?=
 =?us-ascii?Q?rcLt7aqdk6nR7hCyv7BiSqVfnq7ZZno8Vt7a151sdwOEUWJI46WF/Xu+RFMk?=
 =?us-ascii?Q?PQEZxVaMZ2Klf2TIZOb1Rhw5YHzQzdEYqh4hA7q7jV6A5VRwfMxB7UD0IvRt?=
 =?us-ascii?Q?P8i+CvHKM0K0nkhIRIxmuCcSCfUJYD9M0j3IOYPf+Fkim4yXSmNIFYeMUvls?=
 =?us-ascii?Q?QWfWZ2YmcAioQcOfCmYp6P4Z3G74nn8en7tb8iwQVABfaVG70CnkH7FHgQnO?=
 =?us-ascii?Q?tPDbwPwyRfTAcRddZNLDk+6XLEAdHTmrFW9HujkBRGsfax/kcAq0Z2JKQkoL?=
 =?us-ascii?Q?f6rUxorzlnFID6hoIxc0+UxZnrxdOqziIlXNuR0ZwDzpDXFulAD4idgqVCY0?=
 =?us-ascii?Q?LcODF2LPeqIDcNkZr8z/9p1Nqw9im0rb3aTMXnfIE89Ms1/Bfer/DZRT05Z1?=
 =?us-ascii?Q?5yHtHATqGkRpk1+FAQ9iivMNj/69X5SY/h1701mKnapMkd2UKo94cNbQZ3nU?=
 =?us-ascii?Q?NtIEw4EDI2ZSFJpNfaqegz6vd0FbDmiIL18rtYDi5BMgWuHMA9fztfe4bJSA?=
 =?us-ascii?Q?XuBZM2vifCBoF5ausav0SI8p9UX77ibb720IJhmkez4frTotHUaC139auFAF?=
 =?us-ascii?Q?DQZrmK+J2mErvkDgJMJAVEIKwfUnlLCdM5d1+brtpnNpAiWpR+2f1/sAFMpC?=
 =?us-ascii?Q?T4AMy4USjPXNwLEKK47W6pAHoQ7GCJAKFE3BlKDuADBdbJ5YUXyhp6lIMkXZ?=
 =?us-ascii?Q?tiuTIzBFZX+lcaP4A4ERguPaaPUXW4Gzmu65h7bPui92sVGCfSQAIlkVCXJI?=
 =?us-ascii?Q?UaI6OuN3d6rnICrtizlhTTZWCtqUcDqFX/LEOZdj+6xBvGSCDgN895NmAm3S?=
 =?us-ascii?Q?oSH3uOXmDDhfhhcA28CQSPMeudDdGtq4VWEJZthnonLJHTq841oUpaY2dB+Q?=
 =?us-ascii?Q?627sBl7vjMIeRFbuoXEvBc7dly18CDfBv1OqDDXKH9JUpEaO/IqYtV1lHrVt?=
 =?us-ascii?Q?8t3+cYnscH3UwXjovlipRkmZrIIfYMuyuLGWwFLo18cuKmA9XI3EgHUHIaSP?=
 =?us-ascii?Q?8PY2fmwlqGeC1uUJ8xq9cvX8KVRPpQ8IkjMopkLQ5IPbDG9UlHcHdGVQ+5QX?=
 =?us-ascii?Q?Kq0meRv/iHqhHO8oOI9R4BnQ1mpSiB5CCj6qMlbxNECwJo18FXkouT8/5GVN?=
 =?us-ascii?Q?CCKTC/I1jP8zrdDnfFpQp+tOk3CI17dx/xPes/kJAtCHSkZ7Ei/+vMU2gFvX?=
 =?us-ascii?Q?opip6g=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	DmnvqR4kIcs/6SyTpG27i10MBySOPBhRO+tjaoXSbvOfEpG2tAs3mkkmXz9NoRmzPd9yUQlesko3LSmxaMdf40yE5kGolvAxh/GQAE+7ZUaw4XH72LhjPptV7wUrp8jmw85XgdMU4uRL3eH0cLfV05ySmUsl/UGj/kgyYWo8OOwEX+J47nAD9XgNtrHwEpOY8g+LHKHrsp0oKYipPj46JCnobpO0Xq+BmCj4ncnY3kJdSbk6yiqZU/Qn0N46DjEUbyHADDE28obAekxTLUUB5MWQx1/k3zXsurAxVJmfJzS8flq//Qb16br8GMih5BkEOi5fCiJL2IUQ/JvV1syuF7LvEgGdI6hk9u5QffdN3Vj0kFnMWTa8wnaC4LqxjBUa4NL92BZJkIvWDOzD8czlOXS0CSIIJA5r1TXUP5befPaVTZp07b3jTBq1riki9ywevZ/irn+mfbVozXlEpb6bPIHaXHIkTzQ2PoqfL3A6dLXHvdr6lq7JyWIte09mysQZ+q7Jo1JXoxnjX1np9WZtPdVyJOywUdDlObc2hAdCWlqXKjx94GubeVH102u+KLjCfboSzZCYV8u71GAM5MPRAh+FTqShvk+PzGzwyXg3DdI=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: fb193751-3e76-4024-d4a7-08dcef93bc53
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Oct 2024 16:41:38.1213
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: fG1UMXU4M9/78JlttFtn1AGh6sZIS7HvD7PasVANy5+CyEqBvxdS6mq/zU11UDjuLbUSWUEDUe2DSaSfb2dvSStdGpZv1U0Psz+rr23L8oo=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SN4PR10MB5608
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-18_12,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 mlxscore=0 malwarescore=0 adultscore=0
 bulkscore=0 spamscore=0 mlxlogscore=676 phishscore=0 suspectscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2409260000
 definitions=main-2410180106
X-Proofpoint-GUID: B9Gjdww84tO5fHuAYXPUDw6gzP7lzXcK
X-Proofpoint-ORIG-GUID: B9Gjdww84tO5fHuAYXPUDw6gzP7lzXcK

On Fri, Oct 18, 2024 at 10:25:55AM -0600, Shuah Khan wrote:
[snip]
> > > Sorry - this violates the coding styles and makes it hard to read.
> > >
> > > See process/coding-style.rst:
> > >
> > > Do not unnecessarily use braces where a single statement will do.
> > >
> > > .. code-block:: c
> > >
> > >          if (condition)
> > >                  action();
> > >
> > > and
> > >
> > > .. code-block:: c
> > >
> > >          if (condition)
> > >                  do_this();
> > >          else
> > >                  do_that();
> > >
> > > This does not apply if only one branch of a conditional statement is a single
> > > statement; in the latter case use braces in both branches:
> > >
> > > .. code-block:: c
> > >
> > >          if (condition) {
> > >                  do_this();
> > >                  do_that();
> > >          } else {
> > >                  otherwise();
> > >          }
> > >
> > > Also, use braces when a loop contains more than a single simple statement:
> > >
> > > .. code-block:: c
> > >
> > >          while (condition) {
> > >                  if (test)
> > >                          do_something();
> > >          }
> > >
> > > thanks,
> > > -- Shuah
> >
> > Shuah, quoting coding standards to an experienced kernel developer
> > (maintainer now) is maybe not the best way to engage here + it may have
> > been more productive for you to first engage on why it is I'm deviating
> > here.
> >
>
> This is not the only comment I gave you in this patch and your
> other patches.
>

And to be clear - I absolutely appreciate your feedback and in all cases
except ones which would result in things not compiling have acted (rather
promptly) to address them.

I am simply pointing out that it's not my lack of knowledge of these rules
that's the issue it's 3 things:

1. Some code doesn't compile following these rules
2. I therefore don't trust the macros in single-line statements
3. I am not a fan of for/while loops with heavily compound statements

1 and is unavoidable, 2 maybe is avoidable with auditing and 3 is
subjective, and is something I have now undertaken to change.

I've heard a number of kernel developers' opinions on checkpatch and the
overall consensus has been that, while the core style is sacrosanct, strict
adherence to checkpatch warnings is not.

This may be worth a broader discussion (outside of this series). One must
definitely account for cases where the syntactic analysis fails for
instance so 'always strictly adhere' is out unfortunately (why I say it is
fallible) however perhaps 'strict adherence except where it is obviously
wrong' is a position one could take.

Your have a significantly different view on this and that's fine, as I said
I always try to be accommodating.

Key thing is we've found a way forward which I will act on.

Thanks, Lorenzo

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mx0a-00069f02.pphosted.com (mx0a-00069f02.pphosted.com [205.220.165.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id EC5E918FC9F;
	Fri, 18 Oct 2024 21:30:59 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=205.220.165.32
ARC-Seal:i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1729287062; cv=fail; b=Qc/RTKEAbhhWeVne9X9EFMlf7nxIWlhFGyzQTDdBhuibfyAnVW67PAGsmn7zW1UI61T/qdXERuJRnc/gMNoSA4SVBxlUPLFlLx09Ubqg2DyNH3GLLHNBxkUaZIrKGQ4KxQx2BrDM/Q3Y1TdeXIZ6QYLLsDay6aR9mJ1HR/B6TgE=
ARC-Message-Signature:i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1729287062; c=relaxed/simple;
	bh=ETf1qhFkgQcWXk72sH7NchXTZ5yG3drpo9nZZ7qQt5M=;
	h=Date:From:To:Cc:Subject:Message-ID:References:Content-Type:
	 Content-Disposition:In-Reply-To:MIME-Version; b=gEKJ19AiEwafDcEYooDHgUp1ci5YGJOZBW6lF6o9BekyifD9rQ5tEhKnXYDweQ0eet1GTrxfkfmE1Adm319xqxtZozLVsE7kCajGZi+dyohaFicQVa5lpaxzhCTlqsZ9MpgekfEG8tCm6wtIaU8GRZnWn/ApVuZUBJnAxLc07n8=
ARC-Authentication-Results:i=2; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com; spf=pass smtp.mailfrom=oracle.com; dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b=Ai9e9OEy; dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b=Wt9si8GS; arc=fail smtp.client-ip=205.220.165.32
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=oracle.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=oracle.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=oracle.com header.i=@oracle.com header.b="Ai9e9OEy";
	dkim=pass (1024-bit key) header.d=oracle.onmicrosoft.com header.i=@oracle.onmicrosoft.com header.b="Wt9si8GS"
Received: from pps.filterd (m0246627.ppops.net [127.0.0.1])
	by mx0b-00069f02.pphosted.com (8.18.1.2/8.18.1.2) with ESMTP id 49IKBeku015487;
	Fri, 18 Oct 2024 21:30:20 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com; h=cc
	:content-type:date:from:in-reply-to:message-id:mime-version
	:references:subject:to; s=corp-2023-11-20; bh=A3CVk/SL1nEOsfS+r5
	XjuTiJCOw61ZLpA8l83nGfMs0=; b=Ai9e9OEyTmFUSvt6KLFLrJ9kCxKkLuNFoh
	jMcp9mEocWidmqLT0mNei20bsdtd91OWptRUcsGKXMZzZajwpzViixnen4egR4+R
	cieeg0qQx2+171DLEBdG9EevFL6NWJfejPGMmNYrheUAhJILRKsrFQyRMLU/m2h5
	hkbsZ779Nx3pyI6RP8/RBIk9gkBbih0pIX1K4xJ/8jjUlNWpFzgKMcgN6ld2tObs
	QkEmBUS0dHMFlQYHIb+KrshA+QYpH0JlOUSZwwbzfEeENpQrAUq1adDPh26jtYwN
	q9Xnq9DWpHKaC8tYCEazrkOcSZksb0AqQw7T0l6BK3mSdNsgEuIg==
Received: from phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (phxpaimrmta03.appoci.oracle.com [138.1.37.129])
	by mx0b-00069f02.pphosted.com (PPS) with ESMTPS id 427gq7stbq-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 21:30:19 +0000 (GMT)
Received: from pps.filterd (phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com [127.0.0.1])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (8.18.1.2/8.18.1.2) with ESMTP id 49IKnvlI013978;
	Fri, 18 Oct 2024 21:30:10 GMT
Received: from nam12-bn8-obe.outbound.protection.outlook.com (mail-bn8nam12lp2174.outbound.protection.outlook.com [104.47.55.174])
	by phxpaimrmta03.imrmtpd1.prodappphxaev1.oraclevcn.com (PPS) with ESMTPS id 427fjc2qvn-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Fri, 18 Oct 2024 21:30:09 +0000
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=Y1YmRcX50/BVg6Iyig3BeV5XMA5uKgJgUgK1rJJFiUyVPbYFfta/uvbtaW/98L3c6yk3LrgdF3wCDD4g4TUwbUAxfCjuo3vIYJM351ILe8MgpsdTkV2GYHtTlRnDjurA4nOEdZb9iP4NvK4UjVEcp+CvU3IcZInYz1VrjCRyz4WyTepQ504c9NHTwG2+z5g9mLbB2IlAQcXGT4nbO7NqO53TlHfnzFB4k/KfwdE/acZoErxXoJywZaz69AHB4RG02aMlUtabJtdCLcQz9lE1tx2HhM2K55K9gS9xKSxkpWPAcyKYCY1y4lJM/DsSVx4X2vamJ0eAJGmC5RfsDJwmyw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=A3CVk/SL1nEOsfS+r5XjuTiJCOw61ZLpA8l83nGfMs0=;
 b=w+PLjJLPiyp2Uw0wh+w02QQkErcbgAeHZjY9V4VP+O8arBjGYX/GdIBixL3SBntmG5y+WwOuuSERxpYBhTsVG+8PaqpJeAfGCFiyfBvVD9r3P9ZM6xaZ5dcwL4kysErwQlzLAsjxvfpVhJ35gH9HgzJgbcvN7Wnd3K/Ka5vK3sjjq+se1sOXxGKesx8jiDj5c2hBGNxjNbLVwgvCwtiYwmmZQEprUh9di5VRkIi7N0GiXpgNzJi6UDfhUj9xiiR+wHF1Vt+X/szOjCxmmSvv9ZUJR3uc5XoQKKNw97zLTAMTd+Hpo57V8kdruL7LPRNPRNTfy2S99cJwKxjOJ2LE2w==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=oracle.com; dmarc=pass action=none header.from=oracle.com;
 dkim=pass header.d=oracle.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=oracle.onmicrosoft.com; s=selector2-oracle-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=A3CVk/SL1nEOsfS+r5XjuTiJCOw61ZLpA8l83nGfMs0=;
 b=Wt9si8GSGFKtN9LRaT1U/nItQKPlmXgbDrCpeR/jP9q5Kw+9b3aEP3m7Q/tJvXB15Fz+Pwq0mNhfhevAhuWld5h022AlrhFBvenNQGpO/vZXUJiSEtOML16tgKsfYz5A6AHq9VZfgxtuzqqmHfb/SDNSZz1tHcpMZiq/0OjGHz8=
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com (2603:10b6:a03:3d0::5)
 by SA1PR10MB5759.namprd10.prod.outlook.com (2603:10b6:806:23d::17) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8069.24; Fri, 18 Oct
 2024 21:30:06 +0000
Received: from SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e]) by SJ0PR10MB5613.namprd10.prod.outlook.com
 ([fe80::4239:cf6f:9caa:940e%5]) with mapi id 15.20.8069.016; Fri, 18 Oct 2024
 21:30:06 +0000
Date: Fri, 18 Oct 2024 22:30:02 +0100
From: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>
To: Vlastimil Babka <vbabka@suse.cz>
Cc: Andrew Morton <akpm@linux-foundation.org>,
        Suren Baghdasaryan <surenb@google.com>,
        "Liam R . Howlett" <Liam.Howlett@oracle.com>,
        Matthew Wilcox <willy@infradead.org>,
        "Paul E . McKenney" <paulmck@kernel.org>, Jann Horn <jannh@google.com>,
        David Hildenbrand <david@redhat.com>, linux-mm@kvack.org,
        linux-kernel@vger.kernel.org, Muchun Song <muchun.song@linux.dev>,
        Richard Henderson <richard.henderson@linaro.org>,
        Ivan Kokshaysky <ink@jurassic.park.msu.ru>,
        Matt Turner <mattst88@gmail.com>,
        Thomas Bogendoerfer <tsbogend@alpha.franken.de>,
        "James E . J . Bottomley" <James.Bottomley@hansenpartnership.com>,
        Helge Deller <deller@gmx.de>, Chris Zankel <chris@zankel.net>,
        Max Filippov <jcmvbkbc@gmail.com>, Arnd Bergmann <arnd@arndb.de>,
        linux-alpha@vger.kernel.org, linux-mips@vger.kernel.org,
        linux-parisc@vger.kernel.org, linux-arch@vger.kernel.org,
        Shuah Khan <shuah@kernel.org>, Christian Brauner <brauner@kernel.org>,
        linux-kselftest@vger.kernel.org,
        Sidhartha Kumar <sidhartha.kumar@oracle.com>,
        Jeff Xu <jeffxu@chromium.org>, Christoph Hellwig <hch@infradead.org>,
        Linux API <linux-api@vger.kernel.org>
Subject: Re: [PATCH 0/4] implement lightweight guard pages
Message-ID: <bddba849-b8ff-4a5c-acd1-51fa761e0402@lucifer.local>
References: <cover.1729196871.git.lorenzo.stoakes@oracle.com>
 <e4985328-dbfa-4c47-9cf9-12aa89ba9798@suse.cz>
 <4b5382fd-e553-4fef-a7c7-a2d3130b948d@lucifer.local>
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <4b5382fd-e553-4fef-a7c7-a2d3130b948d@lucifer.local>
X-ClientProxiedBy: LO4P265CA0111.GBRP265.PROD.OUTLOOK.COM
 (2603:10a6:600:2c3::11) To SJ0PR10MB5613.namprd10.prod.outlook.com
 (2603:10b6:a03:3d0::5)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR10MB5613:EE_|SA1PR10MB5759:EE_
X-MS-Office365-Filtering-Correlation-Id: 23f53542-6c22-4cf5-7d3a-08dcefbc08da
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam:
	BCL:0;ARA:13230040|366016|7416014|376014|1800799024|10070799003;
X-Microsoft-Antispam-Message-Info:
	=?us-ascii?Q?U+wIqh2wc99BKomF7i9fHGNWGA6IGPGaSHYUOemcEceY4fMq4+b5tXNyThZI?=
 =?us-ascii?Q?xjZclPBCviwNqI3d/1lEkvqVDOkRsKvfcgmqlMsXUvnOs3Aj5U4M3zJ5fL/9?=
 =?us-ascii?Q?cnj/8UwveviWoU6+3Epkjhgx4wo5zhYUrXrUpWO3l/Gs8KHYRFbbCCgwsdBI?=
 =?us-ascii?Q?x228LuoX7PpzbUrloybZWHpY+qBDkrauDiUn89S/Lr+nz6x/f3csokBwh3GB?=
 =?us-ascii?Q?SNIwx4/45tJ7Tp78LMtVjyy3QzhptUH/o3QIModt/Lrj9TNJHfTVZ02Ty/2W?=
 =?us-ascii?Q?/NxRNbhZ3p3bhU6b06CvlXnjPegZ0ld1O6c5Ea9OMExsyUefipsvh/TxEjZ1?=
 =?us-ascii?Q?myZ9KKAHTPwixrm30PVDsWgbh+HLpwweZ3smj9sum90Z6lgDLKNn1V5ZMKgP?=
 =?us-ascii?Q?g7H0vxnuFRBc4DNU+XY8yD0avGNGCbQG4eZmeSAMlxxS9AUaJ4072XRrCuvR?=
 =?us-ascii?Q?N5SxO24/vRsxjSmX7FTbkLFmn2R6s/T08wKNEnEtHKTxqgb3qIZeUVvvut5a?=
 =?us-ascii?Q?dJTlMqjyhlui6Jb3zCASpxNWRsCYSdVl94TG6Rqvc6tX4gRl+3aryU0Oc7WV?=
 =?us-ascii?Q?O3/xehGrHTxmueOU0dIbtCZjmbmTVpGl2T/ocRME/1AihV2p96gcAHalWvjq?=
 =?us-ascii?Q?/mhfUaZbsB5qAIk3DFBUn+K0rKW2Y6ONP5AtyAQOoavSTuEUVLHaYHPghn7D?=
 =?us-ascii?Q?G/FJg3xi2sWn44lQiSqg8iX24gyH28VWss0NXZlAZvyfzPDp7awZd4a5Kzlk?=
 =?us-ascii?Q?bpw7f+SmWMI/kuzJtPPaEkXwanvL2QxY6q/116NDFK+BA8z/VoA52L1c9qiC?=
 =?us-ascii?Q?9zlCTGQQZeTOmTKyJdOiokLLTO5gaxp5bfrF9ntWHQPdbAtB3yP92X5usE3Y?=
 =?us-ascii?Q?jkIy+iFq/dF7/kminpnlhgmQCMBh/jvoSKdLs2QLMCHf52525wpNqD4pEvKQ?=
 =?us-ascii?Q?pnu1Enh1e+rDBM1br2Oen750ELkcwaMBBR4AwPVuLdp8DWGKyh9KpvJPk+DW?=
 =?us-ascii?Q?oIjvhS8oNC1H90TbLFG80ONwzWC1bBE0+8rne3Dp+leXQp4JapcLWPRVaQQu?=
 =?us-ascii?Q?Vr34+wd4zsIqRfv3guBhvhIwffk4tGIADFRdJdUYQYK136U+OckQ5Q1vpmVp?=
 =?us-ascii?Q?Npb9PE6BgeroAo/y/9WKlLpffq7mp7yUjyw1JxLVNiuLIXqWcWRw+uIg28/K?=
 =?us-ascii?Q?ERXuxOf6hK2SSJWA2RjmBf+0gCz+6pVvmNxIk02UEAQA0iS28DNTF1Avte8v?=
 =?us-ascii?Q?GJlU5bw1CdWdKLh/KOx5HxW9PgvevbAgoI8Y99Gbg2meEQAcVNB/ivE/uNpM?=
 =?us-ascii?Q?D3NUK/f6VHU6CbdIMKlzcHh5?=
X-Forefront-Antispam-Report:
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR10MB5613.namprd10.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(7416014)(376014)(1800799024)(10070799003);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0:
	=?us-ascii?Q?r8qlu9Ey058HrfpjnfE5ma6qDcJzJzgkK49ojKgc8TURCn19aamXdm9U0XQt?=
 =?us-ascii?Q?LEQMPurWrYAhdWFqIgdeHIBMugOgArWVfdGtv6e9OnO7lVm4QUs23o9GtU9x?=
 =?us-ascii?Q?9Gta6pAaZDMtRuyH+BNNI20lls5eC41qRk3YOqa7hpg1smXzq5is1GfYUxwg?=
 =?us-ascii?Q?S6OJD5CMyp2B9O6wqGMM72tMpdG4kcMGHzWXgeBTW9dOHbjI9OvTv35cEOO8?=
 =?us-ascii?Q?wnL9KS8XLjniYYW8zpVWDLhPdUBkws0cqUb4N3hJgSqCOoJO6trI3ta9Qcv7?=
 =?us-ascii?Q?01c9iy1h403K3FKKpzakQD/lN7Ud85B8pq80G8jvyS3cm8TxeWcau7UmBAaX?=
 =?us-ascii?Q?ur0uymQkB1sY8ip0hiGjrqLkAhHb9krRhaJsVX6xqcJ4aMqmJT1z9SKanaBo?=
 =?us-ascii?Q?wMSB0ohZBwOCnjwgUjI4VQmjTbIcfvOXrt3CPeWOjg0Mg4RZbEhFY+GKCz+T?=
 =?us-ascii?Q?nQMZ8+q7+BM6qBdmC7GKqXVqYektXz4tXsv8HT6XThdbZ7/NxPV+0FcsNW6j?=
 =?us-ascii?Q?ERk3es+FOV+2SZ07KhHZyeVcllUQRSdVxDkLQFpN4J3o3tVjGuP35y7QRcwF?=
 =?us-ascii?Q?U71OoUteeBM1O3vuzZ1enH/kl110gFam5Rklw+obKlUA1/QwDaygiKqPiAVX?=
 =?us-ascii?Q?T9i28CYIlG8HH51suyC0USORrHS5jb3I3IioFfqBlDxQ6eVN+2oEBUDhYmec?=
 =?us-ascii?Q?OmNlE+HgyleJi6OPsPlsrsVGs8bALGb/DX62iFWEP7GYtjB8WAgQZ5pgscxg?=
 =?us-ascii?Q?sgf/EHiItQS9Mx40GNZ2UR4v2Qsoc3wsx9BBgssxXYtcpaWkYGbK900L13B7?=
 =?us-ascii?Q?juW57kgtBIdtT71J6E8/HNMqQRKxM+BmeG6Vpeh0iZnYovFbkrFNRzxQvSiy?=
 =?us-ascii?Q?GzmWc5BIgQBDIKlAOJ5nmJ6i9skeTY9syPMZnTOKTGlporE2TtNQ6Rvq7/uw?=
 =?us-ascii?Q?dYpSSUQQzK6K4w/6V3Uc62qzZAMxxrmQOjo5+YL+3HFTDWmAkXCxlJGAnQxP?=
 =?us-ascii?Q?fjARHipS11z7hKoqLUfztVj6if8SBqtn0DWoNaMxnLd6jssiuqWAyI7l1okC?=
 =?us-ascii?Q?w3HaC7jkLXPwbD4x2WNv8GFvR0tZ8dTJLIAICd0ASA3gnYWHPPFe4JBfMbK6?=
 =?us-ascii?Q?i3JtdVfF1ajpCZWoalA5k7PLlThosKFbbHcQ01CLRdqrF489qbyndZXl+U9V?=
 =?us-ascii?Q?ygRaArjNNYW1LYVq+8NhNYxbgPfP1+EnjsqS80+0dXUEaRYRERq5/x2XhwNa?=
 =?us-ascii?Q?W46EOhqreWvl5CFarXtJhIWkKFtDMe3Q3FjLz9mPJVoXVj2WYelaXpFGccwM?=
 =?us-ascii?Q?XryyvBatBTnxSVrAAAL9R7ZzVtEAV01zXoHU97ErmjV8WuijhGEkMzMjZVOh?=
 =?us-ascii?Q?X75T0Dln1BmR/MGGqUd/ODxp865twmUK93T8Ufl0Y5+6oNQiKY60Ywa5kUBE?=
 =?us-ascii?Q?QM7I/CJ1/uP+sWL0dSWvQgxQW03O9qP68R/2XptHCas8ZZKNvBWZ6uQ/8UmC?=
 =?us-ascii?Q?/OjZM5tew1D9IUXoR8IBEiGMeVby2awe/X5HizpEsk4pD5ySNp+BFyliJTDv?=
 =?us-ascii?Q?6EEU+BZxF4Qr67RJpncdkddxDL/xXQ4XU/qYQ+xPWAClsEpF3aOCwHrPOSNw?=
 =?us-ascii?Q?RbdwzetHZMCtSuIppoFfZVeIvWCWyf7lUBhCI8PqT8/SHYtU0P1sBmNQBuRi?=
 =?us-ascii?Q?hG3C+Q=3D=3D?=
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0:
	AnJirIciKmTLXEsAwMt1GhBXdepy/9EU58z6gKcP4drQRMUNBsoiQFZupcnCE/AMBNj4fANTX4a2aasAdJiS0jlzDWmZUqJ54hLT48fB3OM1l1dGioQrVXo9gy2biWw11dCMw2vQ6eJbqb938loaPXiecMSMLPjixKLvFXnPoOYDTKEFWrYkcNepjEloEq5TAeWDRK6IokH/YAglC8s4aJdzwDbIwxpRW/sMfjypWOGHF6l2C/BGzczL1JEVv7e3RBmYoXnmmR7mtPXhCLG2X99m83PXuDNuGLEh2NUK/8Z/kU6N7/QwAVQAiPBwH7+2COJ4qiMFO9JkpycbUIudo5txzDrD1/9QERskf9R9x/ODO62uhxvb9T0Lv9iBBr7GI/pAJSqdT2DzJfpnLtoNVjWwdsm2KUvRKLg0GLdAaO1mHwGACW6BUMQN770+vzQpoZJoFMYZ18oeJL93DGahL2UenMGLaRdfMMAlQ5PAeWs0OjxD9DyuDsDwUrGGGsaImBuBgPpB1y+FLy86UVQT4o+uJAf8/U7RxUAij7q4OSCa7JdE/oYnLuoDfikIgQAGRdp8bj1kbUCbWakseFshFThbC4H6yqeu6+z33sNNkVs=
X-OriginatorOrg: oracle.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 23f53542-6c22-4cf5-7d3a-08dcefbc08da
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR10MB5613.namprd10.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Oct 2024 21:30:06.2492
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 4e2c6054-71cb-48f1-bd6c-3a9705aca71b
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: /L0AKrrE5SizRBQ1kA4cT16UUEvRiF8IJg1/faqUirWHT59Q4ijQFlHIAptwHCjajq8aH/9v8oKkwjRz4p+xzcUjRIzHWnaVIZ8dtyGz604=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA1PR10MB5759
X-Proofpoint-Virus-Version: vendor=baseguard
 engine=ICAP:2.0.293,Aquarius:18.0.1051,Hydra:6.0.680,FMLib:17.12.62.30
 definitions=2024-10-18_16,2024-10-17_01,2024-09-30_01
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 malwarescore=0 phishscore=0 mlxscore=0
 mlxlogscore=962 bulkscore=0 spamscore=0 suspectscore=0 adultscore=0
 classifier=spam adjust=0 reason=mlx scancount=1 engine=8.12.0-2409260000
 definitions=main-2410180137
X-Proofpoint-ORIG-GUID: 2TGVGO2ZTDgs_-rivij18f3oVEX_0u5A
X-Proofpoint-GUID: 2TGVGO2ZTDgs_-rivij18f3oVEX_0u5A

On Fri, Oct 18, 2024 at 05:17:56PM +0100, Lorenzo Stoakes wrote:
> On Fri, Oct 18, 2024 at 06:10:37PM +0200, Vlastimil Babka wrote:
> > +CC linux-api (also should on future revisions)
> >
>
> They're cc'd :) assuming Linux API <linux-api@vger.kernel.org> is correct
> right?

As discussed on IRC, no I was being a little slow here and hadn't realised
you'd added them, apologies!

Will add them on future respins, sorry guys :)

>
> > On 10/17/24 22:42, Lorenzo Stoakes wrote:
> > > Userland library functions such as allocators and threading implementations
> > > often require regions of memory to act as 'guard pages' - mappings which,
> > > when accessed, result in a fatal signal being sent to the accessing
> > > process.
> > >
> > > The current means by which these are implemented is via a PROT_NONE mmap()
> > > mapping, which provides the required semantics however incur an overhead of
> > > a VMA for each such region.
> > >
> > > With a great many processes and threads, this can rapidly add up and incur
> > > a significant memory penalty. It also has the added problem of preventing
> > > merges that might otherwise be permitted.
> > >
> > > This series takes a different approach - an idea suggested by Vlasimil
> > > Babka (and before him David Hildenbrand and Jann Horn - perhaps more - the
> > > provenance becomes a little tricky to ascertain after this - please forgive
> > > any omissions!)  - rather than locating the guard pages at the VMA layer,
> > > instead placing them in page tables mapping the required ranges.
> > >
> > > Early testing of the prototype version of this code suggests a 5 times
> > > speed up in memory mapping invocations (in conjunction with use of
> > > process_madvise()) and a 13% reduction in VMAs on an entirely idle android
> > > system and unoptimised code.
> > >
> > > We expect with optimisation and a loaded system with a larger number of
> > > guard pages this could significantly increase, but in any case these
> > > numbers are encouraging.
> > >
> > > This way, rather than having separate VMAs specifying which parts of a
> > > range are guard pages, instead we have a VMA spanning the entire range of
> > > memory a user is permitted to access and including ranges which are to be
> > > 'guarded'.
> > >
> > > After mapping this, a user can specify which parts of the range should
> > > result in a fatal signal when accessed.
> > >
> > > By restricting the ability to specify guard pages to memory mapped by
> > > existing VMAs, we can rely on the mappings being torn down when the
> > > mappings are ultimately unmapped and everything works simply as if the
> > > memory were not faulted in, from the point of view of the containing VMAs.
> > >
> > > This mechanism in effect poisons memory ranges similar to hardware memory
> > > poisoning, only it is an entirely software-controlled form of poisoning.
> > >
> > > Any poisoned region of memory is also able to 'unpoisoned', that is, to
> > > have its poison markers removed.
> > >
> > > The mechanism is implemented via madvise() behaviour - MADV_GUARD_POISON
> > > which simply poisons ranges - and MADV_GUARD_UNPOISON - which clears this
> > > poisoning.
> > >
> > > Poisoning can be performed across multiple VMAs and any existing mappings
> > > will be cleared, that is zapped, before installing the poisoned page table
> > > mappings.
> > >
> > > There is no concept of 'nested' poisoning, multiple attempts to poison a
> > > range will, after the first poisoning, have no effect.
> > >
> > > Importantly, unpoisoning of poisoned ranges has no effect on non-poisoned
> > > memory, so a user can safely unpoison a range of memory and clear only
> > > poison page table mappings leaving the rest intact.
> > >
> > > The actual mechanism by which the page table entries are specified makes
> > > use of existing logic - PTE markers, which are used for the userfaultfd
> > > UFFDIO_POISON mechanism.
> > >
> > > Unfortunately PTE_MARKER_POISONED is not suited for the guard page
> > > mechanism as it results in VM_FAULT_HWPOISON semantics in the fault
> > > handler, so we add our own specific PTE_MARKER_GUARD and adapt existing
> > > logic to handle it.
> > >
> > > We also extend the generic page walk mechanism to allow for installation of
> > > PTEs (carefully restricted to memory management logic only to prevent
> > > unwanted abuse).
> > >
> > > We ensure that zapping performed by, for instance, MADV_DONTNEED, does not
> > > remove guard poison markers, nor does forking (except when VM_WIPEONFORK is
> > > specified for a VMA which implies a total removal of memory
> > > characteristics).
> > >
> > > It's important to note that the guard page implementation is emphatically
> > > NOT a security feature, so a user can remove the poisoning if they wish. We
> > > simply implement it in such a way as to provide the least surprising
> > > behaviour.
> > >
> > > An extensive set of self-tests are provided which ensure behaviour is as
> > > expected and additionally self-documents expected behaviour of poisoned
> > > ranges.
> > >
> > > Suggested-by: Vlastimil Babka <vbabka@suze.cz>
> >
> > Please fix the domain typo (also in patch 3 :)
> >
>
> Damnnn it! I can't believe I left that in. Sorry about that! Will fix on
> respin.
>
> Hopefully not to suse.cs ;)
>
> > Thanks for implementing this,
> > Vlastimil
>
> Thanks!
>
> >
> > > Suggested-by: Jann Horn <jannh@google.com>
> > > Suggested-by: David Hildenbrand <david@redhat.com>
> > >
> > > v1
> > > * Un-RFC'd as appears no major objections to approach but rather debate on
> > >   implementation.
> > > * Fixed issue with arches which need mmu_context.h and
> > >   tlbfush.h. header imports in pagewalker logic to be able to use
> > >   update_mmu_cache() as reported by the kernel test bot.
> > > * Added comments in page walker logic to clarify who can use
> > >   ops->install_pte and why as well as adding a check_ops_valid() helper
> > >   function, as suggested by Christoph.
> > > * Pass false in full parameter in pte_clear_not_present_full() as suggested
> > >   by Jann.
> > > * Stopped erroneously requiring a write lock for the poison operation as
> > >   suggested by Jann and Suren.
> > > * Moved anon_vma_prepare() to the start of madvise_guard_poison() to be
> > >   consistent with how this is used elsewhere in the kernel as suggested by
> > >   Jann.
> > > * Avoid returning -EAGAIN if we are raced on page faults, just keep looping
> > >   and duck out if a fatal signal is pending or a conditional reschedule is
> > >   needed, as suggested by Jann.
> > > * Avoid needlessly splitting huge PUDs and PMDs by specifying
> > >   ACTION_CONTINUE, as suggested by Jann.
> > >
> > > RFC
> > > https://lore.kernel.org/all/cover.1727440966.git.lorenzo.stoakes@oracle.com/
> > >
> > > Lorenzo Stoakes (4):
> > >   mm: pagewalk: add the ability to install PTEs
> > >   mm: add PTE_MARKER_GUARD PTE marker
> > >   mm: madvise: implement lightweight guard page mechanism
> > >   selftests/mm: add self tests for guard page feature
> > >
> > >  arch/alpha/include/uapi/asm/mman.h       |    3 +
> > >  arch/mips/include/uapi/asm/mman.h        |    3 +
> > >  arch/parisc/include/uapi/asm/mman.h      |    3 +
> > >  arch/xtensa/include/uapi/asm/mman.h      |    3 +
> > >  include/linux/mm_inline.h                |    2 +-
> > >  include/linux/pagewalk.h                 |   18 +-
> > >  include/linux/swapops.h                  |   26 +-
> > >  include/uapi/asm-generic/mman-common.h   |    3 +
> > >  mm/hugetlb.c                             |    3 +
> > >  mm/internal.h                            |    6 +
> > >  mm/madvise.c                             |  168 ++++
> > >  mm/memory.c                              |   18 +-
> > >  mm/mprotect.c                            |    3 +-
> > >  mm/mseal.c                               |    1 +
> > >  mm/pagewalk.c                            |  200 ++--
> > >  tools/testing/selftests/mm/.gitignore    |    1 +
> > >  tools/testing/selftests/mm/Makefile      |    1 +
> > >  tools/testing/selftests/mm/guard-pages.c | 1168 ++++++++++++++++++++++
> > >  18 files changed, 1564 insertions(+), 66 deletions(-)
> > >  create mode 100644 tools/testing/selftests/mm/guard-pages.c
> > >
> > > --
> > > 2.46.2
> >

